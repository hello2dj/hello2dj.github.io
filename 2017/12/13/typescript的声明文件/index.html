<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>typescript的声明文件 | hello2dj | if you can&#39;t explain it simply, you don&#39;t understand it well enough</title>

  
  <meta name="author" content="hello2dj (dj_amazing@sina.com)">
  

  
  <meta name="description" content="每个人都是带着棱角来到世上，只有磨平棱角才能走的更远">
  

  
  
  <meta name="keywords" content="typescript">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="typescript的声明文件"/>

  <meta property="og:site_name" content="hello2dj"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="hello2dj" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">hello2dj</a>
    </h1>
    <p class="site-description">if you can&#39;t explain it simply, you don&#39;t understand it well enough</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>typescript的声明文件</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/12/13/typescript的声明文件/" rel="bookmark">
        <time class="entry-date published" datetime="2017-12-13T13:58:58.000Z">
          2017-12-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <img src="/2017/12/13/typescript的声明文件/ts.png" title="开篇一图">
<h3 id="开篇扯淡"><a href="#开篇扯淡" class="headerlink" title="开篇扯淡"></a>开篇扯淡</h3><p>上次我们谈论协变和逆变时提到了 typescript, ts 本身是 js 的超集，从名字就可以看出来 ts 为 js 带来了类型，那么如何能写好 typescript？答案是从声明文件开始，若是能写的一手好的 ts 的声明文件，那 ts 的书写必然是手到擒来啊！2333333（我们就不在这里再做 ts 的基本语法的普及了详见<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">handbook</a>）</p>
<h3 id="为什么要有声明文件呢？ts-的声明文件又是什么呢（是以-d-ts-结尾的文件）？"><a href="#为什么要有声明文件呢？ts-的声明文件又是什么呢（是以-d-ts-结尾的文件）？" class="headerlink" title="为什么要有声明文件呢？ts 的声明文件又是什么呢（是以.d.ts 结尾的文件）？"></a>为什么要有声明文件呢？ts 的声明文件又是什么呢（是以.d.ts 结尾的文件）？</h3><p>为什么？我们知道 ts 是 js 的超集也是会编译成 js 的，那么已有的 js 代码怎么和现有的 ts 项目融合呢（即在 ts 中引用 js）？因为 js 是弱类型的，是无法推导出变量的类型的，那么 ts 的编译器自然就无法集成 js 的代码了？此时声明文件就起到作用了，声明文件的目的就是告诉 ts 的编译器，我要引用 js 文件了，js 文件的内容有啥，暴露出来的变量叫啥，类型是啥等等，听着怎么那么像是 C/C++的头文件呢？ts 是强类型语言了，每个变量就都会有自己的类型(类型是不可变得哦)，这些类型都是要声明的，还有接口也是要声明的，而 js 代码是没有这些的，所以就需要声明文件了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">interface Dog &#123;</span><br><span class="line">  bark: (world: string) =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">const tuDog: Dog = &#123;</span><br><span class="line">  bark: (world: string) &#123;</span><br><span class="line">    console.log(&apos;bark&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">interface TextSpan &#123;</span><br><span class="line">    start: number;</span><br><span class="line">    end: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">type Test = (version: number) =&gt; void;</span><br></pre></td></tr></table></figure>
<p>上面的代码我们定义了两个接口类型，和一个 Test 的函数类型，当我们把这些类型定义都放到一个文件里时就成了一个‘声明文件’了，这里打引号的意思是，正常 ts 之间引用是不用专门抽出来写一成一个文件的(当然你要是乐意那也是可以的)，这个例子就是在说声明文件就是一堆’类型声明‘(这里打引号是因为正式的声明文件里也是会声明变量的)，就好比的 C/C++的头文件</p>
<h3 id="举个简单的栗子"><a href="#举个简单的栗子" class="headerlink" title="举个简单的栗子"></a>举个简单的栗子</h3><ol>
<li>新建一个 foo.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// foo.js</span><br><span class="line">module.exports.say = require(&apos;./say&apos;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建一个 say.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// say.js 我们在此假设 o 是string</span><br><span class="line">module.exports = function say(o) &#123;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在新建一个 index.ts</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// index.ts</span><br><span class="line">import * as a from &apos;../foo&apos;;  //此时是会报错的，因为没有foo.ts</span><br><span class="line">a.say(&apos;123&apos;)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>此时编译 index.ts 是无法通过的, 因为没有 foo.ts</li>
<li>再新建一个 foo.d.ts 文件(需同名，这样 tsc–typescript 的编译器在加载时就会去找相应文件)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 但若是 再加一个foo.d.ts文件</span><br><span class="line">export function say(o: string): string;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>此时再编译就会通过了，而且若是调用穿得参数不是 string，也是不会通过的</li>
</ol>
<h3 id="上面是通过包的形式引入的-那么全局方式引入的又该如何呢？答案是-declare"><a href="#上面是通过包的形式引入的-那么全局方式引入的又该如何呢？答案是-declare" class="headerlink" title="上面是通过包的形式引入的,那么全局方式引入的又该如何呢？答案是 declare"></a>上面是通过包的形式引入的,那么全局方式引入的又该如何呢？答案是 declare</h3><ol>
<li>新建一个 foo.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// foo.js 我们在此假设 o 是string</span><br><span class="line">global.say = function(o) &#123;</span><br><span class="line">  return o;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在新建一个 index.ts</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// index.ts</span><br><span class="line">import * as a from &apos;../foo&apos;;  //此时是会报错的，因为没有foo.ts, 并且也没有bark</span><br><span class="line">bark(&apos;123&apos;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>此时编译 index.ts 是无法通过的, 因为没有 foo.ts</li>
<li>再新建一个 foo.d.ts 文件(需同名，这样 tsc–typescript 的编译器在加载时就会去找相应文件)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 但若是 再加一个foo.d.ts文件</span><br><span class="line">delcare function say(o: string): string;</span><br><span class="line">// delcare var say: (o: string) =&gt; string;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>成功 ok</li>
</ol>
<h3 id="通过上面我们可以看出需要通过包引入的我们使用-export-通过全局似的就可以使用-declare"><a href="#通过上面我们可以看出需要通过包引入的我们使用-export-通过全局似的就可以使用-declare" class="headerlink" title="通过上面我们可以看出需要通过包引入的我们使用 export, 通过全局似的就可以使用 declare"></a>通过上面我们可以看出需要通过包引入的我们使用 export, 通过全局似的就可以使用 declare</h3><h3 id="declare-的正式说明参见typescript-spec"><a href="#declare-的正式说明参见typescript-spec" class="headerlink" title="declare 的正式说明参见typescript spec"></a>declare 的正式说明参见<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#12-ambients" target="_blank" rel="noopener">typescript spec</a></h3><p>总的来说就是 declare 使声明引用那些已经在代码执行环境中存在的 变量，函数，类，枚举，命名空间，或者 modules, 例如通过 script 标签引入的包。在 declare 命名空间和 modules 时应注意，只能在顶层是使用 declare, 命名空间内部是不允许使用的，命名空间内部的可访问情况可由 export 控制（想让谁可访问就 export 谁）</p>
<h3 id="有很多的库都有相应的-ts-声明文件，那么怎么安装呢？"><a href="#有很多的库都有相应的-ts-声明文件，那么怎么安装呢？" class="headerlink" title="有很多的库都有相应的 ts 声明文件，那么怎么安装呢？"></a>有很多的库都有相应的 ts 声明文件，那么怎么安装呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @types/node(package-name)</span><br></pre></td></tr></table></figure>
<p>可以在这里<a href="http://definitelytyped.org/" target="_blank" rel="noopener">搜索.d.ts</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当然这里仅仅是简单的做了介绍，通过这个简单的介绍我们可以发现，当我们把声明文件写的完整的时候，基本就是 ts 出师的时候了。(举的栗子是两种分开的，那么在我的 node 项目的某个文件中既有 global 形式又有包的导出形式该怎么做呢？我还没写对，有待努力！各位看官要是知道的话忘不吝赐教（<a href="mailto:dj_amazing@sina.com" target="_blank" rel="noopener">dj_amazing@sina.com</a>）)</p>
<h3 id="在声明文件中-export"><a href="#在声明文件中-export" class="headerlink" title="在声明文件中 export **"></a>在声明文件中 export **</h3><ul>
<li>和declare的差不多，import {export的， declare的 } from ‘’; 都可以被导出， 但是若是使用了 export = something, 那么就只有somethine会被导出了<h3 id="declare-namespace看做是内部模"><a href="#declare-namespace看做是内部模" class="headerlink" title="declare namespace看做是内部模"></a>declare namespace看做是内部模</h3>块即可，不可作为类型，以及值，只是用来分隔代码</li>
</ul>
<h3 id="conditional-type-中可以使用-infer-关键字，常规的类型定义中不能使用"><a href="#conditional-type-中可以使用-infer-关键字，常规的类型定义中不能使用" class="headerlink" title="conditional type 中可以使用 infer 关键字，常规的类型定义中不能使用"></a>conditional type 中可以使用 infer 关键字，常规的类型定义中不能使用</h3><p>推到出 函数返回值类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure></p>
<p>普通类型定义 使用infer会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T extends (...args: any[]) =&gt; infer R&gt; = R;  // Error, not supported</span><br></pre></td></tr></table></figure></p>
<p>参考：</p>
<ol>
<li><p><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">handbook</a></p>
</li>
<li><p><a href="https://github.com/TypeStrong/learn-typescript" target="_blank" rel="noopener">learn-ts</a></p>
</li>
<li><p><a href="https://github.com/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a></p>
</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/typescript/">typescript</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 hello2dj (dj_amazing@sina.com)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>