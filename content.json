{"meta":{"title":"hello2dj","subtitle":"if you can't explain it simply, you don't understand it well enough","description":"每个人都是带着棱角来到世上，只有磨平棱角才能走的更远","author":"hello2dj (dj_amazing@sina.com)","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"node源码系列1","slug":"node源码系列1","date":"2018-08-02T10:50:27.000Z","updated":"2018-08-02T13:14:20.724Z","comments":true,"path":"2018/08/02/node源码系列1/","link":"","permalink":"http://yoursite.com/2018/08/02/node源码系列1/","excerpt":"","text":"纯贴一波代码，这段代码在/internal/process/fixed_queue.js, 使用在/internal/process/next_tick.js中，用来管理添加的next_tick的回调函数，在早期版本中使用的array来管理，在某一期就换成了这个，我测试性能，他俩不在一个数量级（其实都不用测试因为fixed_queue，本身用的array），array明显快于fixed_queue, 但我也没有找到替换的理由。这个数据够很有意思 他相当于是一个一个的ringbuffer 连接起来的单向链表 使用ringbuffer是为了更好更高效的利用内存(这也是我推测的替换的一个原因)， 因为以前用的是是一个大的array，当next_tick过多就会出现一个array占用过多内存，对gc不友好，小块小块的操作也利于对象的回收 这里又个我们上了一个生动的课程就是分而治之，既然大块内存不利于开辟与操作，有浪费的可能，那就每一次拿一小块，就像是node的事件循环，他并不是把所有的事件统统放到一个queue中，而是做了拆分，根据事件的种类进行拆分，再说一一个就是go的channel，若是所有的数据都通过一个channel进行传递，也是可以，但当量大的时候返回会很弱， 但是拆分过细也不行，就好比go的channel他的调度能力也是有限的，不是无穷无尽的，当达到10w是就会出现饿死的goroutine。 返回来看我们的fixed_queue, 他的每个ringbuffer 设置的大小是2048，而不是10，因为若是太小，反而有加剧了gc的工作，因为要过于频繁的gc。 为什么大小是2048， 我们以往在实现ringbuffer的时候都是通过 mod来进行判断，在这里我们有学习了， 当Size为2的n次方时我们还可以通过是用 (Size - 1) &amp; x来取模123Size = 8;Size - 1 = b111;显然 n 无论是多少和111相与得到的值都是在（0, 7）内正好是8的模 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&apos;use strict&apos;;// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.const kSize = 2048;const kMask = kSize - 1;// The FixedQueue is implemented as a singly-linked list of fixed-size// circular buffers. It looks something like this://// head tail// | |// v v// +-----------+ &lt;-----\\ +-----------+ &lt;------\\ +-----------+// | [null] | \\----- | next | \\------- | next |// +-----------+ +-----------+ +-----------+// | item | &lt;-- bottom | item | &lt;-- bottom | [empty] |// | item | | item | | [empty] |// | item | | item | | [empty] |// | item | | item | | [empty] |// | item | | item | bottom --&gt; | item |// | item | | item | | item |// | ... | | ... | | ... |// | item | | item | | item |// | item | | item | | item |// | [empty] | &lt;-- top | item | | item |// | [empty] | | item | | item |// | [empty] | | [empty] | &lt;-- top top --&gt; | [empty] |// +-----------+ +-----------+ +-----------+//// Or, if there is only one circular buffer, it looks something// like either of these://// head tail head tail// | | | |// v v v v// +-----------+ +-----------+// | [null] | | [null] |// +-----------+ +-----------+// | [empty] | | item |// | [empty] | | item |// | item | &lt;-- bottom top --&gt; | [empty] |// | item | | [empty] |// | [empty] | &lt;-- top bottom --&gt; | item |// | [empty] | | item |// +-----------+ +-----------+//// Adding a value means moving `top` forward by one, removing means// moving `bottom` forward by one. After reaching the end, the queue// wraps around.//// When `top === bottom` the current queue is empty and when// `top + 1 === bottom` it&apos;s full. This wastes a single space of storage// but allows much quicker checks.const FixedCircularBuffer = class FixedCircularBuffer &#123; constructor() &#123; this.bottom = 0; this.top = 0; this.list = new Array(kSize); this.next = null; &#125; isEmpty() &#123; return this.top === this.bottom; &#125; isFull() &#123; return ((this.top + 1) &amp; kMask) === this.bottom; &#125; push(data) &#123; this.list[ this.top ] = data; this.top = (this.top + 1) &amp; kMask; &#125; shift() &#123; const nextItem = this.list[ this.bottom ]; if (nextItem === undefined) return null; this.list[ this.bottom ] = undefined; this.bottom = (this.bottom + 1) &amp; kMask; return nextItem; &#125;&#125;;class FixedQueue &#123; constructor() &#123; this.head = this.tail = new FixedCircularBuffer(); &#125; isEmpty() &#123; return this.head.isEmpty(); &#125; push(data) &#123; if (this.head.isFull()) &#123; // Head is full: Creates a new queue, sets the old queue&apos;s `.next` to it, // and sets it as the new main queue. this.head = this.head.next = new FixedCircularBuffer(); &#125; this.head.push(data); &#125; shift() &#123; const &#123; tail &#125; = this; const next = tail.shift(); if (tail.isEmpty() &amp;&amp; tail.next !== null) &#123; // If there is another queue, it forms the new tail. this.tail = tail.next; &#125; return next; &#125;&#125;;","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"简话协变和逆变","slug":"简话协变和逆变","date":"2018-07-14T13:00:30.102Z","updated":"2018-07-14T13:00:30.102Z","comments":true,"path":"2018/07/14/简话协变和逆变/","link":"","permalink":"http://yoursite.com/2018/07/14/简话协变和逆变/","excerpt":"","text":"原文地址 什么是协变和逆变？子类型(subtyping)在编程语言理论中一直是个复杂的话题。对协变和逆变的误解是造成这个问题的一个主要原因。这篇文章就是来说明这两个术语的。 接下来我们将会使用以下符号: A &lt;: B 意思是A是B的子类型 A -&gt; B 代表一个函数参数是A,返回值是B e : T 意思是e的类型是T 一个有意思的问题假设我们有这么三个类型1Greyhoud &lt;: Dog &lt;: Animal 可以看出Greyhound 是Dog的子类型，并且Dog 是Animal的子类型。通常来说，子类型是具有传递性的，因此Greyhound也是Animal的子类型。 问题: 下面那个类型是Dog -&gt; Dog的子类型 Greyhound -&gt; Greyhound Greyhound -&gt; Animal Animal -&gt; Animal Animal -&gt; Greyhound 我们如何回答这个问题呢？假设f是一个接收Dog -&gt; Dog 函数类型作为参数的函数。此时我们并不关心f的返回值类型，举个栗子吧，假设：1f: (Dog -&gt; Dog) -&gt; String 现在我想用g作为参数来调用f,接下来我们一一看一下当g是上述类型时会是什么情况: 假设g: Grehound -&gt; Grehound, 那个f(g)是否是类型安全的呢？不是的，因为f有可能会用其他的Dog的子类型来调用g,比如：GemanShepherd 假设g: Geryhound -&gt; Animal, 那个f(g)是否是类型安全的呢？不是的，原因同上 假设g: Animal -&gt; Animal, 那个f(g)是否是类型安全的呢？不是的，因为f有可能调用了g,然后使用它的返回值让他吠，但并不是所有的动物都会吠。 假设g: Animal -&gt; Greyhound, 那个f(g)是否是类型安全的呢？是的，这个是安全的，f可以使用任意类型的Dog调用g，因为所有的Dog都是Animal,并且，f可以假设g的返回值就是Dog，因为所有的Greyhound都是Dog。 那么接下来该说啥呢？可以看出这个是类型安全的:1(Animal -&gt; Greyhound) &lt;: (Dog -&gt; Dog) 返回值的类型很直接可以看出: Greyhound 是Dog的子类型。但是参数的类型有点儿炸： Animal是Dog的祖(super)类型啊！ 为了用我们的行话(jargon)来解释这个奇怪的原因,我们规定参数的返回值类型是协变的，然而参数类型是逆变的。返回值是协变的意味着：A &lt;: B暗指(T -&gt; A) &lt;: (T -&gt; B)(A是B的子类就是说（T -&gt; A）是 （T -&gt; B）的子类型)。参数类型的逆变意味着: A &lt;: B 暗指（B -&gt; T）&lt;: （A -T)(A和B交换位置) 有趣的事实是：在Typescript中，参数类型是双变的（即可以是逆变又可以是协变），很显然这是不合理(unsound)的表现（但是在2.6中可以使用–strictFunctionTypes来修正） 那么其他类型呢？问题: 那么List是List的子类型么？ 这问题的答案不是那么好说明的？如果list是不可变的，那么他就是类型安全的，但如果list是可变的，那么他就肯定不是安全的！ 为什么呢？假设我需要一个List然后你给我传了一个List,然而我认为你给我传的就是List,那么我就有可能往list中再插入一个Cat, 那么你的List里面就有了一个Cat!显然类型系统是不允许你这么做的。 正式说明： 当我们的list是不可变(数据是否可变)的时候我们是允许类型是可协变的，但是若是可变(数据是否可变)得list那么list类型必须是不可变的(是指类型是否可变，无论是协变还是逆变都是不可以的)。 有趣的事实: 在Java里面，数组即是可变(是指数据是否可变)的又是类型可协变。显然这是不合理的(unsound)","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"},{"name":"subtype","slug":"subtype","permalink":"http://yoursite.com/tags/subtype/"}]},{"title":"安姐的文章之“增加你的影响力：为别人的决定辩论”-读后感","slug":"增加你的影响-读后感","date":"2018-07-14T13:00:30.101Z","updated":"2018-07-14T13:00:30.101Z","comments":true,"path":"2018/07/14/增加你的影响-读后感/","link":"","permalink":"http://yoursite.com/2018/07/14/增加你的影响-读后感/","excerpt":"","text":"今天安姐发了一篇新的文章增加你的影响力：为别人的决定辩论 总结一下读完的感觉 为 team 的决定辩论，而不是甩手一个决定必然是大家达成了统一或者说是多数决定的。一旦决定达成了，即使你是保留意见，你也应当为这个决定坚守立场。而不是只有抱怨的说，谁谁决定请问他。当然若是你是少数派，若是你能睡服大家，ok，那么决定都到你这了。但若是依然没能成功，那你也应当捍卫这个决定（捍卫有些过火但最少不是一句谁谁决定的找他去）。总之我们是一个 team 应当维护这个 team 的决定。 不要总是想着撇清关系，对交流开方当其他人来询问一个系统或者 bug 或者设计的时候，若是自己参与的那么就应当进行说明，即使没有深度参与也不应当以敷衍的话语了结对话，比如 123456“这是我们组产品经理决定的，你去问他们吧。”或者：“这是那谁谁谁的代码，已经走了，谁也不知道他为什么这样做。”或者：“这个一直就是这样了，我的改动只是 refactoring，没有动原来的逻辑。”再或者：“谁谁谁告诉我要这样做，我也不清楚为什么。” 想这些话语一般都会直接结束对话的。但这些话语一般都是为了撇清责任而说的，但事实是来询问的人一般也不是来问责的，而是来交流的，甚至有一些建设性的意见。我们最好是积极参与进去无论他问的是不是你直接参与的。但是如果人真的是很着急的状态我觉得你还是直接说上面的话吧，不要耽误时间….(大哭)。若真的是完全没有参与那么你也应当对询问之人进行引导方便他能快速的找到对的人。 思考整体与全局不要只是关心自己的那方面，应当有意识的成为整个项目的责任人，这里贴一下安姐的话 当你开始基于一些决定，或者已有的设计，甚至已有的代码开展新的工作的时候，你就把自己认为是所有相关问题、设计的真正主人。你就需要去做下面的一些功课： 别人问的问题，你多少了解一点历史情况。可以根据历史情况，客观的帮助解释。比如，这样做确实不够通用，但是当时因为时间紧急，并且没有现在这么多的场景的应用。所以这个设计在那个时候其实是有道理的。或是因为别的资源限制，这个决定是在当时的限制下的决定。 别人问的问题，其实也是你比较困惑的问题。那么作为团队的一部分，你其实比对方更应该对问题的答案感兴趣。为什么你没有在组里试图去了解这个问题？或者你应该接下来找到相关的人，去了解其背景或者初衷。 别人问的问题，其实是你和组里别人已经争论很久的问题。虽然最后的决定和你的想法不一致，但是为什么会这样做决定，对方一定有说服你的理由，哪怕是技术无关的理由。那么这应该就是你为这个决定辩论的理由。如果对方的理由都没有说服你，那为什么你同意这个决定呢？如果你还是觉得不同意，那么，你应该和自己人先商量清楚。如果你觉得完全不能妥协，那么你应该和相关的人讨论。一旦达成一个统一，你就应该为这个决定辩护。而不是为自己之前的、被说服的想法辩护，对决定吐槽。因为对于没有参与这个争论的人来说，听了你的片面说法，对解决问题没有太大的帮助。 坚持自己的看法与推进系统前进相统一坚持自己的看法不是死坚持因为有时是多数决定的，此时我们可以保留己见但却万万不是消极的抵抗，因为这对项目的推进没有任何好处，应当在保持己见的时候积极推动项目 责任越大能力越大以前大家都说的是能力越大责任越大，看完后我觉得可以反过来说责任越大能力也会随之越大的，责任越大接触与担当的越多，自然能力成长越大。 多作对项目有利的事儿-为项目做出贡献不要总是宣传消极，多做对项目有利的事儿，不是大家互相攻击就能对项目有利，也不是互相猜忌就对项目有利。 7) 不要做下面的人 &gt; 工作中难免遇到一些人，当他跟你争论的时候，没有足够的理由，当时同意或者默认你的观点。可是离开会议后，跟别人一交流，又改变主意，或者完全不把自己的同意当回事。这样的人几乎不可能成为工作中的决策者，或者被委以重任的人。因为他既不能在和不同意见争论时坚守自己认为正确的看法，也不能在自己被说服取得一致后对推动整个项目的进展有任何贡献。因为他其实是不能为一个决定辩论，又不愿为自己表面同意的另一个决定辩论。 做墙头草可以，但你应当把你做墙头草的理由说出来，而不是仅仅是随风倒。 很多时候，你是有机会对其负责的，只是你选择了不。好处是你不担什么责任。但是职场中，如果你认为你只对你从头到尾一手做的东西负责，或是只对完全由你决定的东西负责，那么最后，你几乎不用对任何事情负责 总结：选择担当，不仅仅只是选择了责任，还有能力的成长，责任越大，能力就会越大 ps: 但有责任而又没有权利就会是一件蛋疼的事儿了。那意味着啥事儿你都没有拍板的权力，但是责任都是你的。 我宁可和聪明人(这里的聪明人不是指那些爱耍小聪明的人，心机过深的人)争的面红耳赤，也不愿与面红耳赤者说一句话。","categories":[],"tags":[{"name":"安姐","slug":"安姐","permalink":"http://yoursite.com/tags/安姐/"},{"name":"工作","slug":"工作","permalink":"http://yoursite.com/tags/工作/"}]},{"title":"欢乐的使用rxjs-promise-async-await","slug":"欢乐的使用rxjs-promise-async-await","date":"2018-07-14T13:00:30.101Z","updated":"2018-07-14T13:00:30.101Z","comments":true,"path":"2018/07/14/欢乐的使用rxjs-promise-async-await/","link":"","permalink":"http://yoursite.com/2018/07/14/欢乐的使用rxjs-promise-async-await/","excerpt":"","text":"先上图： 原文地址(english, 需翻墙) Rxjs observable和promise以及Async-Await的互相操作无论何时我都会被问到一个问题那就是如何再使用rxjs的时候使用promise和async和await呢？或者什么时候不能混合使用？我也说过几个不要同时使用的栗子。rxjs从一开始就可以很好的和promise一起使用。希望这篇文章能够很好的阐述一下。 如果他接受Observable, 那么他就可以接受promise举个栗子，假如你在使用switchMap, 那么你就可以像返回一个Observable一样返回一个Promise。就像下面这样 jsbin：123456789101112131415161718192021222324252627// An observable that emits 10 multiples of 100 every 1 secondconst source$ = Observable.interval(1000) .take(10) .map(x =&gt; x * 100);/** * returns a promise that waits `ms` milliseconds and emits &quot;done&quot; */function promiseDelay(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&apos;done&apos;), ms); &#125;);&#125;// using it in a switchMapsource$.switchMap(x =&gt; promiseDelay(x)) // works .subscribe(x =&gt; console.log(x)); source$.switchMap(promiseDelay) // just a little more terse .subscribe(x =&gt; console.log(x)); // or takeUntilsource$.takeUntil(doAsyncThing(&apos;hi&apos;)) // totally works .subscribe(x =&gt; console.log(x))// or weird stuff you want to do likeObservable.of(promiseDelay(100), promiseDelay(10000)).mergeAll() .subscribe(x =&gt; console.log(x)) 经验证确实工作的很好 使用defer函数可以让返回promise的函数可以重新执行化如果你的函数返回一个promise你可以使用Observable.defer包裹他，就可以使得他在发生错误是可以进行重试jsbin。Observable.defer: Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.12345678910function getErroringPromise() &#123; console.log(&apos;getErroringPromise called&apos;); return Promise.reject(new Error(&apos;sad&apos;));&#125;Observable.defer(getErroringPromise) .retry(3) .subscribe(x =&gt; console.log);// logs &quot;getErroringPromise called&quot; 4 times (once + 3 retries), then errors 经验证确实工作的很好 使用defer来封装async-awaitdefer是一个强有力的工具，你也可以用它来封装async-await函数123456Observable.defer(async function() &#123; const a = await promiseDelay(1000).then(() =&gt; 1); const b = a + await promiseDelay(1000).then(() =&gt; 2); return a + b + await promiseDelay(1000).then(() =&gt; 3);&#125;).subscribe(x =&gt; console.log(x)) // logs 7 这个没有jsbin尝试失败了呃，因为不支持async-await,估计是我的姿势错了,但我在本地试了ok。 用forEach订阅一个Observable, 然后来创建使用async-await的函数来并发执行任务。forEach 介绍：1234567891011121314const click$ = Observable.fromEvent(button, &apos;clicks&apos;);/** * Waits for 10 clicks of the button * then posts a timestamp of the tenth click to an endpoint * using fetch */async function doWork() &#123; await click$.take(10) .forEach((_, i) =&gt; console.log(`click $&#123;i + 1&#125;`)); return await fetch( &apos;notify/tenclicks&apos;, &#123; method: &apos;POST&apos;, body: Date.now() &#125; );&#125; 经本地验证很ok 使用toPromise()和async/await来把最后一个订阅值返回为一个Promise事实上toPromise比较怪异因为他并不是rxjs规范所定义的操作符，只是我们提供了而已。而且toPromise只会把最后一个值使用promise进行包装，那就意味着，若是Observable一直不触发complete那么这个promise就永远不会resolve。 toPromise是一个反模式，只有在需要promise的时候才使用，不要乱用，比如await12345678const source$ = Observable.interval(1000).take(3); // 0, 1, 2// waits 3 seconds, then logs &quot;2&quot;.// because the observable takes 3 seconds to complete, and // the interval emits incremented numbers starting at 0async function test() &#123; console.log(await source$.toPromise());&#125; 经本地验证很ok。 总结：Observable 和 Promise能很好的一起使用基本上如果你的目的就是active programming那么就应当使用Rxjs.Observable。但为了符合人体工程学，我们还是提供了和Promise的互操作，谁让他这么流行呢！其实当我们在async/await中使用forEach的是后会带来更多的可能性。","categories":[],"tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://yoursite.com/tags/rxjs/"},{"name":"reactive programming","slug":"reactive-programming","permalink":"http://yoursite.com/tags/reactive-programming/"},{"name":"Ben Lesh(原文作者)","slug":"Ben-Lesh-原文作者","permalink":"http://yoursite.com/tags/Ben-Lesh-原文作者/"}]},{"title":"一切从加密说起","slug":"一且从加密说起","date":"2018-07-14T13:00:30.099Z","updated":"2018-07-14T13:00:30.099Z","comments":true,"path":"2018/07/14/一且从加密说起/","link":"","permalink":"http://yoursite.com/2018/07/14/一且从加密说起/","excerpt":"","text":"我们为什么需要加密 加密可以保护我们的数据。无论数据是正存放在我们自己的计算机上，还是位于数据中心，或者正在通过互联网传送的途中，加密都可以提供防护。加密可以保护我们的聊天，不管是视频、语音还是文字。加密可以保护我们的隐私，可以隐藏我们的踪迹，甚至有时候，它会保护我们的性命。这种保护是攸关我们每个人的。 加密是我们所拥有的最强力的隐私保护技术，是唯一适合避免大规模监视。 避免犯罪分子撒网寻找可乘之机——的技术。 通过使用加密迫使双方都只能专注于具体的个体目标，我们也保护了这个社会。 加密算法 对称加密(加密者和解密者用的秘钥都是一样的) 常见的对称加密算法有 DES、3DES、AES、Blowfish、IDEA、RC5、RC6 举个简单例子，我把我的数据块切分成 32 位大小的，然后都和我的秘钥 key(32 位)进行异或，在相加，这就是个简单的对称加密了。。。有了我的 key 就可以解开了，在异或一次我的 key 就解开了 举个例子 AES 的模式，有 128，256 bit 的，接下来是加密模式ECB：是一种基础的加密方式，密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密，一个个输出组成密文。CBC：是一种循环模式，前一个分组的密文和当前分组的明文异或操作后再加密，这样做的目的是增强破解难度。CFB/OFB 实际上是一种反馈模式，目的也是增强破解的难度。还有填充方式，cbc 是需要填充的， cbc 还需要 iv, 初始化向量 ECB 和 CBC 的加密结果是不一样的，两者的模式不同，而且 CBC 会在第一个密码块运算时加入一个初始化向量。 非对称加密(加密者和解密者使用的 key 是不同，就说加密者使用 key1 加密，解谜者使用 key2 解密) 非对称加密算法 RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用），有个公钥和私钥，公钥加密的数据只有对应的私钥能解开，而私钥加密的数据就只有公钥能解开了 (rsa 原理),被破解的难度在于大整数的因式分解困难, rsa 的加密明文是必须小于 key 的 明文，密文长度而密文长度是和密钥长度是一致的。 安全性 ECDH &gt; DHE &gt; RSA,DH, 前两者提供前向安全: 前向安全: 用来产生会话密钥(session key)的长期密钥(long-term key)泄露出去，不会造成之前通讯时使用的会话密钥(session key)的泄露，也就不会暴漏以前的通讯内容。简单的说，当你丢了这个 long-term key 之后，你以后的行为的安全性无法保证，但是你之前的行为是保证安全的 rsa 加密时注意项, 跟 DES，AES 一样，RSA 也是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。 当明文长度不够加密的长度时需要补足, 因为一次加密的长度是有固定的，为什么是固定的请看 rsa 原理篇 RSA 加密常用的填充方式有下面 3 种： 1. RSA_PKCS1_PADDING 填充模式，最常用的模式，当你选择 RSA_PKCS1_PADDING 填充模式时，如果你的明文不够 128 字节， 加密的时候会在你的明文中随机填充一些数据，所以会导致对同样的明文每次加密后的结果都不一样。对加密后的密文，服务器使用相同的填充方式都能解密。解密后的明文也就是之前加密的明文。 1234567要求:输入：必须 比 RSA 钥模长(modulus) 短至少11个字节, 也就是 RSA_size(rsa) – 11如果输入的明文过长，必须切割， 然后填充输出：和modulus一样长根据这个要求，对于512bit的密钥， block length = 512/8 – 11 = 53 字节 2. for RSA_NO_PADDING 不填充，当你在客户端选择 RSA_NO_PADDING 填充模式时，如果你的明文不够 128 字节， 加密的时候会在你的明文前面，前向的填充零。解密后的明文也会包括前面填充的零，这是服务器需要注意把解密后的字段前向填充的零去掉，才是真正之前加密的明文 1234567输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割， 然后填充输出：和modulus一样长但跟AES等不同的是， block length是跟key length有关的。每次RSA加密的明文的长度是受RSA填充模式限制的，但是RSA每次加密的块长度就是key length。 3. RSA_PKCS1_OAEP_PADDING，RSA_PKCS1_OAEP_PADDING 填充模式没有使用过， 他是 PKCS#1 推出的新的填充方式，安全性是最高的，和前面 RSA_PKCS1_PADDING 的区别就是加密前的编码方式不一样 123输入：RSA_size(rsa) – 41输出：和modulus一样长 一句话不同的填充方式加解密也是不同的，使用的时候要注意 ssl/tls 的加密流程详见 数字证书 数字证书和数字签名的原理简单来说数字签名就是传输信息的摘要，数字证书就是 CA 用自己的私钥把你的公钥及其他信息加密后生成内容, 即 CA 用自己的私钥来给你的公钥做数字签名 现在的数字证书一般采用证书的格式遵循 ITUT X.509 国际标准。一个标准的 X.509 数字证书包含以下一些内容 证书的版本信息; 证书的序列号，每个证书都有一个唯一的证书序列号; 证书所使用的签名算法; 证书的发行机构名称，命名规则一般采用 X.500 格式; 证书的有效期，现在通用的证书一般采用 UTC 时间格式，它的计时范围为 1950-2049; 证书所有人的名称，命名规则一般采用 X.500 格式; 证书所有人的公开密钥; 证书发行者对证书的签名。 证书格式 PEM 格式PEM 格式通常用于数字证书认证机构（Certificate Authorities，CA），扩展名为.pem, .crt, .cer, and .key。内容为 Base64 编码的 ASCII 码文件，有类似”—–BEGIN CERTIFICATE—–” 和 “—–END CERTIFICATE—–”的头尾标记。服务器认证证书，中级认证证书和私钥都可以储存为 PEM 格式（认证证书其实就是公钥）。Apache 和类似的服务器使用 PEM 格式证书。 DER 格式DER 格式与 PEM 不同之处在于其使用二进制而不是 Base64 编码的 ASCII。扩展名为.der，但也经常使用.cer 用作扩展名，所有类型的认证证书和私钥都可以存储为 DER 格式。Java 是其典型使用平台。 PKCS#7/P7B 格式PKCS#7 或 P7B 格式通常以 Base64 的格式存储，扩展名为.p7b 或 .p7c，有类似 BEGIN PKCS7—–” 和 “—–END PKCS7—–”的头尾标记。PKCS#7 或 P7B 只能存储认证证书或证书路径中的证书（就是存储认证证书链，本级，上级，到根级都存到一个文件中）。不能存储私钥，Windows 和 Tomcat 都支持这种格式。 PKCS#12/PFX 格式PKCS#12 或 PFX 格式是以加密的二进制形式存储服务器认证证书，中级认证证书和私钥。扩展名为.pfx 和 .p12，PXF 通常用于 Windows 中导入导出认证证书和私钥。 X.509 证书标准支持三种不对称加密算法：RSA, DSA, Diffie-Hellman algorithms。最常用的是 RSA 算法 数字签名的作用 是能确定消息的不可抵赖性，因为他人假冒不了发送方的私钥签名。发送方是用自己的私钥对信息进行加密的，只有使用发送方的公钥才能解密。 是数字签名能保障消息的完整性。一次数字签名采用一个特定的哈希函数，它对不同文件产生的数字摘要的值也是不相同的 数字证书的作用 不可抵赖性 消息的完整性 身份认证 CA 数字证书认证机构（英语：Certificate Authority，缩写为 CA） 负责发放和管理数字证书的权威机构，承担公钥体系中公钥的合法性检验的责任。 CA 是证书的签发机构，它是 PKI 的核心。CA 是负责签发证书、认证证书、管理已颁发证书的机关。它要制定政策和具体步骤来验证、识别用户身份，并对用户证书进行签名，以确保证书持有者的身份和公钥的拥有权。 CA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。 如果用户想得到一份属于自己的证书，他应先向 CA 提出申请。在 CA 判明申请者的身份后，便为他分配一个公钥，并且 CA 将该公钥与申请者的身份信息绑在一起，并为之签字后，便形成证书发给申请者。 如果一个用户想鉴别另一个证书的真伪，他就用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的 公钥基础设施（Public Key Infrastructure，简称 PKI）wiki 参考: tsl/ssl 进阶 ecdh, dh pki 体系 ca 证书链","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://yoursite.com/tags/crypto/"},{"name":"ssl/tsl","slug":"ssl-tsl","permalink":"http://yoursite.com/tags/ssl-tsl/"}]},{"title":"一帧一世界","slug":"一帧一世界","date":"2018-07-14T13:00:30.099Z","updated":"2018-07-14T13:00:30.099Z","comments":true,"path":"2018/07/14/一帧一世界/","link":"","permalink":"http://yoursite.com/2018/07/14/一帧一世界/","excerpt":"","text":"原文地址 一帧的时间内到底发生了什么一些开发者经常会问我一个问题:页面到像素渲染的流程到底是啥？以及什么时候发生渲染以及为啥。所以啊我就发现好好的解释一下渲染像素到屏幕的过程是很有必要滴，且听我细细道来 本文是从chrome/Blink的角度来谈的。其中大部分对于其他浏览器来说也是大同小异的，好比layout 或者stlye calcs, 但是总体架构可能不太一样。 俗话说一图胜千言确实如此，那我们也从一副图开始说起吧 上图就是从得到像素到绘制到屏幕的整个完整过程 Processes图里面有太多的东西了，所以我在下面进行了更详细的介绍，对于我们的理解来说这是很有帮助的 render process. 一个tab页就是会有一个render process, 他包含了很对的thread, 他负责对我们的操作做出回应。 这些thread 包括 Compositor, Tile Worker, 以及main threads GPU process. 这个是单一的进程(就是说无论你打开多少个tab都只有这一个GPU process),他服务于所有的tab。实际渲染到屏幕的像素数据都是由那些提交到GPU process的帧中的tile数据(贴图)以及其他一些数据(例如顶点数据，矩阵数据)，GPU就包含了一个thread， 而这个GPU thread才是实际干活的。 render process threads接下来让我们看看render process中的threads Compositor thread. 当产生vsync event(vsync是指os告诉浏览器如何产生新的一帧）时这个thread是第一个被通知的。同时也会接受所有的input事件，Compositor会尽量避免打扰main thread, 他会尝试处理输入，例如处理滚动(这可不代表滚动就有compositor处理的哦)。如果他能处理，那么他会直接去更改layer的位置然后吧frames同过GPU thread 提交大GPU去， 但是如果要处理输入的事件，或者其他一个可视化的工作，那么他就会把这些交给main thread Main Thread. 这个是浏览器处理任务的thread，包括我们所熟知的和喜爱的js, styles, layout 以及 paint(这些在将来有可能会因为Houdini而发生改变，通过使用Houdini我们可以在Compositor Thread中run一些code).这个thread也或得了一个荣耀“最能引起卡顿的家伙”， 很大一部分原因是因为有太多的东西在这里运行了 Compositor Tile Worker(s).这些都是由Compositor Thread启动的，是用来处理光栅化任务的(栅格化这个术语可以用于任何将向量图形转换成位图的过程)。 我们可以把Compositor Thread 当做“大boss”。因为他不去运行js，不去布局，不去paint,或者其他事情。他所要做的事情除了启动main thread, 就是把frames传输给screen. 而且如果他没有在等待input event, 他就可以在等待main thread完成任务的同时传输frames 你也可已设想 Serviec Workers 和 Web Workers 运行在this process(应该是指render process),但是我把他们放到后面在说，因为他们会使事情变得太复杂。 main thread 里的整体流程 oftentimes the best way to improve performance is simply to remove the need for parts of the flow to be fired! 让我们逐步介绍从vsync到像素的流程。 值得记住的是，浏览器不需要执行所有这些步骤，这取决于哪些是需要进行的。 例如，如果没有新的HTML解析，那么解析HTML将不会触发。 事实上，提高性能的最佳方法通常是简单地避免整个流程中某些部分的触发例如layout或者其他！ 同样值得注意的是，在样式和布局下的那些红色箭头似乎指向了requestAnimationFrame。 在代码中偶然触发是完全可能的。 这称为强制同步布局（或样式），它往往不利于性能。 Frame start. Vsync事件触发，一帧开始 输入事件。 输入数据同过compositor传递给main thread中相应的handler。每帧当中，首先触发的是事件处理的函数(如touchmove, scroll, click)，但这不是必须的，因为有些没有事件发生。调度程序会尽力而为的尝试，成功性在不同操作系统之间有所不同。 在用户交互和事件之间还有一些延迟(making its way to the main thread to be handled 不会翻译了。。。) requestAnimationFrame. 这里是进行屏幕元素更新的理想场所，你可以在这里刷新数据，并且这里是离最近一次Vsync最近的时机。其他视觉或者可视化任务(visual tasks)，例如style calcs,将在这个task之后进行，因此这里是更改元素的理想时机，如果你进行了更改了-100个classes, 将不会导致100 style calcs, 他们将会被延时批量处理。这里有一个要注意的地方就是不要在这里访问computed styles 或者是布局属性(例如el.style.backgroundImage or el.style.offsetWidth). 如果你这么做了，那么你将会引起样式的重新计算，或者是重新布局或者是全部，更甚至引起强制同步布局或者更甚至是布局恶化 Parse HTML. 任何新加入的HTML都会被处理，并且创建DOM, 你经常会在页面加载时或者在类似于appendChild这样的操作后看到他 Recalc Styles. 所有新加入或者改变过的样式都会被计算。这可能是整棵树，或者可以缩小范围，取决于更改的内容。 例如，更改body上的类可能是整体的，但值得注意的是，浏览器已经非常聪明地自动限制了样式计算的范围。 Layout. 计算每个可见元素的几何信息（每个元素的位置和大小）。 它通常是为整个文档计算的，通常计算成本与DOM大小成比例。 Update Layer Tree. 这个是给排序元素(z-index相关，overlap相关)创建层叠上下文以及深度信息的过程(The process of creating the stacking contexts and depth sorting elements.) Paint. 这是两部分过程中的第一个：paint是draw调用的记录（填充矩形，写入文本），以查看任何新的或视觉上已经改变的元素。 第二部分是光栅化（参见下面），绘制调用被执行，纹理被填充。这部分是绘制调用的记录，通常比光栅化要快得多，但是这两个部分通常统称为“painting”。 Composite. the layer 和贴图信息被计算出来并且传递回来给compositor thread 进行处理。这是因为要处理will-chandge, 相互遮挡的元素，或者是开启了硬件加速的元素。 Raster Scheduled and Rasterize: The draw calls recorded in the Paint task are now executed. This is done in Compositor Tile Workers, the number of which depends on the platform and device capabilities. For example, on Android you typically find one worker, on desktop you can sometimes find four. The rasterization is done in terms of layers, each of which is made up of tiles. Frame End: With the tiles for the various layers all rasterized, any new tiles are committed, along with input data (which may have been changed in the event handlers), to the GPU Thread. Frame Ships: Last, but by no means least, the tiles are uploaded to the GPU by the GPU Thread. The GPU, using quads and matrices (all the usual GL goodness) will draw the tiles to the screen. Bonus round requestIdleCallback: if there’s any time Main Thread left at the end of a frame then requestIdleCallback can fire. This is a great opportunity to do non-essential work, like beaconing analytics data. If you’re new to requestIdleCallback have a primer for it on Google Developers that gives a bit more of a breakdown. LAYERS AND LAYERSThere are two versions of depth sorting that crop up in the workflow. Firstly, there’s the Stacking Contexts, like if you have two absolutely positioned divs that overlap. Update Layer Tree is the part of the process that ensures that z-index and the like is heeded. Secondly, there’s the Compositor Layers, which is later in the process, and applies more to the idea of painted elements. An element can be promoted to a Compositor Layer with the null transform hack, or will-change: transform, which can then be transformed around the place cheaply (good for animation!). But the browser may also have to create additional Compositor Layers to preserve the depth order specified by z-index and the like if there are overlapping elements. Fun stuff! RIFFING ON A THEMEVirtually all of the process outlined above is done on the CPU. Only the last part, where tiles are uploaded and moved, is done on the GPU. On Android, however, the pixel flow is a little different when it comes to Rasterization: the GPU is used far more. Instead of Compositor Tile Workers doing the rasterization, the draw calls are executed as GL commands on the GPU in shaders. This is known as GPU Rasterization, and it’s one way to reduce the cost of paint. You can find out if your page is GPU rasterized by enabling the FPS Meter in Chrome DevTools: OTHER RESOURCESThere’s a ton of other stuff that you might want to dive into, like how to avoid work on the Main Thread, or how this stuff works at a deeper level. Hopefully these will help you out: Compositing in Blink &amp; WebKit. A little old now, but still worth a watch. Browser Rendering Performance - Google Developers Browser Rendering Performance - Udacity Course (totally free!). Houdini - The future, where you get to add more script to more parts of the flow.","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"frame","slug":"frame","permalink":"http://yoursite.com/tags/frame/"}]},{"title":"Hello pyhton","slug":"python基础学习","date":"2018-07-14T13:00:30.069Z","updated":"2018-07-14T13:00:30.069Z","comments":true,"path":"2018/07/14/python基础学习/","link":"","permalink":"http://yoursite.com/2018/07/14/python基础学习/","excerpt":"","text":"本篇是从一个大神哪里学习时总结的但忘了是哪个大神,若是引得不悦，果断删除(dj_amazing@sina.com) 字符串不可变Number（数字）Python3 支持 int、float、bool、complex（复数）。在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。像大多数语言一样，数值类型的赋值和计算都是很直观的。内置的 type() 函数可以用来查询变量所指的对象类型。123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;class &apos;int&apos;&gt; &lt;class &apos;float&apos;&gt; &lt;class &apos;bool&apos;&gt; &lt;class &apos;complex&apos;&gt; 此外还可以用 isinstance 来判断：123456789101112131415&gt;&gt;&gt; a = 111&gt;&gt;&gt; isinstance(a, int)True&gt;&gt;&gt; isinstance 和 type 的区别在于：class A: passclass B(A): passisinstance(A(), A) # returns Truetype(A()) == A # returns Trueisinstance(B(), A) # returns Truetype(B()) == A # returns False 区别就是: type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。1注意：在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。 数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符 String1234567891011#!/usr/bin/python3str = &apos;Runoob&apos;print (str) # 输出字符串print (str[0:-1]) # 输出第一个个到倒数第二个的所有字符print (str[0]) # 输出字符串第一个字符print (str[2:5]) # 输出从第三个开始到第五个的字符print (str[2:]) # 输出从第三个开始的后的所有字符print (str * 2) # 输出字符串两次print (str + &quot;TEST&quot;) # 连接字符串 与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。12345注意：1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。2、字符串可以用+运算符连接在一起，用*运算符重复。3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。4、Python中的字符串不能改变。 List（列表）List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。1234567891011#!/usr/bin/python3list = [ &apos;abcd&apos;, 786 , 2.23, &apos;runoob&apos;, 70.2 ]tinylist = [123, &apos;runoob&apos;]print (list) # 输出完整列表print (list[0]) # 输出列表第一个元素print (list[1:3]) # 从第二个开始输出到第三个元素print (list[2:]) # 输出从第三个元素开始的所有元素print (tinylist * 2) # 输出两次列表print (list + tinylist) # 连接列表 Tuple（元组）元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号(())里，元素之间用逗号隔开。元组中的元素类型也可以不相同。1234567891011#!/usr/bin/python3tuple = ( &apos;abcd&apos;, 786 , 2.23, &apos;runoob&apos;, 70.2 )tinytuple = (123, &apos;runoob&apos;)print (tuple) # 输出完整元组print (tuple[0]) # 输出元组的第一个元素print (tuple[1:3]) # 输出从第二个元素开始到第三个元素print (tuple[2:]) # 输出从第三个元素开始的所有元素print (tinytuple * 2) # 输出两次元组print (tuple + tinytuple) # 连接元组 注意： 与字符串一样，元组的元素不能修改。 元组也可以被索引和切片，方法一样。 注意构造包含0或1个元素的元组的特殊语法规则。 元组也可以使用+操作符进行拼接。 Set（集合）集合（set）是一个无序不重复元素的序列。基本功能是进行成员关系测试和删除重复元素。可以使用大括号({})或者 set()函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。12345678910111213141516171819202122232425262728293031323334#!/usr/bin/python3student = (&#123;&apos;Tom&apos;, &apos;Jim&apos;, &apos;Mary&apos;, &apos;Tom&apos;, &apos;Jack&apos;, &apos;Rose&apos;&#125;)print(student) # 输出集合，重复的元素被自动去掉# 成员测试if(&apos;Rose&apos; in student) : print(&apos;Rose 在集合中&apos;)else : print(&apos;Rose 不在集合中&apos;)# set可以进行集合运算a = set(&apos;abracadabra&apos;)b = set(&apos;alacazam&apos;)print(a)print(a - b) # a和b的差集print(a | b) # a和b的并集print(a &amp; b) # a和b的交集print(a ^ b) # a和b中不同时存在的元素以上实例输出结果：&#123;&apos;Mary&apos;, &apos;Jim&apos;, &apos;Rose&apos;, &apos;Jack&apos;, &apos;Tom&apos;&#125;Rose 在集合中&#123;&apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;&#125;&#123;&apos;b&apos;, &apos;d&apos;, &apos;r&apos;&#125;&#123;&apos;l&apos;, &apos;r&apos;, &apos;a&apos;, &apos;c&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;&#125;&#123;&apos;a&apos;, &apos;c&apos;&#125;&#123;&apos;l&apos;, &apos;r&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;&#125; Re 模块re.sub(r’(\\b[a-z]+) \\1’, r’adfasdf’, ‘cat in the the hat’) -&gt;\\1 是第一个捕获 就是(\\b[a-z]+)，所以整个正则的意思就是匹配两个相同的单词，然后用r’adfasdf’替换 type1234567891011&gt;&gt;&gt; def fn(self, name=&apos;world&apos;): # 先定义函数... print(&apos;Hello, %s.&apos; % name)...&gt;&gt;&gt; Hello = type(&apos;Hello&apos;, (object,), dict(hello=fn)) # 创建Hello class&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class &apos;type&apos;&gt;&gt;&gt;&gt; print(type(h))&lt;class &apos;__main__.Hello&apos;&gt; 要创建一个class类型，type()函数依次传入3个参数： class的名称；继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。 metaclass除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。 metaclass，直译为元类，简单的解释就是： 当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。 但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。 连接起来就是：先定义metaclass，就可以创建类，最后创建实例。 所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。 metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。 我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法： 定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass： 123456789# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs[&apos;add&apos;] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs)有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：class MyList(list, metaclass=ListMetaclass): pass 当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.new()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。 new()方法接收到的参数依次是： 当前准备创建的类的对象； 类的名字； 类继承的父类集合； 类的方法集合。 测试一下MyList是否可以调用add()方法：1234567891011&gt;&gt;&gt; L = MyList()&gt;&gt;&gt; L.add(1)&gt;&gt; L[1]而普通的list没有add()方法：&gt;&gt;&gt; L2 = list()&gt;&gt;&gt; L2.add(1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;list&apos; object has no attribute &apos;add&apos; 动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。 但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。 ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。 要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。 让我们来尝试编写一个ORM框架。 编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：123456class User(Model):# 定义类的属性到列的映射：id = IntegerField(&apos;id&apos;)name = StringField(&apos;username&apos;)email = StringField(&apos;email&apos;)password = StringField(&apos;password&apos;) 1234# 创建一个实例：u = User(id=12345, name=&apos;Michael&apos;, email=&apos;test@orm.org&apos;, password=&apos;my-pwd&apos;)# 保存到数据库：u.save() 其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的魔术方法比如save()全部由metaclass自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。 现在，我们就按上面的接口来实现该ORM。 首先来定义Field类，它负责保存数据库表的字段名和字段类型： 12345678class Field(object): def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return &apos;&lt;%s:%s&gt;&apos; % (self.__class__.__name__, self.name) 在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等： 123456789class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name, &apos;varchar(100)&apos;)class IntegerField(Field): def __init__(self, name): super(IntegerField, self).__init__(name, &apos;bigint&apos;) 下一步，就是编写最复杂的ModelMetaclass了： 12345678910111213141516class ModelMetaclass(type): def __new__(cls, name, bases, attrs): if name==&apos;Model&apos;: return type.__new__(cls, name, bases, attrs) print(&apos;Found model: %s&apos; % name) mappings = dict() for k, v in attrs.items(): if isinstance(v, Field): print(&apos;Found mapping: %s ==&gt; %s&apos; % (k, v)) mappings[k] = v for k in mappings.keys(): attrs.pop(k) attrs[&apos;__mappings__&apos;] = mappings # 保存属性和列的映射关系 attrs[&apos;__table__&apos;] = name # 假设表名和类名一致 return type.__new__(cls, name, bases, attrs) 以及基类Model： 12345678910111213141516171819202122232425class Model(dict, metaclass=ModelMetaclass): def __init__(self, **kw): super(Model, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r&quot;&apos;Model&apos; object has no attribute &apos;%s&apos;&quot; % key) def __setattr__(self, key, value): self[key] = value def save(self): fields = [] params = [] args = [] for k, v in self.__mappings__.items(): fields.append(v.name) params.append(&apos;?&apos;) args.append(getattr(self, k, None)) sql = &apos;insert into %s (%s) values (%s)&apos; % (self.__table__, &apos;,&apos;.join(fields), &apos;,&apos;.join(params)) print(&apos;SQL: %s&apos; % sql) print(&apos;ARGS: %s&apos; % str(args)) 当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。 在ModelMetaclass中，一共做了几件事情： 排除掉对Model类的修改； 在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个mappings的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）； 把表名保存到table中，这里简化为表名默认为类名。 在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等。 我们实现了save()方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出INSERT语句。 编写代码试试：123456789101112u = User(id=12345, name=&apos;Michael&apos;, email=&apos;test@orm.org&apos;, password=&apos;my-pwd&apos;)u.save()输出如下：Found model: UserFound mapping: email ==&gt; &lt;StringField:email&gt;Found mapping: password ==&gt; &lt;StringField:password&gt;Found mapping: id ==&gt; &lt;IntegerField:uid&gt;Found mapping: name ==&gt; &lt;StringField:username&gt;SQL: insert into User (password,email,username,id) values (?,?,?,?)ARGS: [&apos;my-pwd&apos;, &apos;test@orm.org&apos;, &apos;Michael&apos;, 12345] 可以看到，save()方法已经打印出了可执行的SQL语句，以及参数列表，只需要真正连接到数据库，执行该SQL语句，就可以完成真正的功能。 不到100行代码，我们就通过metaclass实现了一个精简的ORM框架。 小结metaclass是Python中非常具有魔术性的对象，它可以改变类创建时的行为。这种强大的功能使用起来务必小心。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}]},{"title":"rocksdb与LSM-Tree","slug":"rocksdb与LSM-Tree","date":"2018-07-14T13:00:30.069Z","updated":"2018-07-14T13:00:30.069Z","comments":true,"path":"2018/07/14/rocksdb与LSM-Tree/","link":"","permalink":"http://yoursite.com/2018/07/14/rocksdb与LSM-Tree/","excerpt":"","text":"今天看了几篇非常棒的文章，列出来与大家共享rocksdb与LSM-Tree leveldb简介 关于leveldb的进一步解析 从这些文章中大致了解了leveldb为何称之为leveldb以及其内部工作原理的大致了解，值得一读再读。对于其转换随机读写为顺序读写的方式值得深思，条条大路通罗马，有的时候是思想狭隘限制我们的生活与工作，多看，多想，多思考~~","categories":[],"tags":[{"name":"rocksdb","slug":"rocksdb","permalink":"http://yoursite.com/tags/rocksdb/"},{"name":"LSM-Tree","slug":"LSM-Tree","permalink":"http://yoursite.com/tags/LSM-Tree/"}]},{"title":"说说到底啥是reactive programming","slug":"reactive","date":"2018-07-14T13:00:30.069Z","updated":"2018-07-14T13:00:30.069Z","comments":true,"path":"2018/07/14/reactive/","link":"","permalink":"http://yoursite.com/2018/07/14/reactive/","excerpt":"","text":"我又要先上图了： 抱歉这次没有原文了！！！！ 响应式编程先来看看rxjs介绍的reactive programming Producer Consumer Pull Passive: produces data when requested. Active: decides when data is requested. Push Active: produces data at its own pace. Passive: reacts to received data. 我们可以看到，在push系统中，consumer要做的就是要决定对接受到的数据做出如何的响应。而在pull系统中consumer要做的是决定什么时候去获取数据。可能ractive programming 就是从消费者的角度来定义的吧。消费者只需要对数据做出响应即可。 显然在pull的系统中，我们需要确定什么时候获取到数据，producer端是被动的，就好比前端和后端，后端就是被动。那么push系统呢？是有producer来决定什么时候产生数据给Consumer的，而consumer是不关心什么时候拿到数据（典型的订阅模式啊）。其实前端后端是pull，但我们也在经常性的使用push，那就是promise，当你调用promise后你是不知道什么时候才会拿得到数据的。可是promise是单值的push系统。而rxjs带来了一个新的push系统，多值可取消的push系统（但rxjs不像promise那样全是异步的，rxjs可异步可同步）。 我们再来看看cyclejs里的介绍1234567// Inside module Foofunction onNetworkRequest() &#123; // ... // 此时Foo玩去可以好好 CCTV.incrementCounter(); // ...&#125; 此时箭头的生命是由箭尾决定的 是由Foo来控制什么时候调用Bar,此时控制权在Foo,我们需要向Foo提供对外响应, Bar的内部状态是由外部来修改的 1234Foo.addOnNetworkRequestListener(() =&gt; &#123; // 事件一来我大CCTV就可以主动控制了， Foo也不知道// 我大CCTV self.incrementCounter(); // self is CCTV&#125;); 可事实是Bar的状态完全可以是一个内部状态，而这个内部状态只需要根据外部事件的来决定做出如何的响应(reactive 的Bar)。 换句话说就是Bar的内部状态是要随着外部状态的改变而做出响应，但是什么响应就是Bar内部状态的实现了，若是按照第一种方式来看，我们就把Bar对事件的实现暴露给了Foo（举个栗子好比是新闻联播，他要去记录老外那里发生了啥事儿，但我们的新闻联播的播放室会告诉老外我们要怎么播放，要播放什么了么？这就是典型响应式啊，老外发生了事情，cctv收到了事件，然后播放给国内人民）,当我们这么做了以后，Bar只需要关心自己的实现就好了，完全对自己负责就可以了 响应式一个最大的卖点就是构建对自我负责的模块就好了，而不是去或者不需要去改变外部或者外来的状态。另一个好处就是关注点分离，各自关心自己的该关心的事情就好了。 react的stateful Component也在做这件事(自扫门前雪)，他的Component,就是一个纯粹的自负责组件,即使是传递props也是，因为props是提前定义的也好比是监听机制只不过是没有起一个on….Listener罢了 响应式编程依赖了那些编程原则呢？ 迪米特原则：最小消息原则，知道的人越少越好 依赖反转原则 单一职责原则 原则综合 单一责任原则：尽量保证一个类只会因为一个原因发生变化，当变化多于一个时，就需要分解这个类。否则将会因为内部存在过多的依赖而变得难以维护。 开放封闭原则：这个是我们最常使用的，具体可以体现在属性私有、方法公开这一点上。开放封闭原则讲究拥抱扩展、封闭修改。 里氏替换原则：保证每一个子类都能够直接替换其父类，满足is-A的关系。 依赖倒置原则：高层次的模块不应该依赖于低层次的模块，二者应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 接口分离原则：当一个用户需要多个接口的时候，尽量将每一个接口分离出来，而不是将多个接口放在一个类中，包含所有的接口 迪米特法则：如果两个类之间并不需要直接通信，那么就不应该让这两个类相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过另外的类来转发调用，降低类与类之间的耦合。 再一次来说说Rxjs, 为什么要用他，他其实总结了出了很多我们在处理问题时的抽象，好比map, each, flatMap,感觉像是lodash了，事实是我们使用lodash的链式调用也可处理很多问题并且使用更少的代码以及更加简洁（我们可以filter.some.map.reduce,语义也更加清晰）而不是更多的for循环参考： The introduction to Reactive Programming you’ve been missing vedio rxjs","categories":[],"tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://yoursite.com/tags/rxjs/"},{"name":"cyclejs","slug":"cyclejs","permalink":"http://yoursite.com/tags/cyclejs/"},{"name":"reactive programming","slug":"reactive-programming","permalink":"http://yoursite.com/tags/reactive-programming/"}]},{"title":"rxjs原理解析（自建一个demo版rxjs）","slug":"rxjs原理解析","date":"2018-07-14T13:00:30.069Z","updated":"2018-07-14T13:00:30.070Z","comments":true,"path":"2018/07/14/rxjs原理解析/","link":"","permalink":"http://yoursite.com/2018/07/14/rxjs原理解析/","excerpt":"","text":"我又要先上图了： 原文地址(english, 需翻墙) 通过构造一个Observable来学习Observable很多时候大家都在问我”hot” 和 “cold” observables的区别到底是啥？，或者是一个observable到底是单播还是多播？。人们对于’Rx.Observable‘的内部工作原理似乎是非常迷惑的。当被问到如何描述一个observable的时候，人们经常说的就是这样的， “他是流（streams）”或者是“他是个类似promises的东西”。但事实上，我在很多场合以及一些公开演讲上都有讲过这些东西。 和promise作比较比较是有必要的，但不幸的是，恐怕不会有太大的用处。这两者都是异步原语，并且promises已经被js社区广泛接受和使用了，总体来说这是个好的开始。通过对比promise的‘then’和observable的’subscribe‘,我们可以看到两者在立即执行和延时执行上的区别，还可以看到observable的取消执行和可重用性，当然还有其他很多的东西。通过这种比较的方式学习对于observable的初学者来说是很容易接受的。但是这里有一个问题：就是这两者的不同之处远远大于类似之处。Promises都是多播的，Promise的resolve和reject都是异步的。当大家以处理promise的方式处理observables的时候，大家会发现有时候结果并不像预期的那样。Observables有时候是多播的，有时候又不是，并且通常是异步的。真的，有时候我也在责备自己，因为我有可能再使这种误解被延续。 Observable仅仅是一个函数，他接受一个observer 并且返回一个函数若果你想彻底搞懂observable，你可以自己实现一个简单的observable。真的，这并没有听起来那么难。对于一个observable, 当我们去观察他的最小实现时会发现他只是一个拥有特定（specific,具体，指定，特定）目的的函数，而这个函数又有自己特定的类型。（就是一个具有特定目的的特定类型的函数） 结构 函数 接受一个observer(观察者): 一个拥有next, error 以及complete方法的对象 返回一个可取消执行的函数 目的： 连接一个observer到生产者(产生value的对象)，并且返回一个能够 取消连接生产者的方法。实际上observer就是一个可以随时传入数据的的监听器处理函数（handler处理函数） 基础实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 一个虚假的data source*/class DataSource &#123; constructor() &#123; let i = 0; this._id = setInterval(() =&gt; this.emit(i++), 200); &#125; emit(n) &#123; const limit = 10; if (this.ondata) &#123; this.ondata(n); &#125; if (n === limit) &#123; if (this.oncomplete) &#123; this.oncomplete(); &#125; this.destroy(); &#125; &#125; destroy() &#123; clearInterval(this._id); &#125;&#125;/** * 我们的 observable*/function MyObservable(observer) &#123; const datasource = new DatSource(); datasource.ondata = (e) =&gt; observer.next(e); datasource.onerror = (e) =&gt; observer.error(err); datasource.oncomplete = () =&gt; observer.complete(); return () =&gt; &#123; datasource.destroy(); &#125;&#125;/** * 接下来我们可以使用上面的observable*/const unsub = myObservable(&#123; next(x) &#123; console.log(x); &#125;, error(err) &#123; console.error(err); &#125;, complete() &#123; console.log(&apos;done&apos;); &#125; &#125;); 你可以在jsbin上尝试一下 正如你看到的一样，他并不复杂，他只是一个简单的契约 安全的Observers: 优化我们的Observers当我们谈论Rxjs或者响应式编程的时候，我们大部分时间把observables放在首位，但事实上observer的实现才是这类响应式编程的核心工作者(workhorse驮马驮东西的马)。Observables是惰性的（inert）他们仅仅是函数，他们就在那里不动一直到你’订阅‘他们，’订阅‘后他就会建立你的observer(就是把observer与producer连接在一起)，至此他们的活就干完了，然后就又变回了原始的状态等着被其他人再次调用, 另一方面observers则是保持在活跃状态，监听着producer的事件。 你可以用一个带有’next‘, ‘error’以及’complete‘等方法的js 对象来订阅observable，但实际上这仅仅是个开始。在rxjs5我们提供了一些保证，下面是一些非常重要的保证： Observer 保证 若果你传入的oberser没有实现所有的方法，这也是可以的 你不需要在complete和error之后调用next 当你取消订阅以后，任何事件都不会被触发（error, next, or complete） 当调用’complete‘和’error‘的时候需要调用unsubsription 当你的next， complete，error等handlers发生异常的时候，需要调用 unsubscription来保证没有资源泄露 next，error 以及 complete都是可选的 为了达到以上目的，我们需要把你的observer包裹到一个SafeObserver中，这个SafeOberver会强制实现以上保证。为了实现2， 我们需要跟踪是否发生了complete 或者 error。为了实现3，我们需要让我们的SafeObserver知道消费者在什么时候调用了unsubscribe, 等等。 因此如果我们真的想要实现完整的SafeObserver,那将是很庞大的，因此在此文章中就不在具体详述，简要写一下怎么用。具体的实现可以看一下jsbin(可惜我可以不在乎23333)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * A contrived data source to use in our &quot;observable&quot; * NOTE: this will clearly never error */class DataSource &#123; constructor() &#123; let i = 0; this._id = setInterval(() =&gt; this.emit(i++), 200); &#125; emit(n) &#123; const limit = 10; if (this.ondata) &#123; this.ondata(n); &#125; if (n === limit) &#123; if (this.oncomplete) &#123; this.oncomplete(); &#125; this.destroy(); &#125; &#125; destroy() &#123; clearInterval(this._id); &#125;&#125;/** * Safe Observer */class SafeObserver &#123; constructor(destination) &#123; this.destination = destination; &#125; next(value) &#123; // only try to next if you&apos;re subscribed have a handler if (!this.isUnsubscribed &amp;&amp; this.destination.next) &#123; try &#123; this.destination.next(value); &#125; catch (err) &#123; // if the provided handler errors, teardown resources, then throw this.unsubscribe(); throw err; &#125; &#125; &#125; error(err) &#123; // only try to emit error if you&apos;re subscribed and have a handler if (!this.isUnsubscribed &amp;&amp; this.destination.error) &#123; try &#123; this.destination.error(err); &#125; catch (e2) &#123; // if the provided handler errors, teardown resources, then throw this.unsubscribe(); throw e2; &#125; this.unsubscribe(); &#125; &#125; complete() &#123; // only try to emit completion if you&apos;re subscribed and have a handler if (!this.isUnsubscribed &amp;&amp; this.destination.complete) &#123; try &#123; this.destination.complete(); &#125; catch (err) &#123; // if the provided handler errors, teardown resources, then throw this.unsubscribe(); throw err; &#125; this.unsubscribe(); &#125; &#125; unsubscribe() &#123; this.isUnsubscribed = true; if (this.unsub) &#123; this.unsub(); &#125; &#125;&#125;/** * our observable */function myObservable(observer) &#123; const safeObserver = new SafeObserver(observer); const datasource = new DataSource(); datasource.ondata = (e) =&gt; safeObserver.next(e); datasource.onerror = (err) =&gt; safeObserver.error(err); datasource.oncomplete = () =&gt; safeObserver.complete(); safeObserver.unsub = () =&gt; &#123; datasource.destroy(); &#125;; return safeObserver.unsubscribe.bind(safeObserver);&#125;/** * now let&apos;s use it */const unsub = myObservable(&#123; next(x) &#123; console.log(x); &#125;, error(err) &#123; console.error(err); &#125;, complete() &#123; console.log(&apos;done&apos;)&#125;&#125;);/** * uncomment to try out unsubscription */// setTimeout(unsub, 500); Observable的设计: 符合人体工程学的 Observer 安全性若是我们把observables封装成一个class或者 一个对象，那么我们就可以很方便的把SafeObserver当做匿名的obserers传入（或者是函数就好像rxjs里的签名似的subscribe(fn, fn, fn)）并且以更好的符合人体工程学的方式提供给开发者。通过在Observable的’subscribe‘中把SafeObserver以内在的形式创建， Observables 又可以以一种简单的方式来使用了：123456789const myObservable = new Observable((observer) =&gt; &#123; const datasource = new DataSource(); datasource.ondata = (e) =&gt; observer.next(e); datasource.onerror = (err) =&gt; observer.error(err); datasource.oncomplete = () =&gt; observer.complete(); return () =&gt; &#123; datasource.destroy(); &#125;;&#125;); 你可能已经注意到了这个例子和我们的第一个例子是类似的。但是他更容易阅读和理解。具体实现可见jsbin但在jsbin里面我们可以看到在 new Observable的时候他把 observable又用safeObservable包裹了一下显然是没有必要的，因为我们在调用myObserable的subscribe的时候已经把observer用safeObservable包装过了1234567891011class Observable &#123; constructor(_subscribe) &#123; // 我们在new Observable的时候传递的函数其实才是真正的 // subscribe this._subscribe = _subscribe; // 保存起来当我们调用subscribe的时候回来调用他的 &#125; subscribe(observer) &#123; // 你看包装过了 const safeObserver = new SafeObserver(observer); return this._subscribe(safeObserver); &#125;&#125; 操作符：也只是个函数而已Rxjs中操作就是一个接收源observable，然后返回一个新的observable, 并且在你订阅他（指新的observable）的时候，他(操作符)会去订阅源observable。我们可以实现一个简单的如下：jsbin12345678910function map(source, project) &#123; return new Observable(observer) =&gt; &#123; const mapObserver = &#123; next: (x) =&gt; observer.next(project(x)), error: (err) =&gt; observer.error(err), complete: () =&gt; observer.complete() &#125;; return source.subscribe(mapObserver); &#125;&#125; 这里最重要的地方是这个操作符做了什么： 当你订阅他所返回的observable的时候，他创建了一个’mapObserver‘去执行工作，并且把’observer’和mapObserver连在了一起。构造操作符的链式调用仅仅是创建了一个模板，用于在订阅时把observes连接在一起。 设计Observable: 使操作符更好的链式调用如果我们把所有的操作符都实现为独立的函数，那么我们的操作符链式调用会很丑陋1map(map(myObservable,(x) =&gt; x + 1), (x =&gt; x + 2) 那么我们可以想象一下如果我们来个5，6操作符，那个咋办？基本上时没法使用的了。 我们还可以使用reduce来简化一下具体实现参考jsbin1pipe(myObservable, map(x =&gt; x + 1), map(x =&gt; x + 2)); 理想情况下，我们希望能够使用如下的方式进行链式调用1myObservable.map(x =&gt; x + 1).map(x =&gt; x + 2); 幸运的是，我们已经把Observable包装成了一个class, 因此我们可以把操作符作为class的方法实现：jsbin1234567891011121314151617181920212223242526/** * Observable basic implementation */class Observable &#123; constructor(_subscribe) &#123; this._subscribe = _subscribe; &#125; subscribe(observer) &#123; const safeObserver = new SafeObserver(observer); safeObserver.unsub = this._subscribe(safeObserver); return safeObserver.unsubscribe.bind(safeObserver); &#125;&#125;// 在此看到了map的实现Observable.prototype.map = function (project) &#123; return new Observable((observer) =&gt; &#123; const mapObserver = &#123; next: (x) =&gt; observer.next(project(x)), error: (err) =&gt; observer.error(err), complete: () =&gt; observer.complete() &#125;; return this.subscribe(mapObserver); &#125;);&#125; 现在我们就得到了我们想要的语法了。这样做还有一个好处，就是我们子类化一些特定Observable(好比包裹Promise或者需要一些静态数值时) 总结：Observables就是一个接收observer作为参数并且返回一个函数的函数牢记此话，Observables are a function that take an observer and return a function. 不多也不少。如果你写了一个函数接收一个observer然后返回一个函数，那么他是同步的还是异步的呢？都有可能，他是一个函数，任何函数的行为都取决与他是如何实现的。因此在处理Observable时，就把他看作是一个你传入的函数的引用, 没有什么魔法，stateful alien type(有状态的外部类型)。当你在使用操作符的链式调用的时候，你所做的其实就是组合一个函数，建立observers的连接，并将它们连接在一起，以及将数据传递给你的observer。 本文中Observable返回都是一个函数，而在Rxjs回哦在那个以及es-observable规范中返回都是Subscription对象，他有一个更好的设计。但在这里这么写保持了文章的简洁性。 接下来再贡献一点其他的 Subject即是observer 又是observable Subject内部有存储observers的list, 因此他可以多播给这些observers Observables 就是函数用来建立生产者和消费者的监听的函数 Observables 目前还没有跟踪错误， 可以使用error handler(都得用啊)或者是observeOn(这招经本地验证无效本地是node环境可能有所不同待研究)jsbin上图如下不管是mapped新产生的observable还是source都终止了。最安全的做法就是一定要监听error。12345678910111213141516// This is going to behave strangelyconst source$ = Observable.interval(1000).share();const mapped$ = source$.map(x =&gt; &#123; if (x === 1) &#123; throw new Error(&apos;oops&apos;); &#125; return x;&#125;);source$.subscribe(x =&gt; console.log(&apos;A&apos;, x));mapped$.subscribe(x =&gt; console.log(&apos;B&apos;, x));source$.subscribe(x =&gt; console.log(&apos;C&apos;, x));// &quot;A&quot; 0// &quot;B&quot; 0// &quot;C&quot; 0// &quot;A&quot; 1// Uncaught Error: &quot;oops&quot; 另一个解决的办法就是使用observeOn123const source$ = Observable.interval(1000) .share() .observeOn(Rx.Scheduler.asap); // magic here 从subject下游抛出的同步错误会杀掉整个subject(尚未验证，不太明白说的是啥 // TODO: 验证 ) 大神说他自己错了，Promise的错误处理才是个好主意。 将来的版本或许会支持error trap(但目前我是5.5.5了，也没支持)有图有真相，最近的rxjs的一个issue的讨论 可能像promise那样全是异步的也不是必须的(shrug耸一下肩)。 文章评论区精彩内容 multicast and unicast单播还是多播取决于你是如何连接producer的，如果你是每次subscribe时就新建一个producer,那么就是单播，否则就是多播，但是这里面还有好多细节的，大致可以这么认为。","categories":[],"tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://yoursite.com/tags/rxjs/"},{"name":"reactive programming","slug":"reactive-programming","permalink":"http://yoursite.com/tags/reactive-programming/"},{"name":"Ben Lesh(原文作者)","slug":"Ben-Lesh-原文作者","permalink":"http://yoursite.com/tags/Ben-Lesh-原文作者/"}]},{"title":"用来angular的体系来写node之nestjs简介","slug":"nestjs","date":"2018-07-14T13:00:30.044Z","updated":"2018-07-14T13:00:30.044Z","comments":true,"path":"2018/07/14/nestjs/","link":"","permalink":"http://yoursite.com/2018/07/14/nestjs/","excerpt":"","text":"先上图 这几年前端发展的很快，出现了很多优秀的框架。例如Angular2, React, Vue等他们大大提升了开发者的生产效率，以及快速创建可测试化，可扩展的前端应用。但是在server端nodejs到没有出现如此的框架都是一些基础的框架，工具等等，虽然目前有eggjs,thinkjs，私以为他们架构成熟性还有待进步，他依然也只是提供了一些工具和方法等，不过egg还是要胜think一筹的（都是我瞎掰的），当然他们也都在不同程度上的解决了一些初步的架构问题。 这里我看到了一个新近的框架nestjs(基于express)，他提供了一个开箱即用的架构体系，是啥样的架构体系呢？angular2的架构体系，可以说几乎是一样的架构体系，照着搬过来了，不过可以想一想用angular2的前端架构来写后端代码，也是一种酸爽！（typescript）在我看看来就是一个nodejs中ROR,flask或者是django。 概念普及 typescript js的超集，提供强类型校验，以及es6,7等js特性 express 一个node， httpserver,提供了最基础的框架如路由等。 依赖注入，angular里面有个重要的概念就是依赖注入，nestjs中也是大量使用，有一个IOC容器。这里nest的注入和angular2的是一样的，注入可以是一个class, 也可以是一个值，可以是一个function等等不过不是一个class的就得用如下的方式 12345&#123; provide: &apos;PhotoRepositoryToken&apos;, useFactory: (connection: Connection) =&gt; connection.getRepository(Photo), inject: [&apos;DbConnectionToken&apos;],&#125; 其中inject是这个注入值要使用的依赖注入，provide是提供给其他人要使用的注入标识符，useFactory代表要执行的方法，也可以是useValue,此时是一个普通对象即可。还有循环依赖，此时就要使用forwardRef了，就不细讲了，大家可以具体参见 装饰器，要是写过angular2，或者flask等就会知道，都是一堆@name堆起来的了的 @Controller处理req的handler的。 1234567@Controller(&apos;cats&apos;)export class CatsController &#123; @Get() findAll(@Req() user) &#123; return []; &#125;&#125; @Component就是service 12345678910111213141516@Component()export class CatsService &#123; private readonly cats: Cat[] = []; create(cat: Cat) &#123; this.cats.push(cat); &#125;&#125;// 使用export class CatsController &#123; constructor(private readonly catsService: CatsService) &#123;&#125; // 注入 @Post() async create(@Body() createCatDto: CreateCatDto) &#123; this.catsService.create(createCatDto); &#125;&#125; @Module在angualr中代码是以module为粗粒度单元进行组织的，就是rootModule包含其他module比如orderModule, reportModule, userModule,等等， 1234@Module(&#123; imports: [CatsModule, OrderModule, ReportModule, UserModule],&#125;)export class ApplicationModule &#123;&#125; @Middleware同理与express的middleware,只是写法有变化，需要包裹一下 123456789@Middleware()export class LoggerMiddleware implements NestMiddleware &#123; resolve(...args: any[]): ExpressMiddleware &#123; return (req, res, next) =&gt; &#123; console.log(&apos;Request...&apos;); next(); &#125;; &#125;&#125; @Filter 和 HttpException用来处理handler执行过程产生exception或者说错误（但是异常和错误应当是区分开来的）,Filter是区分全局和路由级的。 HttpException是nest提供的错误类型 12345678910111213@Post()async create(@Body() createCatDto: CreateCatDto) &#123; throw new HttpException(&#123; status: HttpStatus.FORBIDDEN, error: &apos;This is a custom message&apos;, &#125;);&#125;/**&#123; &quot;status&quot;: 403, &quot;error&quot;: &quot;This is a custom message&quot;&#125;*/ expecptions的体系是可以扩展的，当然nest还提供很多的类型，如BadRequestExceptio, UnauthorizedExceptio等等 12345export class ForbiddenException extends HttpException &#123; constructor() &#123; super(&apos;Forbidden&apos;, HttpStatus.FORBIDDEN); &#125;&#125; @Filter的正式称呼应当是Exception Filters。这次望文生义是正确的。是的就是处理Exception的。 123456789101112131415161718192021222324252627@Catch(HttpException)export class HttpExceptionFilter implements ExceptionFilter &#123; catch(exception: HttpException, response) &#123; const status = exception.getStatus(); response .status(status) .json(&#123; statusCode: status, message: `It&apos;s a message from the exception filter`, &#125;); &#125;&#125;// 使用@Post()@UseFilters(new HttpExceptionFilter())async create(@Body() createCatDto: CreateCatDto) &#123; throw new ForbiddenException();&#125;// 全局的async function bootstrap() &#123; const app = await NestFactory.create(ApplicationModule); app.useGlobalFilters(new HttpExceptionFilter()); await app.listen(3000);&#125;bootstrap(); @Guards用来决定请求是否要被handler处理，典型就是权限判断 12345678910@Guard()export class RolesGuard implements CanActivate &#123; canActivate(dataOrRequest, context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; &#123; return true; &#125;&#125;// 使用@Controller(&apos;cats&apos;)@UseGuards(RolesGuard)export class CatsController &#123;&#125; 我们可以自定义一些装饰器，给controller添加必要属性以供guard来使用 123456789101112131415161718192021222324252627// roles Deacatorexport const Roles = (...roles: string[]) =&gt; ReflectMetadata(&apos;roles&apos;, roles);// 使用@Post()@Roles(&apos;admin&apos;)async create(@Body() createCatDto: CreateCatDto) &#123; this.catsService.create(createCatDto);&#125;// Roles guards 改写@Guard()export class RolesGuard implements CanActivate &#123; constructor(private readonly reflector: Reflector) &#123;&#125; canActivate(req, context: ExecutionContext): boolean &#123; const &#123; parent, handler &#125; = context; const roles = this.reflector.get&lt;string[]&gt;(&apos;roles&apos;, handler); if (!roles) &#123; return true; &#125; const user = req.user; const hasRole = () =&gt; !!user.roles.find((role) =&gt; !!roles.find((item) =&gt; item === role)); return user &amp;&amp; user.roles &amp;&amp; hasRole(); &#125;&#125;// 使用同上 @Pipe使用来处理参数校验以及参数类型转换的,当然nest也提供了很多的内置pipe,参数解释一下，可能不太好看，value,是传进来的值，ArgumentMetadata的属性包含： type: 参数通过什么方式传进来的（body, query, param等等），metatype: 传进来的参数是啥类型，string, number .etc, data: 这个没搞太明白文档上说的是‘The string passed to the decorator, for example @Body(‘string’)’还没参悟处来。。。 123456789101112@Pipe()export class ValidationPipe implements PipeTransform&lt;any&gt; &#123; transform(value: any, metadata: ArgumentMetadata) &#123; return value; &#125;&#125;// 使用@Post()// @UsePipes(new ValidationPipe())async create(@Body(new ValidationPipe()) createCatDto: CreateCatDto) &#123; this.catsService.create(createCatDto);&#125; @Interceptor按照文档的说法就是受到AOP（面向切面编程）编程方式的启发。 在方法执行前后增加额外的逻辑(类似于koa中中间件的执行方式) 有了1，所以我们可以转换执行结果 转换执行时的异常 重写执行逻辑（比如根据缓存返回结果）这个例子太多了，就不贴代码了可以具体参见 可以自定义装饰器，在guard里面我们已经见到过了。 nest还集成了graphql, websockets, microservice, 微服务这部分他提供两种通信方式，redis(pub/sub), tcp等等 目录结构 1234567891011121314app -- modules -- reports -- report.controller.ts -- report.service.ts -- report.entity.ts -- report.interface.ts -- dto(data transfer object) -- report.dto.ts(推荐class) -- orders ... -- common -- db.provice.ts ... 实践一把 git clone https://github.com/nestjs/typescript-starter npm install npm run start 看看实例代码就ok了。 最后 项目地址nest项目也提供了很多的example, 总体来看写起来也还是很舒服的。集成了很多东西，点赞，希望下一个项目可以使用。 感悟总会觉得自己不知道该怎么去更进一步的学习，一开始使用就觉得纯用express有很多问题，可是没有去思考怎么才能更好，总觉得见见世面，看看优秀的人都是怎么写的，可是，看完就完了，却没有想本项目做一样把看到的总结起来。不想动手写业余项目，因为就是觉得自己懂的太少了，还是得多看看，可是只看又有什么用呢？ps: 看的结果就是写出了屎一样的代码，还得努力啊！（有看的欢迎多多交流dj_amazing@sina.com）","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"},{"name":"angular2","slug":"angular2","permalink":"http://yoursite.com/tags/angular2/"}]},{"title":"Oberservable之“hot”和“cold”的区别","slug":"hot&cold","date":"2018-07-14T13:00:30.039Z","updated":"2018-07-14T13:00:30.039Z","comments":true,"path":"2018/07/14/hot&cold/","link":"","permalink":"http://yoursite.com/2018/07/14/hot&cold/","excerpt":"","text":"我又要先上图了： 原文地址(english, 需翻墙) TL;DR: 当你不想一次又一次的创建你的producer时，你需要一个HOT observableCOLD 就是你的Observable创建了生产者（就是当你创建observable时创建producer）12345// COLDconst cold = new Observable((observer) =&gt; &#123; const producer = new Producer(); // have observer listen to producer here&#125;); HOT 就是你的observable 关闭你的生产者12345// HOTconst producer = new Producer();cosnt hot = new Observable((observer) =&gt; &#123; // have observer listen to producer here&#125;) 继续深入我的上篇文章介绍了observables就是函数。那篇文章的目的是解开observerable的神秘，但是没有深入那个困扰大家的问题：HOT VS COLD Observables are just functions!Observables 就是一个绑定observer和producer的函数。是的，那就是全部。他其实不需要创建producer,他们仅仅是建立observer对producer的监听，并且返回一个函数可以用来移除监听器。对obserable的调用就好像是在调用一个函数，并且传递一个observer 那么什么是producer？生产者就是你的observable的数据来源。他可能是一个web socket, 或者是一个DOM event, 又或者是一个迭代器，甚至有可能是对一个数组的循环。总之，他可以是任何东西，可以用来获取数据并且传递给observer.next(value)。 Cold observables: 生产者在内部创建如果一个observable的producer是在subscribe时创建并且激活的那么他就是 ‘cold’。这意味着，如果observables是函数，那么生产者就是在调用这个函数是创建和激活的。 creates the producer activates the producer start listening to the producer unicast 下面这个栗子就是‘cold’, 因为他对websocket的监听是在你subscribe observable时建立的：12345const source = new Observable((observer) =&gt; &#123; const socket = new WebSocket(&apos;ws://someurl&apos;); socket.addEventListener(&apos;message&apos;, (e) =&gt; observer.next(e)); return () =&gt; socket.close();&#125;); 因此任何subscribe source的对象，都会有自己的WebSocket的实例，并且当他unsubscribe的时候，他将会关闭那个socket。这意味着我们source仅仅只是unicast,因为这个生产者仅仅只能给一个监听者发送数据。这里有一个简单的栗子jsbin HOT observables: 生产者是在外部创建的如果一个observable的生产者是在订阅之外(就是不是在订阅时产生的行为)创建或者是激活的那么他就是’hot’。 共享对生产者的引用 开始监听生产者 多播(通常是)如果我们把上面的栗子中对于WebSocket的创建挪到obserable的外面，那么他就是hot了1234const socket = new WebSocket(&apos;ws://someurl&apos;);const source = new Observable((observer) =&gt; &#123; socket.addEventListener(&apos;message&apos;, (e) =&gt; observer.next(e));&#125;); 现在任何订阅source的对象都共享一个相同的WebSocket实例。他将会高效的多播数据到所有的订阅者。但是这里还有个小问题：我们的obserable没有了对socket的取消逻辑。这意味着一旦发生了错误或者结束后，甚至是取消订阅，我们都无法关闭socket。所以我们真正想要的是让我们的’cold’ observable 变成hot。这里有个例子就没有取消的逻辑jsbin 我们为什么需要 ’hot‘ observable?从第一个cold observable的列子我可以看到如果所有的observable都是cold是会有一些问题的。比如，你不止一次的订阅一个observable,但是他有可能每次都创建了一些稀缺资源，好比 web socket connection, 可事实是你并不想创建很多的web socket连接。事实上你可能很容易的对一个observable创建很多的订阅,并且是在你没意识的情况下。假设我们需要从web socket的订阅中过滤出奇数和偶数，于是最终我们可能写出如下的代码：1234source.filter(x =&gt; x % 2 === 0) .subscribe(x =&gt; console.log(&apos;even&apos;, x));source.filter(x =&gt; x % 2 ==== 1) .subscribe(x =&gt; console.log(&apos;odd&apos;, x)); Rx 的subjects在我们把’cold’ observable 变得 ’hot‘之前，我们需要先介绍一个新的类型：Rx Subject。他有如下特性： 他是一个obserable.他的结构类似一个observable, 并且用相同的操作符 他是一个observer, 他是一个鸭子类型的observer。当他订阅一个observable是，他会像一个observer那样把数据传递给’next‘方法 他是多播的。所有通过’subscribe‘犯法订阅的observers都会加入到一个内部的observers list 当他结束的时候就是真的结束了（意味着结束后不可以在重用）。无论是发生了unsubscribe（这我试出来了见下代码）或者complete, 亦或者是发生了error之后，Subjects是不可以再重用的。（When it’s done, it’s done. Subjects cannot be reused after they’re unsubscribed, completed or errored.） 123456789// The death of a Subjectconst subject = new Subject();subject.subscribe(x =&gt; console.log(x));subject.next(1); // 1subject.next(2); // 2subject.complete();subject.next(3); // silently ignoredsubject.unsubscribe();subject.next(4); // Unhandled ObjectUnsubscribedError 当你通过他自身传递数据时，他会进行#2，就是obser那一套。又若是你通过next传递数据，他又会表现出他observable的一面。 之所以称之为’subject‘是因为上述第三点。 在四人帮的设计模式里，’Subjects‘是一个拥有’addObserver‘方法的类。在这个例子里面，’addObserver‘方法是’subscribe‘，这里有一个jsbin的例子：12345678910111213141516171819202122232425262728const &#123; Subject &#125; = Rx;const subject = new Subject();// you can subscribe to them like any other observablesubject.subscribe(x =&gt; console.log(&apos;one&apos;, x), err =&gt; console.error(&apos;one&apos;, err));subject.subscribe(x =&gt; console.log(&apos;two&apos;, x), err =&gt; console.error(&apos;two&apos;, err));subject.subscribe(x =&gt; console.log(&apos;three&apos;, x), err =&gt; console.error(&apos;three&apos;, err));// and you can next values into subjects.// NOTICE: each value is sent to *all* subscribers. This is the multicast nature of subjects.subject.next(1);subject.next(2);subject.next(3);// An error will also be sent to all subscriberssubject.error(new Error(&apos;bad&apos;));// NOTICE: once it&apos;s errored or completed, you can&apos;t send new values into ittry &#123; subject.next(4); //throws ObjectUnsubscribedError&#125; catch (err) &#123; console.error(&apos;oops&apos;, err);&#125; 使一个 ’COLD‘ Observable ‘HOT’当我们使用了Subject，我们可以使用一些函数式编程方法来使一个 ’cold‘ Observable ‘hot’:1234567function makeHot(cold) &#123; const subject = new Subject(); cold.subscribe(subject); return new Observable((observer) =&gt; subject.subscribe(observer));&#125;// 整体流程就是：observer -&gt; subject -&gt; cold(依次订阅下一个observable) 我们的makeHot方法可以接收任何的cold observable并且可以通过创建一个共享的subject。这里有个例子jsbin 但是我们仍然有一些小的问题，因为，我们仍然没有跟踪我们源observable的subscription(就是cancel函数)，因此当我们想要取消的时候，我们该怎么取消呢？我们可以通过添加引用计数来解决这个问题：1234567891011121314function makeHotRefCounted(cold) &#123; const subject = new Subject(); const mainSub = cold.subscribe(subject); let refs = 0; return new Observable((observer) =&gt; &#123; refs++; let sub = subject.subscribe(observer); return () =&gt; &#123; refs--; if (refs === 0) mainSub.unsubscribe(); sub.unsubscribe(); &#125; &#125;);&#125; 这样我们就有了unsubscribe函数了。jsbin 在Rxjs中，使用’publish()‘或者’share()‘你应当使用publish或者share而不是上面造的makeHot。 有很多种方法可以是cold变为hot, 并且在Rx中有很多种高效简洁的方法来实现。 在rxjs 5中，share操作符，可以是cold变成hot，以及使用引用计数的observable。并且这个observable还可以重试当他失败或者成功。因为当他错误，完成或者取消订阅以后，subjects就不可以重新使用了，于是share()操作符会重新回收死掉的subjects并且在生成一个新的subject,使得我们可以重新订阅。这里有一个栗子jsbin经过尝试错误，取消订阅是可以的重新订阅的。 The “Warm” ObservableGiven everything stated above, one might be able to see how an Observable, being that it’s just a function, could actually be both “hot” and “cold”. Perhaps it observes two producers? One it creates and one it closes over? That’s probably bad juju, but there are rare cases where it might be necessary. A multiplexed web socket for example, must share a socket, but send its own subscription and filter out a data stream. 温暖的 observable自己看吧’hot‘和’cold‘都是针对生产者来说的当你是用shared 引用来关闭producer,那么他是hot。 如果你是在你的observable中创建生产者那么他是cold,若是两者都做，那么我猜他是’warm‘吧！ hot Observable通常是多播的，但若是producer一次只提供一个监听器数据，此时再说他是多播的就会有些模糊了。","categories":[],"tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://yoursite.com/tags/rxjs/"},{"name":"reactive programming","slug":"reactive-programming","permalink":"http://yoursite.com/tags/reactive-programming/"},{"name":"Ben Lesh(原文作者)","slug":"Ben-Lesh-原文作者","permalink":"http://yoursite.com/tags/Ben-Lesh-原文作者/"}]},{"title":"","slug":"http2","date":"2018-07-14T13:00:30.039Z","updated":"2018-07-14T13:00:30.039Z","comments":true,"path":"2018/07/14/http2/","link":"","permalink":"http://yoursite.com/2018/07/14/http2/","excerpt":"","text":"http2 支持请求与响应的多路复用来减少延迟。 压缩 HTTP 首部字段将协议开销降至最低。 增加对请求优先级和服务器端推送的支持。 同时由于考虑到庞大的 HTTP1.1 协议用户，所以 HTTP 方法、状态码、URI 及首部字段，等核心概念保持不变，也就是当前正在运行的网站不用做任何改变即可在 HTTP2 协议上运行。 二进制分帧层: 流、消息和帧:二进制分帧机制改变了客户端与服务器之间交互数据的方式，涉及到以下几个重要的概念: 流：已建立的 TCP 连接上的双向字节流，逻辑上可看做一个较为完整的交互处理单元，即表达一次完整的资源请求-响应数据交换流程；一个业务处理单元，在一个流内进行处理完毕，这个流生命周期完结。 消息：由一个或多个帧组合而成，例如请求和响应。 帧：HTTP2 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。所有 HTTP2 通信都在一个连接上完成，此连接理论上可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。图示如下: HTTP2 的所有帧都采用二进制编码，所有首部数据都会被压缩。上图只是演示数据流、消息和帧之间的关系，而非实际传输时的编码结果。 多向请求与响应:在 HTTP1.1 中，如果想使用多个并行 request 请求，必须多开 TCP 连接，但是一个域名对同一个浏览器客户端是有数量限制的（6 个左右），同时，每一个连接中的响应是按照顺序排队进行的，容易导致队头堵塞。 二进制分帧层实现了多向请求和响应，客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。图示如下:由上图可以看出，同一个 TCP 连接可以传输多个数据流，并且服务器到客户端方向有多个数据流，流是一个逻辑信道，所以属于它的帧可以乱序发送，最后再根据标记组合起来即可。把 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP2 最重要的改进，带来了巨大的性能提升，主要因为如下几个原因: 可以并行交错地发送请求，请求之间互不影响。 可以并行交错地发送响应，响应之间互不干扰。 只使用一个连接即可并行发送多个请求和响应。 消除不必要的延迟，从而减少页面加载的时间。 二进制分帧机制解决了 HTTP1.1 队头阻塞问题，也消除了并行处理和发送请求及响应时对多个 TCP 连接的依赖 请求优先级:每个流都包含一个优先级，用来告诉对端哪个流更重要，当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流。HTTP2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级。数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。 服务器推送:当前 web 页面的功能越来越强大，排版越来越精美，所以需要引用的 js 文件、css 文件或者图片等内容也越来越多，对每一个资源的外部引用，都是一次 request 请求。在 HTTP1.1 中，由于不具有多向请求与响应，所以可能需要额外的 TCP 连接，甚至导致队头堵塞，HTTP1.1 对此问题的解决方案可以参阅 HTTP 请求延迟解决方案一章节。当客户端获取服务器发送来的文档之后，通过分析获知需要引入额外的资源，然后再向服务器发送请求获取这些资源，如此大费周章，倒不如服务器主动推送这些额外资源。推送资源的特点如下: 客户端可以缓存推送过来的资源。 客户端可以拒绝推送过来的资源。 推送资源可以由不同的页面共享。 服务器可以按照优先级推送资源。 首部压缩:在 HTTP1.1 中，每次请求或者响应都会发送一组首部信息，同时这些信息都是以文本形式发送，如果带有 cookie 信息的话，那么发送首部信息就是一份相当大的额外开销。为减少这些开销并提升性能，HTTP2 会压缩首部元数据，HTTP2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键/值对，对于相同的数据，不再通过每次请求和响应发送，首部表在 HTTP2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。 http1 的一个问题","categories":[],"tags":[]},{"title":"Hello English","slug":"hello-world","date":"2018-07-14T13:00:30.038Z","updated":"2018-07-14T13:00:30.038Z","comments":true,"path":"2018/07/14/hello-world/","link":"","permalink":"http://yoursite.com/2018/07/14/hello-world/","excerpt":"","text":"step 1 每天一句As long as you’re being a copycat, you will never be the best copycat. 一味的模仿他人，是做不到最好的 [1]: copycat百度翻译，有道翻译 是指模仿者(特指盲目模仿) step 2 音标学习标准的中式发音，谁听谁服气(这说的是我。。。)，下面给你列举一个学习资料（不知道是不是过时了，凑合先看），咱们先跟着第一个学习，每天学一丢丢。你也可以自己线下练习哦， 一天最少5-6个音标会读吧，然后再忘几个。。。就没了 美式音标(KK音标)在线发音课程 step 3 单词学习在上面一起了 step 4 语法学习这里给你一个英语语法学习的专门地址等你啥时候牛逼了，就可以去了, 英语语法网站 先学习词性吧 1 名词 noun n. student 学生 2 代词 pronoun pron. you 你 3 形容词 adjective adj. happy 高兴的 4 副词 adverb adv. quickly 迅速地 5 动词 verb v. cut 砍、割 6 数词 numeral num. three 三 7 冠词 article art. a 一个 8 介词 preposition prep. at 在… 9 连词 conjunction conj. and 和 10 感叹词 interjection interj. oh 哦 前六类叫实词，后四类叫虚词 最后留点儿东西，省的以后还得再查 介词的理解 wiki上的介词定义 wiki上的英语书，很不错哦 英语学习的知乎专栏","categories":[],"tags":[{"name":"英语","slug":"英语","permalink":"http://yoursite.com/tags/英语/"}]},{"title":"memory snapshot的世界","slug":"heapdump解析","date":"2018-07-14T13:00:30.005Z","updated":"2018-07-14T13:00:30.005Z","comments":true,"path":"2018/07/14/heapdump解析/","link":"","permalink":"http://yoursite.com/2018/07/14/heapdump解析/","excerpt":"","text":"snapshot(v8) \b既然要讲v8的snapshot那就得先看看snap\bshot的表示形式，整个snapshot里的对象是以graph的形式展示的，\b节点是对象(会以对象的构造函数的形\b式展示)，边是属性值, 例如 1234class A &#123; a() &#123;&#125;&#125;那么展示就是 A - a(边) -&gt; Function 此图是snapshot的json格式图 此图中的索引都是从零开始的 123456// 对应snapshot中的字段, 查找节点i的信息var i_type = nodes[i];var i_name = strings[nodes[i + 1]];var i_id = nodes[i + 2];var i_size = nodes[i + 3]var i_edge_count = nodes[i + 4]; 再具体的解释如下: 那么接下来就要说一下snapshot里面是有哪些类型即节点的类型(当然这些类型都来自v8)完整的数据类型，而我们在这里要讲则是在snapshot里面定义的类型(来自v8), 这里我们要区分primitive(包扩三类number, string, symbol,js会替我们auto-boxing)和Object(不要问什么) 从上图我们可以清晰节点的类型一共有13种，hidden类型可能不展示 \b边的类型(即属性的表现形式) 从上图可以看出共有7种 map, array, symbol, object, regexp, number, boolean, string, date，typedarray…这些常见的内建对象我就不解释了，大家都知道 我们在sanpshot中还会经常看见两类string比较生疏的两个(这两类算在pimitive中)， sliced string和 concatenated string 那我们就来看看string，在v8里的形式 在这里我们可以清晰的看出来，\bv8的字符串类型，里面有sliced的解释，是其他字符串的部分引用(因为字面量字符串是不可变的so可以这么办。。)，而cons的就是(a, b),\b或者嵌套似的((a,b),c)这样的pairs(同样是因为\b字面量的字符串是不可变的) 节点类型就上面列出的那些，但是根据具体的对象，他们又有好多不同的名字(Gc roots, map / tag, system / …) chrome devtools 里的概念 shallow size:是指对象自己本身占用的大小, 不包含引用对象内容的大小 1234567891011const parent = &#123; a: 23, child: child,&#125;const child = &#123; a: 23, c: 12,&#125;;/** child的大小就是8B(32为机器)，parent大小就有得讨论了，若不算引用的具体内容大小，parent的大小也是8，而此时就是shallow size。那么包含引用内容呢？*/ * retained size:是指不但包含对象自身，还包含该对象所能引用的或者间接引用（parent.child, parent.child.child） GC rootsGC roots的概念来自与垃圾回收算法，js的垃圾回收\b算法是基于根不可达来回收不使用的内存的，就选取某个对象作为初始点，沿着这个对象的引用链往下走，凡是通过这个对象无法访问到(是指通过引用可以获取到对象)的对象就认为是可以被回收的。 如上图5，6，7就无法被访问到，此时就可以认为5，6，7可以被回收了\b 那么GC root 只有一个么？No.很明显不可能只有一个，因为有栈变量的存在 \b那么有哪些对象可以作为GC root呢， 对于js， 有Global, Window, \b\b栈变量，内建对象等(我们是可以自己扩展内建对象的) chrome devtools 里面的distance是指什么？ 是指通过多少次引用能访问对此对象，对于Window等就是1 从上面我们可以看出来，所有的对象是以树的形式展示的，devtools中如何显示对象\b树的？对象的保留树 就像我们前面所说的，堆就是由相互连接的对象构成的网络。在数学的世界中，这种结构称作图或者内存图。一个图是由节点和边构成的，而节点又是由边连接起来的，其中节点和边都有相应的标签。 节点（或者对象）是用创建对象的构造函数标记的。 123这里问题\b就来了那么js中的对象的构造函数都是啥呢const a = &apos;hello2dj&apos;;// a 的构造函数是 String, 但对于字面量来说还会有具体的展示类型,这与v8的内部实现相关 边是用属性名来标记的对于不同的属性chrome 会标记不同的标识对象的属性以及属性值属于不同类型并且有着相应的颜色。每个属性都会有四种类型之一(更详细的上述snapshot里面又讲)： a:property - 有名称的常规属性，通过 .（点）操作符或者 []（方括号）符号来访问，例如 [“foo bar”]； 0:element - 有数字下标的常规属性，使用 []（方括号）来访问。 a:context var - 函数上下文中的某个变量，在相应的函数闭包中使用其名字就可以访问。 a:system prop - 由 JavaScript 虚拟机添加的属性，在 JavaScript 代码中无法访问。 Object count 挡在summary视图模式下查看时，会有这个，按照上述来说对象树的节点是constructor, 属性是边，那么object count 就是\b通过这个constructor 构造出来的对象实例数量 巧了还有一个我们可以在devtools里经常看到的就是有些对象是黄颜色标识的有些是\b红色标识的，见图, 图中很明显标识\b红色和黄色的\b原因 以黄色突出显示的节点具有 JavaScript 代码对它们的直接引用。 以红色突出显示的节点则没有直接引用。只有属于黄色节点的树时，它们才处于活动状态。 一般而言，您需要将注意力放在黄色节点上。 修复代码，使黄色节点处于活动状态的时间不长于需要的时间，您也需要消除属于黄色节点树的红色节点。点击黄色节点对其进行进一步调查。 显然红色节点就是没有js代码直接引用的对象 在summary视图下第一栏是从constructor而这一栏是分两类的 不带()括号的是构造器，下面包含的是用这个构造器生成的对象,这个很好实验的，自己写一个类，实例化一下就可以了 另一类带\b括号的又有如下区分 见上图，他管()的行为叫tag,那就很明显了，在括号()下面的对象\b就是全部的这种对象了。 我错了 (string, regexp) 显示的是literal string 即 a=’234’中的’23’， regexp类似 (num) 显示的\b是以number\b对象展示的对象 (array) 那些通过数组\b引用的对象，说白了就是数组对象 (code deopt data)[]: v8去优化时的数据 []:就是纯数组 (object properties)[]:通过对象属性引用的对象 (map descriptors)[]: map类型相关，暂时搁置 (object elements)[]: \b暂时未知 (function scope info)[]: 暂时未知 (system) 那就是原生代码了 (compiled code) 编译过后的代码 (closure) 通过闭包引用的对象，但感觉更像是闭包自己 (sliced string): 搁置 (undefined): 搁置 (concatenated string): 搁置 还有一些其他概念参见https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101 看一次对其中两个对象的识别及分析代码如下，num2是一个Number对象，不知道为啥，我以字面量分配的num1，我没找到。。。(有待继续)1num2 = new Number(234); 接下来的图示顺序分析的 常见的内存泄露种类 全局变量123function globalLeak() &#123; bar = &apos;hello2dj&apos;;&#125; 这里bar没有生命就意味着他被global引用了，那么他就不会被回收 被遗忘的计时器或回调函数12345678var someResource = getData();setInterval(function() &#123; var node = document.getElementById(&apos;Node&apos;); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); 此例说明：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。 还有时间监听： 12345var element = document.getElementById(&apos;button&apos;); function onClick(event) &#123; element.innerHTML = &apos;text&apos;; &#125;element.addEventListener(&apos;click&apos;, onClick); 被引用的dom有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。 1234567891011121314151617 var elements = &#123; button: document.getElementById(&apos;button&apos;), image: document.getElementById(&apos;image&apos;), text: document.getElementById(&apos;text&apos;)&#125;;function doStuff() &#123; image.src = &apos;http://some.url/image&apos;; button.click(); console.log(text.innerHTML); // 更多逻辑&#125;function removeButton() &#123; // 按钮是 body 的后代元素 document.body.removeChild(document.getElementById(&apos;button&apos;)); // 此时，仍旧存在一个全局的 #button 的引用 // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。&#125; 此外还要考虑 DOM 树内部或子节点的引用问题。假如你的 JavaScript 代码中保存了表格某一个 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的 以外的其它节点。实际情况并非如此：此 是表格的子节点，子元素与父元素是引用关系。由于代码保留了 的引用，导致整个表格仍待在内存中。保存 DOM 元素引用的时候，要小心谨慎。 闭包这段代码被引用了无数次了来自meteor 123456789101112131415var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) console.log(&quot;hi&quot;); &#125;; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () &#123; console.log(someMessage); &#125; &#125;;&#125;;setInterval(replaceThing, 1000); 代码片段做了一件事情：每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。 Meteor 的博文 解释了如何修复此种问题。在 replaceThing 的最后添加 originalThing = null 。 参考 v8类型(知乎上的一篇) v8类型源码注释 v8-object-representation js内部编码介绍 v8类型图 snapshot的格式头文件 生成snapshot的cc文件 heap profiling snap\bshot格式 easy profiling 常见内存泄露copy于此处","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"chrome","slug":"chrome","permalink":"http://yoursite.com/tags/chrome/"},{"name":"memory","slug":"memory","permalink":"http://yoursite.com/tags/memory/"},{"name":"snapshot","slug":"snapshot","permalink":"http://yoursite.com/tags/snapshot/"},{"name":"heapdump","slug":"heapdump","permalink":"http://yoursite.com/tags/heapdump/"}]},{"title":"Golang 高效的错误处理","slug":"error-in-go","date":"2018-07-14T13:00:30.002Z","updated":"2018-07-14T13:00:30.002Z","comments":true,"path":"2018/07/14/error-in-go/","link":"","permalink":"http://yoursite.com/2018/07/14/error-in-go/","excerpt":"","text":"原文地址 简介golang 的错误处理方式一直是他遭受抨击的一个原因之一。探查每一个的错误然后处理确实是一个艰巨的任务，这里有几招可以让你减少错误的处理方式（处理错误的方法）。 错误处理靠前当我们写golang的时候倾向于12345f, err := os.Open(path)if err != nil &#123; // handle error&#125;// do stuff 而不是12345f, err := os.Open(path)if err == nil &#123; // do stuff&#125;// handle error 这种方式可以让我们的正常处理方式一路看到底，而不是if之后是错误 定义属于自己的错误处理错误的第一步得是知道错误是啥，如果你的package发生了错误，那么你的用户一定对错误的原因很感兴趣。要做到让你的user知道错误是啥，你只需要实现error interface, 如下就可以了12type Error stringfunc (e Error) Error() string &#123; return string(e) &#125; 这样你的用户就可以通过类型断言来判断是否是你的错误1234result, err := yourpackage.Foo()if err, ok := err.(yourpackage.Error); ok &#123; // use tp to handle err&#125; 你也可以暴露一个结构体的error给你的用户12345678910111213141516171819type OpenError struct &#123; File *File Error string&#125;func (oe *OpenError) Error() string &#123; // format error string here&#125;func ParseFiles(files []*File) error &#123; for _, f := range files &#123; err := f.parse() if err != nil &#123; return &amp;OpenError&#123; File: f, Error: err.Error(), &#125; &#125; &#125;&#125; 通过这种方式，你的用户就可以分辨具体是哪个文件解析失败了但是当你包裹错误的时候你也应当注意，因为包裹一个error，会丢失一些信息，就好比上面那个你已经丢失了err的类型而只剩下了err里的信息1234567891011121314var c net.Connf, err := DownloadFile(e, path)switch e := err.(type) &#123; default: // this will get executed if err == nil case net.Error: // close connection, not valid anymore c.Close() return e case error: // if err is non-nil return err&#125;// do other things 见上如果此时你包裹了net.Error, 那么这段代码就不会看到net.Error这个错误了，而只能是一段错误信息，此时就无法具体区分错误了（见前一段的包裹方式丢失了具体的错误类型）一个好的处理方式是尽量不要包裹你调用的其他包自己产生的错误，因为用户可能更关心他们产生的错误而不是你的。 把错误当做状态有时候你可能想要持有一个错误而不是抛出，不管你是打算随后上报或者是你知道这个错误很快就会再次出现 这种情况的一个栗子就是bufio这个包。当bufio.Reader遇到一个错误，他会持有这个错误一直到buffer空为止，只有此时他才会上报这个错误。另一种栗子就是使用go/loader。当使用参数调用遇到错误时，他会持有这个错误，因为有很大的概率他会再次使用相同的参数又调用一遍 使用函数去避免重复如果你有一段错误处理的代码是重复的，你可以把他提出来做一个函数123456789101112131415func handleError(c net.Conn, err error)&#123; // repeated error handling&#125;func DoStuff(c net.Conn) error&#123; f, err := downloadFile(c, path) if err != nil &#123; handeError(c, err) return err &#125; f, err := doOtherThing(c) if err != nil &#123; handleError(c, err) return err &#125;&#125; 一个替换方案是123456789101112131415161718func handeError(c net.Conn, err error) &#123; if err == nil &#123; return &#125; // repeat err handling&#125;func DoStuff(c net.Conn) error &#123; // defer func()&#123; handleError(c, err) &#125;() // 这是原文在的位置，但明显有错误啊，err未定义啊 f, err := downloadFile(c, path) defer func()&#123; handleError(c, err) &#125;()// 所以我挪到这里了，但效果是否ok，暂未验证 if err != nil &#123; return err &#125; f, err := doOtherThing(c) if err != nil&#125; ps: 一个golang官网的一段翻译 Why is my nil error value not equal to nil? 为什么我的nil error 不等于nil呢？先上代码1234567func returnError() error&#123; var p *MyError = nil if bad() &#123; p = ErrBad &#125; return p // Will always return a non-nil error&#125; 如上这里的p明明是nil值为啥返回后就不是了呢？这里涉及到另外一个问题就是\binterface值，我们知道error是一个interface，而MyError是一个struct, 就是要把struct值赋值给interface,在golang里interface值是包括两个的一个type值，一个value值，只有当两者都是nil的时候interface值才是nil, 上述代码，很明显虽然value是nil,可是类型还在啊，就是说type不是你nil而是MyError, \b改进如下123456func returnsError() error &#123; if bad() &#123; return ErrBad &#125; return nil&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"},{"name":"error","slug":"error","permalink":"http://yoursite.com/tags/error/"}]},{"title":"Rxjs之不要到处都是取消订阅","slug":"donotunsubscribe","date":"2018-07-14T13:00:30.001Z","updated":"2018-07-14T13:00:30.001Z","comments":true,"path":"2018/07/14/donotunsubscribe/","link":"","permalink":"http://yoursite.com/2018/07/14/donotunsubscribe/","excerpt":"","text":"我又要先上图了： 原文地址(english, 需翻墙) Rxjs: 不要 取消订阅！好吧，我说的不要调用太多的取消的订阅 在我们的使用过程中我们可能会有很多的Observables, 那么这多的Observables该如何管理呢，有的人就会管理所有的subscription,然后一个一个的取消订阅，这样是不优雅的。当你管理了太多的subscriptions时那可能意味着你是必须要管理他们，而不是在充分利用Rx的强大。 我们来看一个不太好的管理方式1234567891011121314151617181920212223242526272829303132class MyGenericComponent extends SomeFrameworkComponent &#123; updateData(data) &#123; // do something framework-specific to update your component here. &#125; onMount() &#123; this.dataSub = this.getData() .subscribe(data =&gt; this.updateData(data)); const cancelBtn = this.element.querySelector(‘.cancel-button’); const rangeSelector = this.element.querySelector(‘.rangeSelector’); this.cancelSub = Observable.fromEvent(cancelBtn, ‘click’) .subscribe(() =&gt; &#123; this.dataSub.unsubscribe(); &#125;); this.rangeSub = Observable.fromEvent(rangeSelector, ‘change’) .map(e =&gt; e.target.value) .subscribe((value) =&gt; &#123; if (+value &gt; 500) &#123; this.dataSub.unsubscribe(); &#125; &#125;); &#125; onUnmount() &#123; this.dataSub.unsubscribe(); this.cancelSub.unsubscribe(); this.rangeSub.unsubscribe(); &#125;&#125; 我们从dataSub订阅数据直到发生了button click或者是range范围变化为止。就意味着当这两想发生时我们就会停止数据的订阅。我们可以看到上面管理了3个subscripitions，很复杂。但其实我们可以把这些subscripition组合到一个subscripition里面来管理。 使用takeUntil来管理你的subscripition1234567891011121314151617181920class MyGenericComponent extends SomeFrameworkComponent &#123; updateData(data) &#123; // do something framework-specific to update your component here. &#125; onMount() &#123; const data$ = this.getData(); const cancelBtn = this.element.querySelector(‘.cancel-button’); const rangeSelector = this.element.querySelector(‘.rangeSelector’); const cancel$ = Observable.fromEvent(cancelBtn, &apos;click&apos;); const range$ = Observable.fromEvent(rangeSelector, &apos;change&apos;).map(e =&gt; e.target.value); const stop$ = Observable.merge(cancel$, range$.filter(x =&gt; x &gt; 500)) this.subscription = data$.takeUntil(stop$).subscribe(data =&gt; this.updateData(data)); &#125; onUnmount() &#123; this.subscription.unsubscribe(); &#125;&#125; 可以看到我们使用一个stop$就管理了所有的subscripitions。优点： 很明显我们减少了代码量 这种方式给了我们一个可以complete observable的方法，当takeUntil条件满足后是会触发complete的，而单纯的调用unsubcribe只是不再订阅了，而source并不一定就结束了，这样就不会触发complete的 最后一个就是你把所有的东西都聚合在了一起，因为上述代码我们可以看到只有一个subscribe和一个unsubscribe, 而Observable，只有在调用了subscribe后才开始执行，这意味你把中心点都给聚合了，代码逻辑的开始和结束被归一了，代码会很清晰。 其他的操作符 take(n) takeWhile(predicate): 只有predicate返回true,才会触发数据，当是false时就结束了 first() first(predicate): 过滤所有的数据只有第一个满足predicate的数据会被触发，然后就结束了。 总结：使用takeUntil和takeWhile或者其他的当你看到多个subscripitions的时候就应当尝试使用takeUntil来管理它们。 更多的可组合性 当你结束一个stream的时候会触发complete 更少的代码 更少需要管理的东西 更少的subscribe调用","categories":[],"tags":[{"name":"rxjs","slug":"rxjs","permalink":"http://yoursite.com/tags/rxjs/"},{"name":"reactive programming","slug":"reactive-programming","permalink":"http://yoursite.com/tags/reactive-programming/"},{"name":"Ben Lesh(原文作者)","slug":"Ben-Lesh-原文作者","permalink":"http://yoursite.com/tags/Ben-Lesh-原文作者/"}]},{"title":"chrome-dev-you-may-dont-know","slug":"chrome-dev-you-may-dont-know","date":"2018-07-14T13:00:30.000Z","updated":"2018-07-14T13:00:30.000Z","comments":true,"path":"2018/07/14/chrome-dev-you-may-dont-know/","link":"","permalink":"http://yoursite.com/2018/07/14/chrome-dev-you-may-dont-know/","excerpt":"","text":"chrome devtools 中的一些实用技巧在元素面板中拖拽元素在控制台中引用元素面板中选中的元素在控制台中使用上次操作的结果修改元素的状态以及添加 css查找 css 属性定义的位置将修改的 css 样式保存到文件对单个元素的截图在控制台中使用 shift-enter(连续多行输入执行)清理控制台跳转…监听表达式XHR/FETCH 调试DOM 修改的调试———————————————–(华丽的分割线) 在元素面板中拖拽元素在元素面板中我们是可以拖拽任意元素到页面中其他位置的(这个大家应该都知道。。。) 控制台中引用元素面板中选中的元素在元素面板中选中元素，然后就可以在控制台中使用 $0 引用它，神奇了 大吃一惊还有这等操作(管用) 在控制台中使用上次操作的结果在控制台中输入 $_ 引用上次操作结果 他要$?就更神奇了（管用） 修改元素的状态以及添加 css这个大家都知道，直接截图就好了 在看下一个 查找 css 属性定义的位置使用 cmd-click(ctrl-click on windows) 组合点击一个元素面板中的 css 属性就会跳转到 Source panel 中(连续两连点击才可以哦) 不错不错（管用） 将修改的 css 样式保存到文件在元素面板右侧修改样式，然后使用上面方法跳 source panel 中，就会看到 css 源文件，右击文件名字，save as 保存到本地 对单个元素的截图选中一个元素然后按组合键 cmd-shift-p(or crtl-shift-p on windows)打开命令菜单(command menu), 接着输入 screenshot 选择 Capture node screenshot 有意思的功能, 可惜我试验失败了。。。（66.0.3359.139chrome 版本，大家可以试试），其实里面的 screenshot 还有另外两个 capture full siz screenshot(全截，我也失败了)， capture screenshot 接的是当文档展示的区域我成功了 在控制台中使用 shift-enter 连续多行输入执行多行输入执行，啥也不说了，有用（管用） 每次换行使用 shit+enter 哦 清理控制台清理使用 ctrl-l or cmd-k(管用) 跳转…在 source panel 中 cmd-o(ctrl-o on windows) 展示当前页面加载的所有文件 cmd-shift-o(ctrl-shift-o in windows) 展示当前文件的符号表（属性，函数以及类） ctrl-g 调到当前文件的指定行 亲测管用 监听表达式添加一个表达式到 debug session 中，不用手动计算了 管用， 在 source panel 中，若是没有 consle 面板，右键-&gt; evaluate in console 即可 XHR/FETCH 调试可以在 source panel 中的右侧看到 XHR/FETCH breakpoints 中添加断点，不知道请 ajax 啥时候发的，没问题，他可以帮你。。。 并且我还在下面发现了 Event Listener Breakpoint,而它可以带来的断点位置是在是太多了，比如： 动画（animation）, Canvas, Clipboard, DOM Mutaion, keyboard, 哎呀太多了，大家可以亲自试一试 DOM 修改的调试右键选中的元素，选择 break on 展开后会有 subtree modifications, 就是说如果有脚本修改了子元素，断点就会触发，还有 atrribute modification, 以及 node removal $$ 相当于 document.querySelectorAll()文章尾部福利赠送cmd-shfit-p 打开的命令行里面的有用命令(还有更多的等待大家一起探索) show layers 查看当前页面的渲染情况，合成层(关于合成层看淘宝)的状况，绘制的具体范围，等等检查性能一绝 show perfomance monitor 顾名思义 show frame per second(FPS) meter 顾名思义 show paint flashing rectangles 展示当前页面重绘的区域","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"chrome devtools","slug":"chrome-devtools","permalink":"http://yoursite.com/tags/chrome-devtools/"}]},{"title":"golang基础","slug":"golang基础","date":"2018-06-05T16:00:00.000Z","updated":"2018-07-14T13:00:30.004Z","comments":true,"path":"2018/06/06/golang基础/","link":"","permalink":"http://yoursite.com/2018/06/06/golang基础/","excerpt":"","text":"随时会更新 golang 的所有的都是 copy 赋值，=，传参，channel 发送等等都是。:= 这种声明方式若是已经定义了，则不会新建1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot;)func main() &#123; pase_student()&#125;type student struct &#123; Name string Age int&#125;func pase_student() &#123; m := make(map[string]*student) stus := []student&#123; &#123;Name: &quot;zhou&quot;, Age: 24&#125;, &#123;Name: &quot;li&quot;, Age: 23&#125;, &#123;Name: &quot;wang&quot;, Age: 22&#125;, &#125; for i, stu := range stus &#123; m[stu.Name] = &amp;stu; // 应该改为m[stu.Name] = &amp;stus[i] &#125; for _, va := range m &#123; fmt.Printf(&quot;%p \\n&quot;, va) &#125;&#125; stus 是个 map, stu 并不会每次新生成一个, 其实循环时每次都是相同的 stu, 而且 golang 每次都是 copy 语义，你再看一眼会发现，给 map 赋值的是指针，那就意味着无论你如何改变 map 都会是相同的值。:= 多次声明不会重新定义新的变量， 可见规范 见下: 123field1, offset := nextField(str, 0)field2, offset := nextField(str, offset) // redeclares offseta, a := 1, 2 // illegal: double declaration of a or no new variable if a was declared elsewhere golang 的字符串是不可变的，要想使用可变字符串可以使用 bytes，或者[]rune 数组, string 类型不可变，他的 slice 也不可变我们可以从关闭的 channel 中读取数据但是为空，就是说若是在 select 语句 case 中从关闭的 channel 是可以的。 参见123456select &#123;case &lt;- stopCh: fmt.Println(&quot;go&quot;)default: fmt.Println(&quot;come&quot;)&#125; 在使用 Go channel 的时候，一个适用的原则是不要从接收端关闭 channel，也不要关闭有多个并发发送者的 channel。 优雅关闭 go channel(http://www.tapirgames.com/blog/golang-channel-closing)channel 的使用，当 channel 是非缓冲的时候他就是阻塞读与写的， 所以使用 channel 的时候要小心同步阻塞，导致死锁 game over 123ch := make(chan string)ch &lt;- &quot;23&quot; // 此时就会阻塞// a &lt;- ch 单写他也是会阻塞的 所以要小心不要出现只有读或者只有写的 channel 若是出现的话，分布在不同 goroutine 中时就会导致 golang 死锁，主在等子完成可是子阻塞在了 channel 读或者写上了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package mainimport ( &quot;time&quot; &quot;math/rand&quot; &quot;sync&quot; &quot;log&quot; &quot;strconv&quot;)func main() &#123; rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // ... const MaxRandomNumber = 100000 const NumReceivers = 10 const NumSenders = 1000 wgReceivers := sync.WaitGroup&#123;&#125; wgReceivers.Add(NumReceivers) // ... dataCh := make(chan int, 100) stopCh := make(chan struct&#123;&#125;) // stopCh is an additional signal channel. // Its sender is the moderator goroutine shown below. // Its reveivers are all senders and receivers of dataCh. toStop := make(chan string, 1) // 设为缓冲1是为了防止moderator还未准备好就停止了 // the channel toStop is used to notify the moderator // to close the additional signal channel (stopCh). // Its senders are any senders and receivers of dataCh. // Its reveiver is the moderator goroutine shown below. var stoppedBy string // moderator go func() &#123; stoppedBy = &lt;- toStop // part of the trick used to notify the moderator // to close the additional signal channel. close(stopCh) &#125;() // senders for i := 0; i &lt; NumSenders; i++ &#123; go func(id string) &#123; for &#123; value := rand.Intn(MaxRandomNumber) if value == 0 &#123; // here, a trick is used to notify the moderator // to close the additional signal channel. select &#123; case toStop &lt;- &quot;sender#&quot; + id: default: &#125; return &#125; // the first select here is to try to exit the // goroutine as early as possible. select &#123; case &lt;- stopCh: return default: &#125; // 为什么要在前面在加一个select stopCh呢? 因为若是到了这一步由于select的随机性（此时stopCh和dataCh都处于活跃状态select是随机选取的），有可能会继续发送，而没有选择stopCh select &#123; case &lt;- stopCh: return case dataCh &lt;- value: &#125; &#125; &#125;(strconv.Itoa(i)) &#125; // receivers for i := 0; i &lt; NumReceivers; i++ &#123; go func(id string) &#123; defer wgReceivers.Done() for &#123; // same as senders, the first select here is to // try to exit the goroutine as early as possible. select &#123; case &lt;- stopCh: return default: &#125; select &#123; case &lt;- stopCh: return case value := &lt;-dataCh: if value == MaxRandomNumber-1 &#123; // the same trick is used to notify the moderator // to close the additional signal channel. select &#123; case toStop &lt;- &quot;receiver#&quot; + id: default: &#125; return &#125; log.Println(value) &#125; &#125; &#125;(strconv.Itoa(i)) &#125; // ... wgReceivers.Wait() log.Println(&quot;stopped by&quot;, stoppedBy)&#125; golang make 返回的是值类型，用 slice, map, channel, 并且会给 map 和 slice 预分配空间golang slice 语法可以对值也可以对引用123a = [1,2,34]t := a[1:3] // okc := (&amp;a)[1:2] // ok golang 切片的用法是 [start:end] 但不包括 endnew 返回的是指针类型golang 也存在 js 中的那个经典问题就是123456789101112131415161718func main() &#123; runtime.GOMAXPROCS(1) wg := sync.WaitGroup&#123;&#125; wg.Add(20) for i := 0; i &lt; 10; i++ &#123; go func() &#123; fmt.Println(&quot;i: &quot;, i) wg.Done() &#125;() &#125; for i := 0; i &lt; 10; i++ &#123; go func(i int) &#123; fmt.Println(&quot;i: &quot;, i) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 第一个打印的 i 都是 10， 因为他们打印的都是同一个变量 i。 golang 中 return defer 返回值的顺序先来假设出结论，帮助大家理解原因： 多个 defer 的执行顺序为“后进先出”； defer、return、返回值三者的执行逻辑应该是：return 最先执行，return 负责将结果写入返回值中；接着 defer 开始执行一些收尾工作；最后函数携带当前返回值退出。 如何解释两种结果的不同： 上面两段代码的返回结果之所以不同，其实从上面第 2 条结论很好理解。 a()int 函数的返回值没有被提前声名，其值来自于其他变量的赋值，而 defer 中修改的也是其他变量，而非返回值本身，因此函数退出时返回值并没有被改变。 b()(i int) 函数的返回值被提前声名，也就意味着 defer 中是可以调用到真实返回值的，因此 defer 在 return 赋值返回值 i 之后，再一次地修改了 i 的值，最终函数退出后的返回值才会是 defer 修改过的值。 defer 是在函数结束前执行的，当返回值的临时变量赋给外部时才算调用结束吧！a = fn(2) 当把值给了 a 才算结束 我们可以这么理解 return 肯定先执行执行的结果就是把返回值计算出来并且赋值给返回值所存在的临时变量, 但我们命名返回值的时候，返回值并不是临时变量而是函数中声明的变量 在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名append 只能作用在 slice 上而不能是指针参见签名 1func append(slice []Type, elems ...Type) []Type 错误的栗子 12345678910package mainimport &quot;fmt&quot;func main() &#123; s1 := []int&#123;1, 2, 3&#125; s2 := []int&#123;4, 5&#125; s1 = append(s1, s2) fmt.Println(s1)&#125; // 错误因为 append接下来的参数是以一个一个传递的切片中的元素，而不是切片 正确的是 s1 = append(s1, ...s2) 进行结构体比较时候，只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。并且结构体可比较的前提是结构的属性都可比较。map 和 slice 还有 function 不可比较就是说属性名字不同，类型不同或者顺序不同都是不能比较的 12345678910111213141516171819202122232425262728func main() &#123; sn1 := struct &#123; age int name string &#125;&#123;age: 11, name: &quot;qq&quot;&#125; sn2 := struct &#123; age int name string &#125;&#123;age: 11, name: &quot;qq&quot;&#125; if sn1 == sn2 &#123; fmt.Println(&quot;sn1 == sn2&quot;) &#125; sm1 := struct &#123; age int m map[string]string &#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125; sm2 := struct &#123; age int m map[string]string &#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125; if sm1 == sm2 &#123; fmt.Println(&quot;sm1 == sm2&quot;) &#125;&#125; 此处 sn1 可以和 sn2 使用==比较但是如下 1234sn3:= struct &#123; name string age int&#125;&#123;age:11,name:&quot;qq&quot;&#125; sn3 就不能比较了 还有上例中，含有不可比较的 map,slice，func 等，所以 sm1 和 sm2 是不可比较的但是我们可以使用 deepEqual 来进行比较 12345if reflect.DeepEqual(sn1, sm) &#123; fmt.Println(&quot;sn1 ==sm&quot;)&#125;else &#123; fmt.Println(&quot;sn1 !=sm&quot;)&#125; := 赋值模式的限制定义变量同时显式初始化不能提供数据类型只能在函数内部使用 nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”, 是不可以作为其他类型的空值的，比如 String, string 的空值是“”12345678var a chan int// a 是空值nil// chan的初始化一定是用makevar a map[int]string// a 是空值nil// map初始化一定使用make// 使用new 生成的map也是nil的map itoa1234567891011121314151617const ( x = iota y z = &quot;zz&quot; k p = iota)func main() &#123; fmt.Println(x,y,z,k,p)&#125;// 结果01zzzz4（直接计算当前的值） golang const 常量可以使用 itoa 赋值， 甚至是自定义类型参见 若是自定义类型类似于枚举，当我们传递字面量（如：2，3）时也是可以被识别为枚举值的。 当在一行声明两个常量 itoa 时，itoa 是只有到了下一行才会增长 123456789101112const ( Apple, Banana = iota + 1, iota + 2 Cherimoya, Durian Elderberry, Fig)// 输出// Apple: 1// Banana: 2// Cherimoya: 2// Durian: 3// Elderberry: 3// Fig: 4 itoa 从 0 开始增长，当我们们不使用 itoa 时，且赋值一个则所有的都会是这个值 123456const ( a = &quot;1&quot; b c d) goto 不能跳转到其他函数或者内层代码, 只能在本函数以及相同的 scope 内下面的就是错的 12345678910package mainfunc main() &#123; for i:=0;i&lt;10 ;i++ &#123; loop: println(i) &#125; goto loop&#125; 注意 defintion 和 type alias 的区别 defintion 是定义了一个新的类型，alias 仅仅是个别名1234567891011package mainimport &quot;fmt&quot;func main() &#123; type MyInt1 int type MyInt2 = int var i int =9 var i1 MyInt1 = i // 错误 MyInt1是个新类型 var i2 MyInt2 = i // yes 是个别名 fmt.Println(i1,i2)&#125; 1. 我们在返回值中定义的命名返回值，可以直接在函数中使用不用再重新定义 2. 内部 scope 中新定义的内部变量是会覆盖掉外部的变量12345678910111213141516171819202122232425262728293031package mainimport ( &quot;errors&quot; &quot;fmt&quot;)var ErrDidNotWork = errors.New(&quot;did not work&quot;)func DoTheThing(reallyDoIt bool) (err error) &#123; if reallyDoIt &#123; result, err := tryTheThing() if err != nil || result != &quot;it worked&quot; &#123; err = ErrDidNotWork &#125; fmt.Println(err) &#125; return err&#125;func tryTheThing() (string,error) &#123; return &quot;&quot;,ErrDidNotWork&#125;func main() &#123; fmt.Println(DoTheThing(true)) fmt.Println(DoTheThing(false))&#125;// 输出两个&lt;nil&gt;&lt;nil&gt; 改为 12345678910func DoTheThing(reallyDoIt bool) (err error) &#123; var result string if reallyDoIt &#123; result, err = tryTheThing() // 不要新定义变量 if err != nil || result != &quot;it worked&quot; &#123; err = ErrDidNotWork &#125; &#125; return err&#125; panic 仅有最后一个可以被 revover 捕获,panic 中可以传任何值，不仅仅可以传 string1234567891011121314151617181920212223242526272829func main() &#123; defer func() &#123; if err:=recover();err!=nil&#123; fmt.Println(&quot;++++&quot;) f:=err.(func()string) fmt.Println(err,f(),reflect.TypeOf(err).Kind().String()) &#125;else &#123; fmt.Println(&quot;fatal&quot;) &#125; &#125;() defer func() &#123; // 这里就recover是捕获不到err的，所以这里的err是nil if err:=recover();err!=nil&#123; fmt.Println(&quot;++++&quot;) f:=err.(func()string) fmt.Println(err,f(),reflect.TypeOf(err).Kind().String()) &#125;else &#123; fmt.Println(&quot;fatal&quot;) &#125; &#125;() defer func() &#123; panic(func() string &#123; return &quot;defer panic&quot; &#125;) &#125;() panic(&quot;panic&quot;)&#125; 不管运行顺序如何，当参数为函数的时候，要先计算参数的值map 引用不存在的 key，不报错map 使用 range 遍历顺序问题，并不是录入的顺序，而是随机顺序append 函数返回更新后的 slice（长度和容量可能会变），必须重新用 slice 的变量接收，不然无法编译通过golang channel 和一个 goroutine 组合起来就是一个 web-worker 的模式，只是我们在 js 里管理的是 web-worker 的句柄，而在 golang 里面我们要管理的是 channel,这里 golang 的一个优势是我可以把多个 channel 和一个 goroutine 绑定，而 web-worker 一个句柄就对应这个一个 web-worker 是不可能多对一的。golang channel 的使用方式两种 调用者生成传递个 goroutine。 被调用者生成返回给调用者。 内嵌结构体，当内嵌结构体不是指针时，是会有默认值得，这就符合了 golang 得概念，所有的变量都有默认值，指针的默认值是 nil.123456789101112package mainimport &quot;sync&quot;type A struct &#123; sync.Mutex&#125;func main() &#123; a := A&#123;&#125; a.Lock() a.Unlock() fmt.Println(&quot;Mutex a &quot;, a)&#125; 上面代码运行是 ok 的。 两个 golang 问题 http://colobu.com/2018/03/08/two-issues-in-go-development/golang 包的引入路径 GOPATH/src/…一层一层查找bin 是可执行的文件， pkg 是编译生成的.a 文件的存放位置是静态库src 是存放源文件的命令安装问题 golang/x/tools &gt; https://github.com/golang/tools下载放到 src 下的 golang/x/下 安装问题 golang/x/net &gt; https://github.com/golang/net下载放到 src 下的 golang/x/下 golint go get -u -v github.com/golang/lint/golint编译时的使用第三方源码包 编译时的探索 在使用第三方包的时候，当源码和.a 均已安装的情况下，编译器链接的是源码 所谓的使用第三方包源码，实际上是链接了以该最新源码编译的临时目录下的.a 文件而已。 标准库在编译时也是必须要源码的。不过与自定义包不同的是，即便你修改了 fmt 包的源码（未重新编译 GO 安装包），用户源码编译时，也不会尝试重新编译 fmt 包的，依旧只是在链接时链接已经编译好的 fmt.a Go 语言中 import 后面路径中最后的一个元素到底是包名还是路径名？答案是目录名。按照 Golang 语言习惯，一个 go package 的所有源文件放在同一个目录下，且该目录名与该包名相同，比如 libproj1/foo 目录下的 package 为 foo，foo1.go、 foo2.go…共同组成 foo package 的源文件。但目录名与包名也可以不同。 一个路径下不允许有两个包。 同其他语言 nodejs 一样，一个包被导入一次后就会被缓存，再次被导入会从缓存获取init 函数的执行顺序 对同一个 go 文件的 init()调用顺序是从上到下的 对同一个 package 中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的 init()函数,对于 对不同的 package，如果不相互依赖的话，按照 main 包中”先 import 的后调用”的顺序调用其包中的 init() 如果 package 存在依赖，则先调用最早被依赖的 package 中的 init() 最后调用 main 函数 关于关闭 channel 有几点需要注意的是： 重复关闭 channel 会导致 panic。 向关闭的 channel 发送数据会 panic。 从关闭的 channel 读数据不会 panic，读出 channel 中已有的数据之后再读就是 channel 类似的默认值，比如 chan int 类型的 channel 关闭之后读取到的值为 0。 make 和 new new allocate the memory and return the pointer make allocate the memory and initialize the memory cause slice, map and channel must be initialized before usenew 的作用是 初始化 一个指向类型的指针 (T)， make 的作用是为 slice, map 或者 channel 初始化，并且返回引用 Tmake(T, args)函数的目的与 new(T)不同。它仅仅用于创建 Slice, Map 和 Channel，并且返回类型是 T（不是 T）的一个初始化的（不是零值）的实例。 这中差别的出现是由于这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。 例如, Slice 是一个 具有三项内容的描述符，包括 指向数据（在一个数组内部）的指针，长度以及容量。在这三项内容被初始化之前，Slice 的值为 nil。对于 Slice，Map 和 Channel， make（）函数初始化了其内部的数据结构，并且准备了将要使用的值。 产品中一定不要使用默认的 http.Get如果你觉得方便，直接使用 http.Get 或者类似的方法发送请求，可能会导致一些问题， 因为这默认是使用 DefaultClient 作为 client: 多 goroutine 共享，这意味着在别处对 DefaultClient 的改动会影响你当前的使用 未设置 connection timeout 和 read/write timeout 默认的 idle connection 等设置可能不满足你的需求 检查网络错误或者超时 net.Error 和 err.Timeout() 可以检查是不是超时错误123if err, ok := err.(net.Error); ok &amp;&amp; err.Timeout() &#123; ……&#125; golang 命名返回值123func test()(a int) &#123; return&#125; 实际上 a 相当于已经命名了，相当于 1234func test() int &#123; var a int return a&#125; channel 关闭问题 通过 recover 来恢复来恢复 通过 Mutex 来保证不会向已关闭的 channel 发送消息 通过 sync.Once 来关闭，保证不会重复关闭好的原则是： 不要在接收端关闭 channel, 避免向关闭的 channel 发送消息 不要关闭有多个并发发送者的 channel golang 里面所有未赋值的变量都会赋值为默认值，就连内嵌 struct, infterface 也一样 内嵌 struct 会变为相应字段的默认值 内嵌 interface 为赋值就是 nil, 因为接口变量的默认值就是 nil(但 nil 和 nil 是不同的， 这里是个坑) 若是要 marshal 时，不要输出 null 字段或者是为空的字段（结构体），需要把它赋值为指针才可以然后加上 omitemptyhttps://stackoverflow.com/questions/18088294/how-to-not-marshal-an-empty-struct-into-json-with-go?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa http://colobu.com/2017/05/12/call-private-functions-in-other-packages/ 突破 golang 的访问限制reflect reflect.TypeOf,是获取类型的元数据 1reflect.TypeOf(i).Elem().Field(0).Tag //获取定义在struct里面的标签 reflect.ValueOf,是获取类型的值 1reflect.ValueOf(i).Elem().Field(0).String() //获取存储在第一个字段里面的值 http://www.01happy.com/p3206/最后再次重复一遍反射三定律： 反射可以将“接口类型变量”转换为“反射类型对象”。 反射可以将“反射类型对象”转换为“接口类型变量”。 如果要修改“反射类型对象”，其值必须是“可写的”（settable）。 一旦你理解了这些定律，使用反射将会是一件非常简单的事情。它是一件强大的工具，使用时务必谨慎使用，更不要滥用。 只有可以 addressable 的变量才可以使用 reflect 进行赋值修改即：wrong 123var x float64 = 3.4v := reflect.ValueOf(x)v.SetFloat(7.1) // Error: will panic. yes 1234var x float64 = 3.4p := reflect.ValueOf(&amp;x) // Note: take the address of x.fmt.Println(&quot;type of p:&quot;, p.Type())fmt.Println(&quot;settability of p:&quot;, p.CanSet()) 存入 map 的是值是不可以 addressable 的 a = map [string]int; &amp;a[“s”], 这个很好理解因为，map 回去做冲突处理，地址有可能发生变化。 [go web 的一些建议](https://medium.com/@matryer/how-i-write-go-http-services-after-seven-years-37c208122831 Shared dependencies are fields of the structure通过结构体的字段共享依赖，而不是到处引入（适用于所有的） I have a single file inside every component called routes.go where all the routing can live: 123456package appfunc (s *server) routes() &#123; s.router.HandleFunc(&quot;/api/&quot;, s.handleAPI()) s.router.HandleFunc(&quot;/about&quot;, s.handleAbout()) s.router.HandleFunc(&quot;/&quot;, s.handleIndex())&#125; This is handy because most code maintenance starts with a URL and an error report — so one glance at routes.go will direct us where to look. If a particular handler has a dependency, take it as an argument. 若是有特殊依赖则作为参数传入 4. https://github.com/dgryski/go-perfbook/blob/master/performance.mdhttps://my.oschina.net/xinxingegeya/blog/729673 golang unsafe 包的 unsafe 特性错误和异常，意料之内的是错误，意料之外的是异常(https://studygolang.com/articles/11753?fr=sidebar)从标准输入读取 os.Stdin 实现了 Reader 接口可以直接 Read 12s := make([]byte, 10)n, err := os.Stdin.Read(s) fmt.Scanf() 可以读取 so.Stdin 123var firstname, secondname stringfmt.Scanln(&amp;FirstName, &amp;SecondNames) //Scanln 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。fmt.Scanf(&quot;%s %s&quot;, &amp;firstName, &amp;lastName) //Scanf与其类似，除了 Scanf 的第一个参数用作格式字符串，用来决定如何读取。 os.Stdin 是个 Reader 但是没有缓冲， 可以使用 bufio.NewReader()生成一个带缓冲的 12345inputReader := bufio.NewReader(os.Stdin)for &#123; input, _ := inputReader.ReadString(&apos;\\n&apos;) fmt.Println(input)&#125; Reader 接口 Read 方法也就是说，当 Read 方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。io.EOF 变量的定义：var EOF = errors.New(“EOF”)，是 error 类型。根据 reader 接口的说明，在 n &gt; 0 且数据被读完了的情况下，返回的 error 有可能是 EOF 也有可能是 nil。 Writer 接口 Write 方法Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n &lt; len(p)，它就必须返回一个 非nil 的错误。 golang 比较行为 指针只有指针指向的内容是同一个时才相等 接口值可以比较， 但若是接口值得类型相同，但是值却是不可比较的例如slice等，就会报runtime error Slice, map, and function values are not comparable func的receiver是 值时 无论调用者是指针还是值都可以调用func如下若是使用指针作为receiver，则print 值时无法调用到String12345678910111213type A struct &#123; c int&#125;func (a A) String() string &#123; return &quot;dj&quot;&#125;func format() &#123; a := &amp;A&#123;c: 22&#125; fmt.Println(a)&#125; bufio的readSlice返回的是bufio.Reader的里的buf（Reader缓存的slice），因此当再此读取以后返回的slice的值是改变的 一般的reader都是没有缓冲的，bufio就是给reader加缓冲的1234567func readSlice() &#123; reader := bufio.NewReader(strings.NewReader(&quot;http://studygolang.com.\\nIt is the home of gophers&quot;)) line, _ := reader.ReadSlice(&apos;\\n&apos;) fmt.Println(&quot;the line is &quot;, string(line)) n, _ := reader.ReadSlice(&apos;\\n&apos;) fmt.Println(string(n), string(line))&#125; 最后n和slice的值相同 而ReadBytes和ReadString就不会出现这个问题了，他们都新开辟的空间 如果ReadSlice在找到界定符之前遇到了error，它就会返回缓存中所有的数据和错误本身（经常是 io.EOF）。如果在找到界定符之前缓存已经满了，ReadSlice会返回bufio.ErrBufferFull错误。当且仅当返回的结果（line）没有以界定符结束的时候，ReadSlice返回err != nil，也就是说，如果ReadSlice返回的结果line不是以界定符delim结尾，那么返回的err也一定不等于nil（可能是bufio.ErrBufferFull或io.EOF）。并且当下次在读取时会继续向前1234567func ReadSliceSize() &#123; reader := bufio.NewReaderSize(strings.NewReader(&quot;http://studygolang.com.\\nIt is the home of gophers&quot;), 10) line, _ := reader.ReadSlice(&apos;\\n&apos;) fmt.Println(&quot;the line is &quot;, string(line)) n, _ := reader.ReadSlice(&apos;\\n&apos;) fmt.Println(string(n), string(line))&#125; 然而使用ReadBytes和ReadString就没有这个问题了，bufio.reader会自动为我们处理。 golang排序对基本类型排序 int, float等sort包有sort.Ints, sort.Float64s等方法排序，会改变原数组 其他类型则需要实现 sort.Interface接口了 ，如less,等 程序中使用time.Time程序中应使用 Time 类型值来保存和传递时间，而不是指针。就是说，表示时间的变量和字段，应为time.Time类型，而不是*time.Time.类型。一个Time类型值可以被多个go程同时使用 time 格式化这是实际开发中常用到的。 time.Parse 和 time.ParseInLocation time.Time.Format解析对于解析，要特别注意时区问题，否则很容易出 bug。比如： t, _ := time.Parse(“2006-01-02 15:04:05”, “2016-06-13 09:14:00”)fmt.Println(time.Now().Sub(t).Hours())2016-06-13 09:14:00 这个时间可能是参数传递过来的。这段代码的结果跟预期的不一样。 原因是 time.Now() 的时区是 time.Local，而 time.Parse 解析出来的时区却是 time.UTC（可以通过 Time.Location() 函数知道是哪个时区）。在中国，它们相差 8 小时。 所以，一般的，我们应该总是使用 time.ParseInLocation 来解析时间，并给第三个参数传递 time.Local。 string和number互转 ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings: number和byte (数字和字节互转)想进行地址的加减操作就得使用uintptr1234bts := [5]byte&#123;2, 3, 4, 5, 6&#125;fmt.Println(bts)c := (*[4]byte)(unsafe.Pointer((uintptr(unsafe.Pointer(&amp;bts)) + uintptr(1))))[:]fmt.Println(c) 输出正确，直接使用 slice就错误（bts := []byte{2,3,4,5,6}）原因是：bts为slice的时候 bts的内部结构是12345type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; 也就是说转化为[]byte以后 只有Data的地址，Len和Cap的值被转化为了字节 string 和 []byte 无copy转换// reflect.SliceHeader and reflect.StringHeader12345678910type SliceHeader struct &#123; Data uintptr Len int Cap int&#125;type StringHeader struct &#123; Data uintptr Len int&#125; 123456789101112131415161718192021/* struct string&#123; uint8 *str; int len; &#125; struct []uint8&#123; uint8 *array; int len; int cap; &#125; uintptr是golang的内置类型，是能存储指针的整型，uintptr的底层类型是int，它和unsafe.Pointer可相互转换。 但是转换后的string与[]byte共享底层空间，如果修改了[]byte那么string的值也会改变，就违背了string应该是只读的规范了，可能会造成难以预期的影响。*/func str2byte(s string) []byte &#123; x := (*[2]uintptr)unsafe.Pointer(&amp;s) h := [3]uintptr&#123;x[0],x[1],x[1]&#125; return *(*[]byte)(unsafe.Pointer(&amp;h))&#125;func byte2str(b []byte) string&#123; return *(*string)(unsafe.Pointer(&amp;b))&#125; golang json问题 json tag json:&quot;name,omitempty,type&quot; json: “name,[option]” int 为0时，若tag 为omitempty, int会不被序列化出来， omitempty，tag里面加上omitempy，可以在序列化的时候忽略0值或者空值 解决办法是使用 指针 1234type Test struct &#123; String *string `json:&quot;string,omitempty&quot;` Integer *int `json:&quot;integer,omitempty&quot;`&#125; int8 byte uint8 json序列化的时候 会被当做字符串处理 123456789type CA struct &#123; List []uint8 &#125; func main() &#123; ca := CA&#123;[]uint8&#123;1,2,3,4,5,6,7,8,9,0&#125;&#125; r, _ := json.Marshal(ca) fmt.Println(string(r)) //&#123;&quot;List&quot;:&quot;AQIDBAUGBwgJAA==&quot;&#125; &#125; 当我们想给某操作加缓冲区时就可以使用bytes.Buffer","categories":[],"tags":[]},{"title":"instanceof带来的思考与es规范的研究","slug":"instanceof带来的思考","date":"2018-06-05T16:00:00.000Z","updated":"2018-07-14T13:00:30.040Z","comments":true,"path":"2018/06/06/instanceof带来的思考/","link":"","permalink":"http://yoursite.com/2018/06/06/instanceof带来的思考/","excerpt":"","text":"源码面前了无秘密，规范面前也一样啊！ 问题今天在jjc的群里正美大大抛出了一个问题 答案全是false 郁闷点我很郁闷了，我觉得按照instanceof的执行过程应该是true啊！为啥呢？因为一下两点 我记忆中instanceof的流程是，比如： “k instanceof v”就是验证v.prototype 在 k的原型链中 证明如下 而在REPL中查看 如下12(2).\\__proto\\__ === Number.prototype// true 那么为啥 2 instanceof Number 是false呢 接下来我要开始装逼了 下面的es规范是基于ecma-262/5.1的，es6的规范有了一些变化，有了更多的新东西，更加严谨，但原理是一致的。 先来讲讲js里的原始类型 我们知道js中的原始类型(primitive) 只有如下几种1Undefined, Null, Boolean, String, Number es6中多了一个原始类型 Symbol 要注意，Number是指原始类型而不是内置的Number对象, 其他类似 因此 3, ‘123’, true, false, null, undefined等是原始类型，不是对象(Object)哦。 也就是说3 和 new Number(3)或者Number(3)不是一个类型哦，后两者是对象参见下图 各位看官有没有看到里面的另一句话啊: Number object 可以通过是用Number函数方式的调用在转换为Number value。 Number(new Number(3)) instanceof Number === false 剩下的就是对象了Object，各种对象，就不缺对象 接下来上 instanceof 的规范, 一步一步揭开秘密例子13 instanceof Number 我们一步一步讲来 1. The instanceof operator The production RelationalExpression : RelationalExpression instanceof ShiftExpression is evaluated as follows: Let lref be the result of evaluating RelationalExpression. 计算左侧 为3 Let lval be GetValue(lref). GetValue 调用返回值\b赋值给lval(此处我们只要知道GetValue(3) === 3就好了，后面会细讲) Let rref be the result of evaluating ShiftExpression. 计算Number ，那就是Number Let rval be GetValue(rref). 同2 这里rval = Number If Type(rval) is not Object, throw a TypeError exception. Type 调用会返回rval的类型，此处是对象Object[1]。 If rval does not have a [[HasInstance]] internal method, throw a TypeError exception. 判断rval 是否有HasInstance 方法 Return the result of calling the [[HasInstance]] internal method of rval with argument lval.使用lval作为参数调用rval的[[HasInstance方法]] \b就是 Number[[HasInstance]] (3) 接下来就该[[HasInstance]]了 2. [[HasInstance]] (V)Assume F is a Function object. 假设F是一个函数对象 When the [[HasInstance]] internal method of F is called with value V, the following steps are taken: 当我们调用F的[[HasInstance\b]]方法时走如下步骤 If V is not an object, return false. 如果v不是对象，返回false很明显我们上面的调用就结束了。。。因为3不是个对象，而是个Number value Let O be the result of calling the [[Get]] internal method of F with property name “prototype”. 获取\b F的prototype 给 O If Type(O) is not Object, throw a TypeError exception. Repeat Let V be the value of the [[Prototype]] internal property of V. If V is null, return false. If O and V refer to the same object, return true. 找到V的原型\b链，然后依次向上查找，直到结束，若\bO与其中一个原型是同一个对象返回\btrue, 否则false NOTE Function objects created using Function.prototype.bind have a different implementation of [[HasInstance]] defined in 15.3.4.5.3. 到此我们已经搞定为了为啥 3 instanceof Number 是false了，打完，不收工。还有一个Symbol啊，在此有个很魔性的地方，我上面引入的ecma262/5.1是没有Symbol的，我们去看ecma262/6.0，里面是有Symbol的，可是在\b那里我们可以看到Symbol也进级为了原始类型，因此Symbol(‘a’) instanceof Symbol自然也是 false了，你说魔性不魔性。 结束了？no 不结束！GetValue我们还没讲呢在此我们先来看看 Reference是啥官方解释如下1234The Reference type is used to explain the behaviour of such operatorsas delete, typeof, the assignment operators, the super keyword andother language features. For example, the left-hand operand of anassignment is expected to produce a reference. 我只看明白是为了解释某些操作而存在的，例如delete, typeof, super, left-hand operand等等,还有super keyword等等 Reference 含有3个component base value: any 甚至是Environment Record referenced name: string or symbol strict reference flag: true or false 那什么时候会创建一个Reference呢 规范并没有说怎么设置，我在stackoverflow 上看到了以下三个会创建并返回Reference的情况 identifier reference expressions, that resolve the identifier in the current lexical environment (or one of its parents)标识符，解析标识符时会创建一个reference, base value is envRec, referenced name is identifier property accessor expressions, i.e. the .… and […] operators属性获取时会创建一个reference(这个就是我们后面要用到的哦) function calls to host functions are permitted to return them, but such don’t exist.这个在es5规范里有说，是可以返回，但没有规定一定返回 接下来说说我的另一个问题了，就是下面的类型转换是怎么发生的？Number value =&gt; Number object12(2).\\__proto\\__// [Number: 0] 上面的转换\b很显然是获取属性发生的转换，我们一步一步解析，请看下面 1. “(2).__proto__” 是啥, 从表达式走起123456789101111 Expressions11.1 Primary ExpressionsSyntax PrimaryExpression : this Identifier Literal ArrayLiteral ObjectLiteral ( Expression ) 参见上面，我们”(2)”是PrimaryExpression, 再来看看 (Expression)是啥 123411.1.6 The Grouping Operator The production PrimaryExpression : ( Expression ) is evaluated as follows: 1. Return the result of evaluating Expression. This may be of type Reference. NOTE This algorithm does not apply GetValue to the result of evaluating Expression. The principal motivation for this is so that operators such as delete and typeof may be applied to parenthesised expressions.很显然我们”(2)”是group expression,按照规范的描述，group expression返回的有可能是Reference 2. “2” 咋计算看了上面我们知道了”(2)”是啥，那按照规范所说的，”(2)”属于Express, 也可以看出来”2” 属于PrimaryExpression 中的Literal, 于是就有了下面的1211.1.3 Literal Reference A Literal is evaluated as described in 7.8. 看到了Literal 参见7.8 具体就是规定了Number literal的语法 3. (2)我们解决了，那么就该”(2).__proto__”了， 这是一个属性获取，于是有了下面的规范, 规范先描述了属性获取的语法”.”和”[]”,然后是算法描述The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows: Let baseReference be the result of evaluating MemberExpression. 左侧计算 得到 2 赋值给baseReference Let baseValue be GetValue(baseReference). 调用GetValue, 对2 ，依然返回2 Let propertyNameReference be the result of evaluating Expression. 计算属性Expression 赋值给 propertyNameReference， 对于’.’调用会变为’[]’ 于是 就是”__proto__”字符串 Let propertyNameValue be GetValue(propertyNameReference). 调用GetValue, 对于propertyNameReference ，依然返回”__proto__”字符串 Call CheckObjectCoercible(baseValue). 判断baseValue不是Null或者Undefined Let propertyNameString be ToString(propertyNameValue). 转为String If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let strict be false. Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict. 返回 Reference, base value是baseValue，对于我们的baseValue就是2，referenced name 是 propertyNameString，对于我们就是”__proto__” The production CallExpression : CallExpression [ Expression ] is evaluated in exactly the same manner, except that the contained CallExpression is evaluated in step 1. 这句话的意思就是 CallExpress和属性获取类似。 到这里我们就完成了 “(2).__proto__”的完整解析，这个完整解析返回了一个Reference, 可是类型转换呢？ 4. 对属性获取返回的Reference的使用上面的步骤我们是完成了整个表达式的解析，但还没有使用表达式返回的结果，那我们来使用一下，比如 “(2).__proto__ === 2”11.9.4 The Strict Equals Operator ( === ) The production EqualityExpression : EqualityExpression === RelationalExpression is evaluated as follows: Let lref be the result of evaluating EqualityExpression. 解析 EqualityExpression ,我们从前面可以得知，”(2).__proto__”， 解析之后是一个Reference, 类似于 {baseValue: 2, referencedName: “__proto__”, strict:…} Let lval be GetValue(lref). 重头戏来了 把我们上一步得到的Reference 作为参数调用 GetValue会返回什么呢？ 见下 Let rref be the result of evaluating RelationalExpression. Let rval be GetValue(rref). Return the result of performing the strict equality comparison rval === lval. (See 11.9.6) 5. GetValue调用上面的严格等于我们就不分析了，不是重点，来看看GetValue吧。很长很高能 8.7.1 GetValue (V) If Type(V) is not Reference, return V. 判断V是不是一个Reference,不是直接返回V， 现在明白了GetValue(2)为啥返回2了吧。 Let base be the result of calling GetBase(V). 获取base value, 对我们的Ref 就是2 If IsUnresolvableReference(V), throw a ReferenceError exception. 这是用来判断base value为非null和undefined的 If IsPropertyReference(V), then If HasPrimitiveBase(V) is false, then let get be the [[Get]] internal method of base, otherwise let get be the special [[Get]] internal method defined below. base value 不是原始类型，则让get为base的内部[[Get]]方法，若是原始类型则参见下面的internal [[GET]]方法的逻辑，嗯，我们的base value是2，于是就得走下面的internal [[GET]]方法了 Return the result of calling the get internal method using base as its this value, and passing GetReferencedName(V) for the argument. 调用get，使用referenceName作为参数, base value作为this判断V的base value是不是object, number, string, Boolean Else, base must be an environment record. 不是 上面列举的几类，那就一定是environment record Return the result of calling the GetBindingValue (see 10.2.1) concrete method of base passing GetReferencedName(V) and IsStrictReference(V) as arguments. The following [[Get]] internal method is used by GetValue when V is a property reference with a primitive base value. It is called using base as its this value and with property P as its argument. The following steps are taken: internal [[GET]]method Let O be ToObject(base). 我的神啊，神啊，神啊，神啊，神啊，神啊，神啊，神啊，神啊，神啊，神啊，神啊，神啊，神啊，神啊， 终于看到了类型转换啊！！！ ToObject(base), 这个很简单了，把原始类型转换为对应Object类型，比如2(Number Value), 转换为Number Object, 其他类似 参见 Let desc be the result of calling the [[GetProperty]] internal method of O with property name P. …不解释了，往下就很容易理解了 If desc is undefined, return undefined. If IsDataDescriptor(desc) is true, return desc.[[Value]]. Otherwise, IsAccessorDescriptor(desc) must be true so, let getter be desc.[[Get]] (see 8.10). If getter is undefined, return undefined. Return the result calling the [[Call]] internal method of getter providing base as the this value and providing no arguments. NOTE The object that may be created in step 1 is not accessible outside of the above method. An implementation might choose to avoid the actual creation of the object. The only situation where such an actual property access that uses this internal method can have visible effect is when it invokes an accessor function. 这些说的就是step 1创建的object，不应当被外部访问到。 总结源码面前了无秘密，规范面前也一样啊！其实但我们理解了Reference 类型，那么this绑定的问题也就迎刃而解了，大家可以再去看看this的绑定问题也是基于Reference的 注[1]Type(v)解释 根据具体的内容返回相应的类型，如字面3,返回\bNumber Type，new Number(3) 返回Object 类型","categories":[],"tags":[]},{"title":"egg入门","slug":"egg","date":"2018-06-05T02:05:27.000Z","updated":"2018-07-14T13:00:30.002Z","comments":true,"path":"2018/06/05/egg/","link":"","permalink":"http://yoursite.com/2018/06/05/egg/","excerpt":"","text":"egg是基于koa的企业级web框架egg的使用感觉 约定大于配置 koa中间件基本无痛使用 可以总结业务通用基础服务（生产基础框架），而不用费心费力再重新写插件啥的 app -&gt; plugins -&gt; framework (统统一套约定) 照着官网总结了一部分详细的还得去官网查询 官方文档进行搭建 npm i egg-init -g egg-init egg-example –type=simple 关于 type: egg 本身的集成包括了很多的东西，从一个基本的webserver走起，沉淀出plugin, 最后是framework 于是type就很明显了webserver== simple… 整体结构 MVC文件夹约定所有相应的文件必须放在指定目录中 12345678910111213141516171819202122232425262728293031323334353637egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app| ├── router.js│ ├── controller│ | └── home.js│ ├── service (可选)│ | └── user.js│ ├── middleware (可选)│ | └── response_time.js│ ├── schedule (可选)│ | └── my_task.js│ ├── public (可选)│ | └── reset.css│ ├── view (可选)│ | └── home.tpl│ └── extend (可选)│ ├── helper.js (可选)│ ├── request.js (可选)│ ├── response.js (可选)│ ├── context.js (可选)│ ├── application.js (可选)│ └── agent.js (可选)├── config| ├── plugin.js| ├── config.default.js│ ├── config.prod.js| ├── config.test.js (可选)| ├── config.local.js (可选)| └── config.unittest.js (可选)└── test ├── middleware | └── response_time.test.js └── controller └── home.test.js 内置对象 Application (ctx.app, this.app) Response/Request (ctx.request, ctx.response) Context (this.ctx) Service (this.service)` Helper (this.ctx.helper) Logger (ctx.logger, this.logger（应用打印log）) 还有coreLogger(框架打印log) Config (this.config, app.config) Subscription 订阅发布模型的规范基类 controller12345678910111213141516171819202122// app/controller/post.jsconst Controller = require(&apos;egg&apos;).Controller;class PostController extends Controller &#123; async create() &#123; const &#123; ctx, service &#125; = this; const createRule = &#123; title: &#123; type: &apos;string&apos; &#125;, content: &#123; type: &apos;string&apos; &#125;, &#125;; // 校验参数 ctx.validate(createRule); // 组装参数 const author = ctx.session.userId; const req = Object.assign(ctx.request.body, &#123; author &#125;); // 调用 Service 进行业务处理 const res = await service.post.create(req); // 设置响应内容和响应状态码 ctx.body = &#123; id: res.id &#125;; ctx.status = 201; &#125;&#125;module.exports = PostController; this.ctx: 当前请求的上下文 Context 对象的实例，通过它我们可以拿到框架封装好的处理当前请求的各种便捷属性和方法。 this.app: 当前应用 Application 对象的实例，通过它我们可以拿到框架提供的全局对象和方法。 this.service：应用定义的 Service，通过它我们可以访问到抽象出的业务层，等价于 this.ctx.service 。 this.config：应用运行时的配置项。 this.logger：logger 对象，上面有四个方法（debug，info，warn，error），分别代表打印四个不同级别的日志，使用方法和效果与 context logger 中介绍的一样，但是通过这个 logger 对象记录的日志，在日志前面会加上打印该日志的文件路径，以便快速定位日志打印位置。 service1234567891011// app/service/user.jsconst Service = require(&apos;egg&apos;).Service;class UserService extends Service &#123; async find(uid) &#123; const user = await this.ctx.db.query(&apos;select * from user where uid = ?&apos;, uid); return user; &#125;&#125;module.exports = UserService; this对象和controller中能拿到的实例是相同的, service的使用是依据文件名来查找的，this.service.filename.method service 在使用构造函数时需要传递ctx参数 12345678class User extends app.Service &#123; // 默认不需要提供构造函数。 // constructor(ctx) &#123; // super(ctx); 如果需要在构造函数做一些处理，一定要有这句话，才能保证后面 `this.ctx`的使用。 // // 就可以直接通过 this.ctx 获取 ctx 了 // // 还可以直接通过 this.app 获取 app 了 // &#125;&#125; routerhttp://eggjs.org/zh-cn/basics/router.html 基本使用12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get(&apos;/user/:id&apos;, controller.user.info);&#125;; middlerware基本示例1234567891011121314151617const isJSON = require(&apos;koa-is-json&apos;);const zlib = require(&apos;zlib&apos;);async function gzip(ctx, next) &#123; await next(); // 后续中间件执行完成后将响应体转换成 gzip let body = ctx.body; if (!body) return; if (isJSON(body)) body = JSON.stringify(body); // 设置 gzip body，修正响应头 const stream = zlib.createGzip(); stream.end(body); ctx.body = stream; ctx.set(&apos;Content-Encoding&apos;, &apos;gzip&apos;);&#125; 使用 全局路由使用module.exports = {// 配置需要的中间件，数组顺序即为中间件的加载顺序middleware: [ ‘gzip’ ], // 配置 gzip 中间件的配置gzip: { threshold: 1024, // 小于 1k 的响应体不压缩},}; 某个路由使用 1234module.exports = app =&gt; &#123; const gzip = app.middleware.gzip(&#123; threshold: 1024 &#125;); app.router.get(&apos;/needgzip&apos;, gzip, app.controller.handler);&#125;; 框架默认中间件使用例如，想把某个自定义中间件放到所有中间件之前执行 12345// app.jsmodule.exports = app =&gt; &#123; // 在中间件最前面统计请求时间 app.config.coreMiddleware.unshift(&apos;report&apos;);&#125;; 上面的顺序可随意互换 koa中间件基本可无痛使用 通用配置（无论是框架还是自定义中间件都可以） enable：控制中间件是否开启。 match：设置只有符合某些规则的请求才会经过这个中间件。 ignore：设置符合某些规则的请求不经过这个中间件。 插件（就是个mini的egg应用，只是没有路由和controller罢了）http://eggjs.org/zh-cn/advanced/plugin.html 可以把我们的通用逻辑沉淀为插件 插件配置示例123456789101112131415161718192021exports.mongoose = &#123; enable: true, package: &apos;egg-mongoose&apos;,&#125;;exports.session = false;exports.cors = &#123; enable: true, package: &apos;egg-cors&apos;,&#125;;exports.jwt = &#123; enable: true, package: &apos;egg-jwt&apos;&#125;;exports.routerPlus = &#123; enable: true, package: &apos;egg-router-plus&apos;,&#125;; 定时任务http://eggjs.org/zh-cn/basics/schedule.html 框架扩展 context application response request helper扩展就是说可以通过context等实例直接访问到例如，我们要增加一个 ctx.foo() 方法：123456// app/extend/context.jsmodule.exports = &#123; foo(param) &#123; // this 就是 ctx 对象，在其中可以调用 ctx 上的其他方法，或访问属性 &#125;,&#125;; 特性根据环境进行框架扩展比如unittest环境app实例有mockXX方法12345// app/extend/application.unittest.jsmodule.exports = &#123; mockXX(k, v) &#123; &#125;&#125;; 启动自定义(可以执行一些异步初始化的工作)12345678910111213module.exports = app =&gt; &#123; app.beforeStart(async () =&gt; &#123; // 应用会等待这个函数执行完成才启动 app.cities = await app.curl(&apos;http://example.com/city.json&apos;, &#123; method: &apos;GET&apos;, dataType: &apos;json&apos;, &#125;); // 也可以通过以下方式来调用 Service // const ctx = app.createAnonymousContext(); // app.cities = await ctx.service.cities.load(); &#125;);&#125;; 配置基本默认123456config|- config.default.js|- config.test.js|- config.prod.js|- config.unittest.js`- config.local.js 配置加载顺序-&gt; 插件 config.default.js-&gt; 框架 config.default.js-&gt; 应用 config.default.js-&gt; 插件 config.prod.js-&gt; 框架 config.prod.js-&gt; 应用 config.prod.js 配置示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152module.exports = appInfo =&gt; &#123; appInfo; const config = exports = &#123;&#125;; // add your config here config.middleware = [&apos;errorhandler&apos;, &apos;auth&apos;]; config.auth = &#123; ignore: [] &#125;; // mongoose config.mongoose = &#123; url: &apos;mongodb://localhost:27017/trace-to-source&apos;, options: &#123;&#125;, &#125;; // multipart set config.multipart = &#123; fileSize: &apos;30mb&apos;, whitelist: [ &apos;.xlsx&apos;, &apos;.jpg&apos;, &apos;.png&apos;, &apos;.zip&apos;, ], &#125;; config.security = &#123; // 关闭csrf安全防范(关闭后post delete put请求可以不携带csrf-token) domainWhiteList: [&apos;http://47.104.6.246:8090&apos;, &apos;http://localhost:8000&apos;, &apos;https://localhost:8000&apos;], csrf: &#123; enable: false, &#125;, &#125;; // cors config.cors = &#123; credentials: true, allowMethods: &apos;GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS&apos;, &#125;; // logger config.logger = &#123; buffer: true, // 文件写入时缓存 https://github.com/eggjs/egg-logger/blob/master/lib/egg/loggers.js#L44 maxDays: 0, &#125;; config.jwt = &#123; secret: &apos;lksjdhglaiejf&apos; &#125;; return config;&#125;; 运行环境 通过 config/env 文件指定，该文件的内容就是运行环境，如 prod。一般通过构建工具来生成这个文件。 通过 EGG_SERVER_ENV 环境变量指定。一般使用 EGG_SERVER_ENV指定 自定义环境 比如，要为开发流程增加集成测试环境 SIT。将 EGG_SERVER_ENV 设置成 sit（并建议设置 NODE_ENV = production），启动时会加载 config/config.sit.js，运行环境变量 app.config.env 会被设置成 sit 应用内获取运行环境 框架提供了变量 app.config.env 来表示应用当前的运行环境。 测试ctx测试123456789101112131415161718192021const assert = require(&apos;assert&apos;);const mock = require(&apos;egg-mock&apos;);describe(&apos;test/controller/home.test.js&apos;, () =&gt; &#123; let app; before(() =&gt; &#123; // 创建当前应用的 app 实例 app = mock.app(); // 等待 app 启动成功，才能执行测试用例 return app.ready(); &#125;); it(&apos;should mock ctx.user&apos;, () =&gt; &#123; const ctx = app.mockContext(&#123; user: &#123; name: &apos;fengmk2&apos;, &#125;, &#125;); assert(ctx.user); assert(ctx.user.name === &apos;fengmk2&apos;); &#125;);&#125;); http请求测试(controller 测试)123456// 使用 asyncit(&apos;should redirect&apos;, async () =&gt; &#123; await app.httpRequest() .get(&apos;/&apos;) .expect(302);&#125;); service 测试12345678910111213141516describe(&apos;get()&apos;, () =&gt; &#123; it(&apos;should get exists user&apos;, async () =&gt; &#123; // 创建 ctx const ctx = app.mockContext(); // 通过 ctx 访问到 service.user const user = await ctx.service.user.get(&apos;fengmk2&apos;); assert(user); assert(user.name === &apos;fengmk2&apos;); &#125;); it(&apos;should get null when user not exists&apos;, async () =&gt; &#123; const ctx = app.mockContext(); const user = await ctx.service.user.get(&apos;fengmk1&apos;); assert(!user); &#125;);&#125;); 更多测试 多进程架构1234567891011 +--------+ +-------+ | Master |&lt;--------&gt;| Agent | +--------+ +-------+ ^ ^ ^ / | \\ / | \\ / | \\ v v v+----------+ +----------+ +----------+| Worker 1 | | Worker 2 | | Worker 3 |+----------+ +----------+ +----------+ 启动顺序 123456789101112131415+---------+ +---------+ +---------+| Master | | Agent | | Worker |+---------+ +----+----+ +----+----+ | fork agent | | +--------------------&gt;| | | agent ready | | |&lt;--------------------+ | | | fork worker | +-----------------------------------------&gt;| | worker ready | | |&lt;-----------------------------------------+ | Egg ready | | +--------------------&gt;| | | Egg ready | | +-----------------------------------------&gt;| 消息发送 12345678910111213141516171819202122232425广播消息： agent =&gt; all workers +--------+ +-------+ | Master |&lt;---------| Agent | +--------+ +-------+ / | \\ / | \\ / | \\ / | \\ v v v +----------+ +----------+ +----------+ | Worker 1 | | Worker 2 | | Worker 3 | +----------+ +----------+ +----------+指定接收方： one worker =&gt; another worker +--------+ +-------+ | Master |----------| Agent | +--------+ +-------+ ^ | send to / | worker 2 / | / | / v +----------+ +----------+ +----------+ | Worker 1 | | Worker 2 | | Worker 3 | +----------+ +----------+ +----------+ egg-logger 使用 自定义transport时一定要传递level参数 12345678class RemoteTransport extends Transport &#123; // level 必传 constructor(&#123; level, app &#125;) &#123; super(&#123; level &#125;); this._level = level; this._app = app; &#125;&#125; 自定logger在配置文件中必须传file参数, 必须在customLogger下面配置 12345config.customLogger = &#123; remoteLogger: &#123; file: path.join(appInfo.root, &apos;logs/remote.log&apos;), &#125;,&#125;; 所有logger的错误error方法都被errorLogger的log方法劫持了，所以当我们使用自定义logger的error方法打印时其实是被errorLogger输出了，所以若是自己配置的自定义logger中有其他处理使用error时是不会被触发的 原因见下 1234567891011121314151617/** * Add a logger * @param &#123;String&#125; name - logger name * @param &#123;Logger&#125; logger - Logger instance */set(name, logger) &#123; if (this.has(name)) &#123; return; &#125; // redirect ERROR log to errorLogger, except errorLogger itself if (name !== &apos;errorLogger&apos;) &#123; logger.redirect(&apos;error&apos;, this.errorLogger); &#125; this[name] = logger; super.set(name, logger);&#125; hack egg-mongoose 里面挂载在app上的mongoose是个conn对象，base才是mongoose实例 egg 里面的hack, app下面有个serviceClasses属性里面是所有的service的构造函数，所以在拿不到service实例时，可以自己new一个，切记要传入ctx对象，可以通过app.createAnonymousContext创建一个匿名ctx","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"docker相关的一些使用总结","slug":"docker基础知识","date":"2018-05-31T16:00:00.000Z","updated":"2018-07-14T13:00:30.001Z","comments":true,"path":"2018/06/01/docker基础知识/","link":"","permalink":"http://yoursite.com/2018/06/01/docker基础知识/","excerpt":"","text":"随时更新 解决docker sudo问题检查是否已有 docker 用户组1cat /etc/group | grep docker 将现有用户加入 docker 组1sudo gpasswd -a $&#123;USER&#125; docker 重启 docker 服务1sudo service docker restart 退出当前用户，重新登录docker 的远程镜像名字得和本地一致且以 url 为前缀比如 docker push docker.sensoro.com/library/ai-server，那么推送的地址是 docker.sensoro.com/library/ 我们的镜像想要叫 ai-server。 但是本地在 build 时，要用 docker build ./ -t docker.sensoro.com/library/ai-server tag 必须是这个。 docker compose networks 负责创建一个网络 见 sysctls 负责内核参数 见 ulimits swarm docker swarm init 根据上条命令输出执行即可 docker daemon api 链接docker 在配置为 host 网络模式时，是不需要映射端口的，因为 docker 容器的网络（ip）就是 host（宿主）的网络 IP，并没有进行隔离网络模式 host 模式 众所周知，Docker 使用了 Linux 的 Namespaces 技术来进行资源隔离，如 PID Namespace 隔离进程，Mount Namespace 隔离文件系统，Network Namespace 隔离网络等。一个 Network Namespace 提供了一份独立的网络环境，包括网卡、路由、Iptable 规则等都与其他的 Network Namespace 隔离。一个 Docker 容器一般会分配一个独立的 Network Namespace。但如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。 container 模式 在理解了 host 模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。 none 模式 这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。 bridge 模式 bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。下面着重介绍一下此模式。","categories":[],"tags":[]},{"title":"node图像库","slug":"node-img","date":"2018-05-23T16:00:00.000Z","updated":"2018-07-14T13:00:30.044Z","comments":true,"path":"2018/05/24/node-img/","link":"","permalink":"http://yoursite.com/2018/05/24/node-img/","excerpt":"","text":"image-demo 需要一个能在图片上写汉字色图片处理库 图片库比较1.node-images 国产图片处理库node-images，已经停止维护，缺乏某些功能，比如图片上加文字，并且在nodejs 8.0版本下无法使用 2.Jimp Jimp无需第三方依赖，安装简单，基本无坑，Github star4200多，npm周下载量7万多次，算是比较优秀的第三方处理库。支持常见的图片处理操作，也可以加文字，但是如果要在图片上加中文文字的话，有点麻烦，需要自制.fnt位图字体文件，然后导入。但CJK字库文字太多，制作出来文件很大。我就是因为这个，放弃了使用jimp。 3.node-lwip 和jimp类似，无第三方依赖。没有提供图片上写文字的方法。 4.sharp 目前nodejs中最快的图片处理库，和其他图片处理库相比，遥遥领先。无需第三方依赖，性能超好，就是安装比较麻烦，但最后还是安装成功了！一次性处理200张图片，sharp图片处理库的速度明显最快。按照官方说明，至少是5到10倍于ImageMagick and GraphicsMagick 。可惜，翻遍文档api也没有找到图片写文字的方法，就是说，没有提供图片直接写文字的方法。 关于sharp在windows 10 64位的安装，直接npm install sharp，基本都不会成功的。 Sharp的安装，需要三个前提条件： Node v4.5.0+ C++11 compatible compiler such as gcc 4.8+, clang 3.0+ or MSVC 2013+ node-gyp and its dependencies (includes Python) 对于windows10 64位来说，可以运行以下两条命令，一劳永逸解决sharp的安装问题： 先运行： npm install –global –production windows-build-tools 然后： npm config set msvs_version 2015 –global 就可以把所有的环境配置搞定。最后关掉所有cmd或者shell窗口，然后再用 npm install sharp安装就OK了。 速度超快，api好用，基本等于完美，可惜刚好我缺乏我需要的一个功能。 5.基于GraphicsMagick和ImageMagick的gm 如果不需要在图片上加中文文字，只需要安装GraphicsMagick就可以了。如果需要在图片上加【中文文字】，要同时安装GraphicsMagick 和 ImageMagick。然后使用gm subclass子类话的方法来调用。 注意：中文需要指定中文字体的.ttf文件，并且字体文件名不能是中文，如”msyh.ttf”，OK；“微软雅黑.ttf”，BAD! gm提供了超级强悍的api，基本上你需要对图片做的任何处理都能实现！并且它是基于命令行的，可以直接在命令行中调用。 GraphicsMagick和ImageMagick在windows10 64位下的安装都比较傻瓜式，直接下载对应的exe文件，不分32位和64位，setup 一路next就行。 总结，gm的速度仅仅比sharp慢，比其他的几个图片库都要快的多，并且提供的api很丰富，链式调用写法很爽，安装配置也相对简单的多，支持在图片上直接添加中文文字。其他的几个图片库，对于&rdquo;在图片上添加文字&ldquo;这个功能，有些不提供，有些提供了但很难用。 提供一段gm的示例代码（demo文件夹中）123456789101112131415161718var gm = require(&apos;gm&apos;);var fs = require(&apos;fs&apos;);var _name = &quot;China中文&quot;;gm(&apos;./0.jpg&apos;) .font(&apos;./st_black.ttf&apos;,30) .drawText(20, 30,&quot;你&quot;) .drawText(50, 50, &quot;好&quot;) .drawText(70, 70,&quot;色&quot;) .drawText(110, 110, &quot;彩&quot;) //.resize(240, 240) .toBuffer(&quot;jpg&quot;,(err, buffer)=&gt; &#123; fs.writeFileSync(&quot;./4.jpg&quot;, buffer); if (!err)&#123; console.log(&apos;done&apos;); &#125;else&#123; console.log(err.message || &quot;出错了！&quot;); &#125; &#125;); red-hat 安装gmImageMagick 安装 安装 yum install ImageMagick 查看是否安装成功 rpm -qa | grep ImageMagick gm 安装 npm install gm –save 测试代码1234567var gm = require(&quot;gm&quot;);var imageMagick = gm.subClass(&#123; imageMagick : true &#125;);var fs = require(&apos;fs&apos;);imageMagick(300, 300, &quot;pink&quot;).toBuffer(&quot;jpg&quot;, (err, buffer)=&gt;&#123; fs.writeFileSync(&quot;./fill.jpg&quot;, buffer); console.log(&quot;image create success!&quot;)&#125;) 会生成一个300*300，背景色为粉色的图片 #环境配置 代码运行环境1.node 开发时用的 8.9.0, node直接更新到最新的版本即可，没有太多限制 2.gm的依赖环境mac下环境配置 安装Xcode软件 很重要 在mac的应用中心就可以安装 安装imagemagick brew install imagemagick 安装graphicsmagick brew install graphicsmagick 以上3步之后 npm install gm 基本就没什么问题了 centos下环境配置 安装 imagemagick graphicsmagick的依赖 yum install -y gcc libpng libjpeg libpng-devel libjpeg-devel ghostscript libtiff libtiff-devel freetype freetype-devel 安装imagemagick yum install ImageMagick 安装graphicsmagick wget ftp://ftp.graphicsmagick.org/pub/GraphicsMagick/1.3/GraphicsMagick-1.3.25.tar.gz tar -zxvf GraphicsMagick-1.3.25.tar.gz cd GraphicsMagick-1.3.25 ./configure make make install 4.以上步骤之后 gm基本就能使用","categories":[],"tags":[]},{"title":"pki 体系","slug":"pki","date":"2018-05-13T16:00:00.000Z","updated":"2018-07-14T13:00:30.068Z","comments":true,"path":"2018/05/14/pki/","link":"","permalink":"http://yoursite.com/2018/05/14/pki/","excerpt":"","text":"PKICA 自建 cahttps://www.jianshu.com/p/79c284e826fahttps://www.barretlee.com/blog/2016/04/24/detail-about-ca-and-certs/ 生成秘钥(可选，因为后面的步骤也可以自动生成秘钥)openssl genrsa 生成 CA 证书请求openssl req [-key 使用已生成的秘钥][-keyout 未声明秘钥需自动生成] 自签发 ca 根证书openssl ca -selfsign（需使用上述的请求证书） 2,3 两步可以合在一起openssl req -new -x509(关键是-x509 生成 509 的根证书) 签发证书也是上述的步骤只是签发证书时不需要-selfsign 选项 证书发放向 CA 请求证书时需要先生成一个 CSR(certificate signing request), 证书签发的请求。包括一些申请者的信息，申请者的公钥，还有 Distinguished Name(专有名称类似于发放者的唯一标示)用来标识证书时发给谁的。 pem 代表 Privacy-enhanced Electronic Mail 一种文件格式 base64 编码显示CA DN distinguished name .cer/.crt 是用于存放证书，它是 2 进制形式存放的，不含私钥。 X.509 DER 编码(ASCII)的后缀是： .DER .CER .CRT X.509 PAM 编码(Base64)的后缀是： .PEM .CER .CRT .pem 跟 crt/cer 的区别是它以 Ascii 来表示 CSR 文件 包含了公钥和标识名称（Distinguished Name）intermediate ca证书链root ca -&gt; intermediate ca -&gt; end user 数字证书tsl 认证 单向认证时，客户端需要有 server 的根证书来验证 server 的证书是否 ok 双向时，服务端也得有客户端的根证书来验证 client 的证书是否 ok 私钥使用来解密公钥加密的数据，证书用来验证身份的，而证书又包含公钥，因此证书和私钥永远是一对儿。流程就是把证书发给对方，对方验证证书是否 ok，然后取出证书中的公钥，用公钥加密数据然后发回来，此时再用私钥解密即可获得数据。","categories":[],"tags":[]},{"title":"go map实战","slug":"gomap实战","date":"2018-05-09T16:00:00.000Z","updated":"2018-07-14T13:00:30.004Z","comments":true,"path":"2018/05/10/gomap实战/","link":"","permalink":"http://yoursite.com/2018/05/10/gomap实战/","excerpt":"","text":"go maps 实践 简介在cs中hash table是一种经常使用的数据结构。许多hash table的实现都拥有很多的属性。但总的来说，他们都会提供快速查询，添加以及删除等功能。go 提供了一个内置的实现了hash table的map 类型。 声明和初始化go map类型的签名如下 1map[KeyType]ValueType KeyType要求是能够comparable的类型, 而ValueType则可以是任意的类型，甚至是另一个map 如下一个key为string,value是int的map1var m map[string]int map类型也是引用类型，就像指针或者切片一样，因此上面的声明的m是nil;我们还没有实例化map。一个值是nil的map再读取的时候就像是个空map你啥都读不到12value, ok := m[&quot;c&quot;]// value is 0, ok is false 但是写入nil map是会报错的。千万记得不要这么做要记得初始化map，请使用内置的make function(make 专门用来分配内存，初始化map, slice, channel)1m = make(map[string]int) make会分配内存并且初始化然后返回一个map值，注意make不生成指针new才是返回指针但是new只分配内存，而不初始化。make的实现底层是基于的c的实现，本文只关注怎么使用，就不分析他的实现了。 使用mapsgo 提供了便捷的语法来操作map例如赋值1m[&quot;route&quot;] = 66 加下来取值1i := m[&quot;route&quot;] 若是我们取得值不存在那么我们取到的会是值相应类型的默认值（zero value）。在我们的例子中我们读到的就是0：12j := m[&quot;root&quot;]// j == 0 内置的len函数可以得到map中的元素个数12n := len(m)// n == 1 内置的delete函数是用来删除map中的元素1delete(m, &quot;route&quot;) delete没有返回值，并且若是删除的key不存在则啥都不处理 还有一种读取的语法如下1i, ok := m[&quot;route&quot;] 这个语法是：i取得是m中route对应的数据，若是不存在route对应的数据则i会是对应类型的零值，而ok代表的是route在m是否存在，false即是不存在也就是说没有读到i值。 当我们只是为了验证是否存在相应的key时可以使用下划线来忽略key对应的数据1_, ok := m[&quot;route&quot;] 为了遍历map，我们可以使用range关键字123for key, value := range m &#123; fmt.Println(&quot;Key:&quot;, key, &quot;Value:&quot;, value)&#125; 若是不使用make,我们也可以使用map的字面量来初始化一个map1234commits := map[string]int &#123; &quot;rsc&quot;: 3711, &quot;r&quot;, 2138,&#125; 我们还可以初始化一个空map，和使用make是一样的1var m = map[string]int&#123;&#125; 对默认值的利用当我们读取的key不存在时返回默认值有的是很方便的。 比如，一个值为bool类型的map就可以看做是一个set类型的数据结构（要知道，布尔类型的默认值是false）。这个例子遍历一个linked list of nodes, 并且打印他们的值。他使用值类型是Node 指针的map来检测list是否有环。123456789101112131415type Node struct &#123; Next *Node Value interface&#123;&#125;&#125;var first *Nodevisited := make(map[*Node]bool)for n := first; n != nil; n = n.Next &#123; if visited[n] &#123; fmt.Println(&quot;cycle detected&quot;) break &#125; visited[n] = true fmt.Println(n.Value)&#125; 若Node n已经被访问过了，则visited[n]的值是true, 若值是false则说明Node n没有被访问过。我们不需要再用其他数据来判断node在map中的存在性，map默认值已经帮我们处理了。 另一个有用的例子是slices的map, 我们知道当我们想一个nil slice append数据的时候是会分配新的内存的。因此当我们向slice的map中append 数据的时候，是不需要检查key是否存在的。可以看看下面的例子12345678910111213type Person struct &#123; Name string Likes []string&#125;var people []*Personlikes := make(map[string][]*Person)for _, p := range people &#123; for _, l := range p.Likes &#123; likes[l] = append(likes[l], p) &#125;&#125; 我们开一个打印出喜欢cheese的人：123for _, p := range likes[&quot;cheese&quot;] &#123; fmt.Println(p.Name, &quot;likes cheese.&quot;)&#125; 打印出有多少人喜欢bacon1fmt.Println(len(likes[&quot;bacon&quot;]), &quot; people like bacon.&quot;) range 和 len都把nil slice当做长度是0的slice, 因此我们最后两个数据是不会出错的。 key的类型前面提到过了，就是map的keys必须是可比较的。语言规范已经详细定义了可比较。 总的来说可比较的类型就是boolean, numeric, string, pointer, channel 以及接口类型，还有只包含上述类型的结构体和数据。不在上述范围的类型有map, slice 和 functions; 这些类型是不能用==，也不能当做map的keys的。 很明显strings， ints, 以及一些其他的类型可以做key,但是结构体就有点而出乎意料了。让我们看这个1hits := make(map[string]map[string]int) 这是一个页面访问的次数的map，key对应二级url1n := hits[&quot;/doc/&quot;][&quot;au&quot;] 但我们这么访问是错的，因为map是需要实例化的，我们可以这么读，但是当我们添加的时就会有问题，我们需要去初始化内部的map。如下123456789func add(m map[string]map[string]int, path, country string) &#123; mm, ok := m[path] if !ok &#123; mm = make(map[string]int) m[path] = mm &#125; mm[country]++&#125;add(hits, &quot;/doc/&quot;, &quot;au&quot;) 但是我们可以采用另一种设计如下12345type Key struct &#123; Path, Country string&#125;hits := make(map[Key]int) 此时我们可以一步添加1hits[Key&#123;&quot;/&quot;, &quot;vn&quot;&#125;]++ 另外读取也是非常方便的1n := hits[Key&#123;&quot;/ref/spec/&quot;, &quot;ch&quot;&#125;] 并发Maps不是并发安全的：当我们同时读写时map的行为是未定义的。通常我们可以使用sync.RWMutex来保护map 看个例子1234var counter = struct &#123; sync.RWMutex m map[string]int&#125;&#123;m: make(map[string]int)&#125; 读取的时候就可以使用读锁1234couter.RLock()n := counter.m[&quot;some_key&quot;]counter.RUnlock()fmt.Println(&quot;some_key:&quot;, n) 写时用写锁123couter.Lock()counter.m[&quot;some_key&quot;]++counter.Unlock() sync.Mutex第一次被使用后，千万不可以复制，要传指针。因为sync.Mutex是结构体而非指针数据，接下来回来一篇文章分析一下的。 迭代顺序map的迭代顺序是不包证的 123456789101112import &quot;sort&quot;var m map[int]stringvar keys []intfor k := range m &#123; keys = append(keys, k)&#125;sort.Ints(keys)for _, k := range keys &#123; fmt.Println(&quot;Key:&quot;, k, &quot;value:&quot;, m[k])&#125; 注意点map element是不可以addressable的意味着, 其实是可以预料的，因为map会扩容，那么扩容后map元素是否还在原地址就不一定了，所以&amp;map[“x”]这个操作是不被允许的。 12345type data struct &#123; name string&#125;var a = map[string]data &#123;&quot;x&quot;: &#123;&quot;one&quot;&#125;&#125;m[&quot;x&quot;].name = &quot;two&quot; // error 错误的，除非他的类型是指针123456789type data struct &#123; name string&#125;func main() &#123; m := map[string]*data &#123;&quot;x&quot;:&#123;&quot;one&quot;&#125;&#125; m[&quot;x&quot;].name = &quot;two&quot; //ok fmt.Println(m[&quot;x&quot;]) //prints: &amp;&#123;two&#125;&#125; 但是要注意不要写入空的了指针，是会panic的12345678910package maintype data struct &#123; name string&#125;func main() &#123; m := map[string]*data &#123;&quot;x&quot;:&#123;&quot;one&quot;&#125;&#125; m[&quot;z&quot;].name = &quot;what?&quot; //???&#125; 很显然，指针的默认值是nil,当然无法访问nil的name了。 但是slice element就可以addressable123456789type data struct &#123; name string&#125;func main() &#123; s := []data &#123;&#123;&quot;one&quot;&#125;&#125; s[0].name = &quot;two&quot; //ok fmt.Println(s) //prints: [&#123;two&#125;]&#125;","categories":[],"tags":[{"name":"go map","slug":"go-map","permalink":"http://yoursite.com/tags/go-map/"}]},{"title":"css的一些基础知识","slug":"css的一些基础知识","date":"2018-05-06T16:00:00.000Z","updated":"2018-07-14T13:00:30.001Z","comments":true,"path":"2018/05/07/css的一些基础知识/","link":"","permalink":"http://yoursite.com/2018/05/07/css的一些基础知识/","excerpt":"","text":"随时会更新 生成 BFC 根元素 float 属性不为 none position 为 absolute 或 fixed display 为 inline-block, table-cell, table-caption, flex, inline-flex overflow 不为 visible 记忆规则： absolute, fixed, inline-block, overflow BFC 布局规则 非 BFC 盒子内的第一个元素的 margin-top 设置为正值是不会撑开父元素的，而是紧贴着把父元素的兄弟元素给撑开。 内部的 Box 会在垂直方向，一个接一个地放置。 Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 每个元素的左外边缘（margin-left)， 与包含块的左边（contain box left）相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的 BFC。 BFC 的区域不会与 float box 重叠。(不会被兄弟float元素覆盖) BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算 BFC 的高度时，浮动元素也参与计算 IFC 布局规则 框会从包含块的顶部开始，一个接一个地水平摆放。 摆放这些框的时候，它们在水平方向上的外边距、边框、内边距所占用的空间都会被考虑在内。在垂直方向上，这些框可能会以不同形式来对齐：它们可能会把底部或顶部对齐，也可能把其内部的文本基线对齐。能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。水平的 margin、padding、border 有效，垂直无效。不能指定宽高。 行框的宽度是由包含块和存在的浮动来决定。行框的高度由行高计算这一章所描述的规则来决定。 IFC 结论 一个 line box 总是足够高对于包含在它内的所有盒子。然后，它也许比包含在它内最高的盒子高。(比如，盒子对齐导致基线提高了)。 当盒子 B 的高度比包含它的 line box 的高度低，在 line box 内的 B 的垂值对齐线通过’vertical align’属性决定。当几个行内级盒子在一个单独的 line box 内不能很好的水平放置，则他们被分配成了 2 个或者更多的垂直重叠的 line boxs.因此,一个段落是很多个 line boxs 的垂直叠加。Line boxs 被叠加没有垂直方向上的分离(特殊情况除外)，并且他们也不重叠。 通常，line box 的左边缘挨着它的包含块的左边缘，右边缘挨着它的包含块的右边缘。然而，浮动盒子也许会在包含块边缘和 line box 边缘之间。因此，尽管 line boxs 在同样的行内格式上下文中通常都有相同的宽度(就是他的包含块的宽度)，但是水平方向上的空间因为浮动被减少了，它的宽度也会变得复杂。Line boxs 在同样的行内格式上下文中通常在高度上是多样的(比如，一行也许包含了一个最高的图片然后其他的也可以仅仅只包含文字) 当在一行中行内级盒子的总宽度比包含他们的 line box 的宽度小，他们的在 line box 中的水平放置位置由’text align’属性决定。如果属性是’justify’，用户代理可能会拉伸空间和文字在 inline boxs 内。 当一个行内盒子超过了 line box 的宽度，则它被分割成几个盒子并且这些盒子被分配成几个横穿过的 line boxs。如果一个行内盒子不能被分割。则行内盒子溢出 line box。 当一个行内盒子被分割，分割发生则 margins,borders,和 padding 便没有了视觉效果。 在同样的 line box 内的行内盒子也许会被分割成几个盒子因为双向的文字。Line boxs 在行内格式上下文中档需要包含行内级内容时被创造。Line boxs 包含没有文字，没有空格，没有带着 margins,padding 和 borders，以及没有其他在流中的内容(比如图片，行内盒子和行内表格)，也不会以新起一行结尾。对于在他们内的任何盒子的位置都以他们决定并且必须将他们视作没有高度的 line boxs。 IFC 的 css font-size line-height height vertical-aligin block ele 块级元素 a block-level box is also a block container box. A block container box either contains only block-level boxes or establishes an inline formatting context and thus contains only inline-level boxes. Not all block container boxes are block-level boxes: non-replaced inline blocks and non-replaced table cells are block containers but not block-level boxes. Block-level boxes that are also block containers are called block boxes.解释一下 块级盒子也是一个块级包含块盒子， 他要么只包含块级盒子要么建立一个 IFC 并且只包含行级盒子。并不是所有的块级包含快盒子都是块级盒子，也有不可替换的 inline-block 或者其他的。 解释 1 只包含块级元素或者是创建一个 IFC 只包含块级元素,就是说若是一个块级盒子里面包含了一个块级元素，那么它里面就只有块级元素！你在骗我吧，你看我是可以这么写的？12345&lt;div&gt; &lt;p&gt;I love you&lt;/p&gt; &lt;span&gt;真逗我不love你&lt;/span&gt; 那我来爱你吧&lt;div&gt; 问：你看我这个 div 里不止有 p,还有 span 还有 text,你咋说？答：没错但是你看规范 9.2.1.1 Anonymous block boxes就是说像你这种情况他是会生成一个匿名块级盒子的，那么你的代码就是这样的了 12345 &lt;div&gt; &lt;p&gt;I love you&lt;/p&gt; &lt;anonymous-block-boxes&gt;&lt;span&gt;真逗我不love你&lt;/span&gt; 那我来爱你吧&lt;/anonymous-block-boxes&gt;&lt;div&gt; 我觉得这也是合理的就像规范里说的，这种方式也易于实现，要不浏览器的实现不得费劲啊。这样规定就意味着，块级元素只包含块级元素或者是创建一个 IFCIFC 的栗子 1&lt;div&gt;i love you&lt;/div&gt; 但事实上，这里不止创建 IFC 还有一个这个 Anonymous inline boxes，因为 html 里所有的东西都是被盒子包裹的文本也不例外，你没写盒子，并不代表就没有，其实是有匿名盒子生成的。 tricks 两栏布局 分栏高度自动相等 使用 margin-bottom 负边距，padding-bottom 正边距, 原理是 padding-bottom 足够大让人误以为你的高度是在自动增加而实际是你增加的高度不能超过 padding-bottom 的值，否则就会看到白框了，margin-bottom 负边距是为了让后面的元素能够上移到 content 元素的后面，而不是被 padding 给撑开。 水平垂直居中的方式 层叠上下文 背景&lt;布局&lt;内容 层叠准则： 务必牢记的层叠准则下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面 2 个准则： 谁大谁上：当具有明显的层叠水平标示的时候，如识别的 z-indx 值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。 层叠上下文的特性层叠上下文元素有如下特性： 层叠上下文的层叠水平要比普通元素高（原因后面会说明）； 层叠上下文可以阻断元素的混合模式（见此文第二部分说明）； 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。 每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。 翻译成真实世界语言就是： 当官的比老百姓更有机会面见圣上； 领导下去考察，会被当地官员阻隔只看到繁荣看不到真实民情； 一个家里，爸爸可以当官，孩子也是可以同时当官的。但是，孩子这个官要受爸爸控制。 自己当官，兄弟不占光。有什么福利或者变故只会影响自己的孩子们。 每个当官的都有属于自己的小团体，当家眷管家发生摩擦磕碰的时候（包括和其他官员的家眷管家），都是要优先看当官的也就是主子的脸色。 层叠上下文的创建 根元素（很厉害的，本身是 BFC,还是具有层叠上下文） 定位元素对于包含有 position:relative/position:absolute 的定位元素，以及 FireFox/IE 浏览器（不包括 Chrome 等 webkit 内核浏览器）（目前，也就是 2016 年初是这样）下含有 position:fixed 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文。典型的栗子，猜猜谁上谁下 123456&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt; &lt;img src=&quot;mm1.jpg&quot; style=&quot;position:absolute; z-index:2;&quot;&gt; &lt;-- 横妹子 --&gt;&lt;/div&gt;&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt; &lt;img src=&quot;mm2.jpg&quot; style=&quot;position:relative; z-index:1;&quot;&gt; &lt;-- 竖妹子 --&gt;&lt;/div&gt; 还有这个 123456&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt; &lt;img src=&quot;mm1.jpg&quot; style=&quot;position:absolute; z-index:2;&quot;&gt; &lt;-- 横妹子 --&gt;&lt;/div&gt;&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt; &lt;img src=&quot;mm2.jpg&quot; style=&quot;position:relative; z-index:1;&quot;&gt; &lt;-- 竖妹子 --&gt;&lt;/div&gt; CSS3 与新时代的层叠上下文 z-index 值不为 auto 的 flex 项(父元素 display:flex|inline-flex).注意，这里的规则有些负责复杂。要满足两个条件才能形成层叠上下文：条件 1 是父级需要是 display:flex 或者 display:inline-flex 水平，条件 2 是子元素的 z-index 不是 auto，必须是数值。此时，这个子元素为层叠上下文元素，没错，注意了，是子元素，不是 flex 父级元素。 元素的 opacity 值不是 1. 元素的 transform 值不是 none. 元素 mix-blend-mode 值不是 normal. 元素的 filter 值不是 none. 元素的 isolation 值是 isolate. will-change 指定的属性值为上面任意一个。 元素的-webkit-overflow-scrolling 设为 touch. 再具体的请参见原文 同时设置 margin-left 和 margin-right 参见更正： 第二种情况中若是没有设置宽度也是和第一种情况一样，设置负值会增加相应方向的宽度。 内容的包裹性，如何让你的盒子的宽度自适应内容呢？ 行内元素肯定是可以的可是我们没办法控制行内元素的高度等属性 float, inline-block，其实还有 position:absolute但是这真的可以么？也不是参见为什么还那么宽呢？因为我们里面放了两个 inline 元素，而第二个太长有放不下，于是挪到下一行了，但他占的位置依然在。so… float 的一些规则另一个还有鑫空间的不贴了，一搜就有 宽度计算法则position：absolute 的定位参考是包含块，若是没有定位为非 static 的父元素，则是依据的是 viewport 定位（是根元素的包含块）。基本上来说，reflow 有如下的几个原因： Initial。网页初始化的时候。 Incremental。一些 Javascript 在操作 DOM Tree 时。 Resize。其些元件的尺寸变了。 StyleChange。如果 CSS 的属性发生变化了。 Dirty。几个 Incremental 的 reflow 发生在同一个 frame 的子树上。我们来看一个示例： 1234567891011var bstyle = document.body.style; // cachebstyle.padding = &quot;20px&quot;; // reflow, repaintbstyle.border = &quot;10px solid red&quot;; // 再一次的 reflow 和 repaintbstyle.color = &quot;blue&quot;; // repaintbstyle.backgroundColor = &quot;#fad&quot;; // repaintbstyle.fontSize = &quot;2em&quot;; // reflow, repaint// new DOM element - reflow, repaintdocument.body.appendChild(document.createTextNode(&apos;dude!&apos;)); 当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就 reflow 或 repaint 一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是有些情况浏览器是不会这么做的，比如：resize 窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行 reflow。 但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些 DOM 值： offsetTop(定位距离+margin-top), offsetLeft, offsetWidth(dom 对象的可见宽度包括滚动条等), offsetHeight scrollTop(顶部已经滚动的距离)/Left/Width(元素完整的高度和宽度包括 overflow: hidden 的部分)/Height clientTop(就是 border-top)/Left/Width(dom 内容的宽度)/Height IE 中的 getComputedStyle(), 或 currentStyle 因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会 flush 出去一些样式的改变，从而造成频繁的 reflow/repaint。 各种 top,height(http://www.cnblogs.com/gagarinwjj/p/conflict_client_offset_scroll.html， https://github.com/pramper/Blog/issues/10) offet 的 top, left 就是距离定位系统的父元素的距离(比如是相对父元素的定位那么算出来的就是距离父元素的距离) event 对象中有offsetX/Y, clientX/Y, pageX/Y, screenX/Y 等。 screenX:鼠标位置相对于用户屏幕水平偏移量，而 screenY 也就是垂直方向的，此时的参照点也就是原点是屏幕的左上角。 clientX:跟 screenX 相比就是将参照点改成了浏览器内容区域的左上角，该参照点会随之滚动条的移动而移动。 pageX：参照点也是浏览器内容区域的左上角，但它不会随着滚动条而变动 flex 布局（https://zhuanlan.zhihu.com/p/25303493） 当设置了 display: flex 时， 子元素的 float、clear、vertical-align 都会失效 并且当设置了 flex-basis 时 width 设置就不起作用了 getComputedStyle 可以获取伪类元素的样式可以通过 parentNode 来获取 node 的 parent 元素offsetParent (https://www.cnblogs.com/xiaohuochai/p/5828369.html) 是指元素的定位父元素（只有有 position 不为 static 才能成为 offsetParent 元素， 若是没有 position 定位的父级元素那么 offsetParent 就是 body, 而 fixed 元素的 offsetParent 是 null）offsetParent 是用来计算 offsetTop 等值 的。他和 parentNode 是不同的，parentNode 父亲节点 HTML 结构层级关系中的上一级元素。因为所有的元素最后计算偏移都是和 body 元素的偏移。 .offsetTop/offsetLeft:当前元素距离父级参照物上/左边距偏移量, 我们要注意 offsetTop 可不是 scrollTop, 一个偏移距离，一个是滚动距离-&gt;offset():等同于 jQuery 中的 offset 方法，实现获取页面中任意一个元素距离 body 的偏移（包含左偏移和上偏移），不管当前元素的父级参照物是谁。-&gt;获取的结果是一个对象{left:距离 body 的左偏移量，top:距离 body 上偏移}-&gt;在标准的 ie8 浏览器中，我们使用 offsetLeft/offsetTop 其实是把父级参照物的边框也计算在内了 1234567891011121314151617181920212223function offset(curEle)&#123;var totalLeft = null,totalTop = null,par = curEle.offsetParent;//首先把自己本身的进行累加totalLeft += curEle.offsetLeft;totalTop += curEle.offsetTop; //只要没有找到body，我们就把父级参照物的边框和偏移量累加 while(par)&#123; if(navigator.userAgent.indexOf(&quot;MSIE 8.0&quot;) === -1)&#123; //不是标准的ie8浏览器，才进行边框累加 //累加父级参照物边框 totalLeft += par.clientLeft; totalTop += par.clientTop; &#125; //累加父级参照物本身的偏移 totalLeft += par.offsetLeft; totalTop += par.offsetTop; par = par.offsetParent; &#125; return &#123;left:totalLeft,top:totalTop&#125;;&#125;console.log(offset(box).top); getBoundingClientRectDOMRect 对象包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口(viewPort)的左上角位置而言的。 getClientRects, 对于 块级元素 来说，这两个其实没有什么区别的，关键是对于 内联元素 这两个有明显的区别。简单的说就是 内联元素 不在一行的时候每行都会产生一个矩形范围，而 getBoundingClientRect 并不会。getClientRects 返回的是数组，对于行内元素及其有用，尤其是当行内元素不在一行的时候 宽度计算 transform-origin 以及 transform： scale 的妙用transform-orgin 默认是 50%， 50% 中间向两端延伸动画 1234567891011121314151617181920212223242526272829303132333435363738394041div &#123; position: absolute; width: 200px; height: 60px;&#125;div::before &#123; content: &quot;&quot;; position: absolute; left: 0; bottom: 0; width: 200px; height: 2px; background: deeppink; transition: transform .5s; transform: scaleX(0);&#125;div:hover::before &#123; transform: scaleX(1);&#125; 从左侧出来再右侧消失的动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445div &#123; position: absolute; width: 200px; height: 60px;&#125;div::before &#123; content: &quot;&quot;; position: absolute; left: 0; bottom: 0; width: 200px; height: 2px; background: deeppink; transition: transform .5s; transform: scaleX(0); transform-origin: 100% 0;&#125;div:hover::before &#123; transform: scaleX(1); transform-origin: 0 0;&#125; 结合 transform-orgin 和 scale 可以做出很多初始位置与结束位置不同的动画demo 使用 css 接收页面点击事件 :target 是 CSS3 新增的一个伪类，可用于选取当前活动的目标元素。当然 URL 末尾带有锚名称 #，就可以指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)。它需要一个 id 去匹配文档中的 target 。 123456&lt;ul class=&apos;nav&apos;&gt; &lt;li&gt;&lt;a href=&quot;#content1&quot;&gt;列表1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#content2&quot;&gt;列表2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div id=&quot;content1&quot;&gt;列表1内容:123456&lt;/div&gt;&lt;div id=&quot;content2&quot;&gt;列表2内容:abcdefgkijkl&lt;/div&gt; 的那我们点击 a 标签时，如下的类选择器就会被触发 1234#content1:target,#content2:target &#123; color: black;&#125; input[radio|checkbox] 点击可以触发 inpu:check 选择器， for 指定 input id 可以绑定 input,就是说点击 label 就相当于点击 input 123456789101112&lt;div class=&quot;container&quot;&gt; &lt;input class=&quot;nav1&quot; id=&quot;li1&quot; type=&quot;radio&quot; name=&quot;nav&quot;&gt; &lt;input class=&quot;nav2&quot; id=&quot;li2&quot; type=&quot;radio&quot; name=&quot;nav&quot;&gt; &lt;ul class=&apos;nav&apos;&gt; &lt;li class=&apos;active&apos;&gt;&lt;label for=&quot;li1&quot;&gt;列表1&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;label for=&quot;li2&quot;&gt;列表2&lt;/label&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;content1&quot;&gt;列表1内容:123456&lt;/div&gt; &lt;div class=&quot;content1&quot;&gt;列表2内容:abcdefgkijkl&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 多个元素的边界线问题，最后一个不要消失的边界线问题，《css 设计指南》看到过，有一种巧妙的方法。li+li{border-left: 1px solid #000;} // 单行 li 字体定义顺序是一门学问，通常而言，我们定义字体的时候，会定义多个字体或字体系列。举个栗子：body {font-family: tahoma, arial, ‘Hiragino Sans GB’, ‘\\5b8b\\4f53’, sans-serif;}别看短短 5 个字体名，其实其中门道很深。解释一下： 使用 tahoma 作为首选的西文字体，小字号下结构清晰端整、阅读辨识容易； 用户电脑未预装 tohoma，则选择 arial 作为替代的西文字体，覆盖 windows 和 MAC OS； Hiragino Sans GB 为冬青黑体，首选的中文字体，保证了 MAC 用户的观看体验； Windows 下没有预装冬青黑体，则使用 ‘\\5b8b\\4f53’ 宋体为替代的中文字体方案，小字号下有着不错的效果； 最后使用无衬线系列字体 sans-serif 结尾，保证旧版本操作系统用户能选中一款电脑预装的无衬线字体，向下兼容。嗯，其实上面的 font-family 就是淘宝首页 body 的字体定义，非常的规范，每一个字体的定义都有它的意义。综上，总结一下，我觉得字体 font-family 定义的原则大概遵循： 1、兼顾中西中文或者西文（英文）都要考虑到。 2、西文在前，中文在后由于大部分中文字体也是带有英文部分的，但是英文部分又不怎么好看，同理英文字体中大多不包含中文。 所以通常会先进行英文字体的声明，选择最优的英文字体，这样不会影响到中文字体的选择，中文字体声明则紧随其次。 3、兼顾多操作系统选择字体的时候要考虑多操作系统。例如 MAC OS 下的很多中文字体在 Windows 都没有预装，为了保证 MAC 用户的体验，在定义中文字体的时候，先定义 MAC 用户的中文字体，再定义 Windows 用户的中文字体； 4、兼顾旧操作系统，以字体族系列 serif 和 sans-serif 结尾当使用一些非常新的字体时，要考虑向下兼容，兼顾到一些极旧的操作系统，使用字体族系列 serif 和 sans-serif 结尾总归是不错的选择。 hover 的使用hover 当 button 被点击时的状态变化 初始 -&gt; hover(直到鼠标离开都是 hover) -&gt; focus(点击后获取焦点，再点击其他或者 tab 键时会失去 focus) -&gt; active(点击松开后就失去了)， 因此 active 应当放到最后，否则会被作用时长比他长的样式覆盖，比如 hover 的样式css loader 简单实现，border-radius, boder-top-color: 透明123456789101112.loader &#123; display: none; width: 50px; height: 50px; border: 4px solid #fff; border-top-color: transparent; border-radius: 50%; margin: 0 auto; animation: spin 400ms linear infinite;&#125; 居中的方式http://www.html-js.com/article/4613 图片预览的方式基本原则就是造一个img标签 domReady两栏布局1234567891011121314.wrapper &#123; display: flex; justify-content: space-between;&#125;.left &#123; background: blue; width: 200px; height: 400px;&#125;.right &#123; width: calc(100% - 200px); height: 400px; background: green;&#125; 123456789101112.left &#123; background: blue; float: left; width: 200px; height: 400px;&#125;.right &#123; width: calc(100% - 200px); height: 400px; background: green; display: inline-block;&#125; CSS深入理解流体特性和BFC特性下多栏自适应布局waterfall 布局 我先入为主以为waterfall 布局就是得横向一个一个布局的，但是若是所有的宽度一致的话，我们可以认为是按照列布局的啊！！！12345678910111213141516171819202122232425262728&lt;div class=&quot;1&quot;&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;2&quot;&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;3&quot;&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;4&quot;&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt; &lt;div class=&quot;ele&quot;&gt; &lt;/div&gt;&lt;/div&gt; 如上我们就把一个一个的横向布局计算absolute位置，变为了，多列等宽布局（只需检测是否要改变列数）每列内部以此顺序布局即可。 参见 流体特性块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；如果有margin-left/margin-right, padding-left/padding-right, border-left-width/border-right-width等，实际内容区域会响应变窄。对于浏览器的元素布局来说最基础的就是一个一个的横向排列，放不下了就另换一行继续进行。 包含块 （http://w3help.org/zh-cn/kb/008/）Notably, a containing block is not a box (it is a rectangle), however it is often derived from the dimensions of a box 值得注意的是，一个包含块不是一个盒子（它是一个矩形），然而它通常是从盒子的尺寸派生的 containing block chainA sequence of successive containing blocks that form an ancestor-descendant chain through the containing block relation. For example, an inline box’s containing block is the content box of its closest block container ancestor; if that block container is an in-flow block, then its containing block is formed by its parent block container; if that grandparent block container is absolutely positioned, then its containing block is the padding edges of its closest positioned ancestor (not necessarily its parent), and so on up to the initial containing block. position: static/relative 找的是最近的block containers, block container 是包含IFC或者是BFC的 CSS3 transform使position:fixed元素absolute化实例页面http://www.zhangxinxu.com/study/201505/css3-transform-position-fixed-to-absolute.html 宽度计算的另一种和containing block有关‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ = width of containing block 其中margin-left/width/margin-right可为auto，且具有以下规则： 若width为auto，则其他设置为auto的属性的实际值为0，并让width的实际值满足等式； 若width为数值，而margin-left/right均为auto，且除marin-left/right外其他属性值总和小于containing block的宽度，那么margin-left == margin-right == (‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ + ‘border-right-width’)/2；否则margin-left == margin-right == 0. 尺寸相对定位元素的尺寸，会保持它在常规流中的尺寸。包括换行以及原来为它保留的位置。 定位及计算偏移后的值 ‘left’ 和 ‘right’ 的特性值 对于一个相对定位的元素，’left’ 和 ‘right’ 会水平的位移框而不会改变它的大小。’left’ 会将框向右移动，’right’ 会将框向左移动。 由于 ‘left’ 或者 ‘right’ 不会造成框被拆分或者拉伸，所以，计算后的值( computed value )总是：left = -right。 ‘left’ 和 ‘right’ 的设定值都是 “auto” 如果 ‘left’ 和 ‘right’ 的值都是 “auto” （它们的初始值），计算后的值( computed value )为 0（例如，框区留在其原来的位置）。 ‘left’ 或 ‘right’ 其一的设定值为 “auto” 如果 left 为 ‘auto’，计算后的值(computed value)为 right 的负值（例如，框区根据 right 值向左移）。 如果 right 被指定为 ‘auto’，其计算后的值(computed value)为 left 值的负值。 示例代码：1&lt;div style=&quot;width:20px; height:20px; background-color:red; position:relative; left:100px;&quot;&gt;&lt;/div&gt; 上述代码中，DIV 元素是相对定位的元素，它的 ‘left’ 值是 “100px”， ‘right’ 没有设置，默认为 “auto”，那么，’right’ 特性计算后的值应该是 -left，即 “right:-100px”。 ‘left’ 和 ‘right’ 设定值都不是 “auto” 如果 ‘left’ 和 ‘right’ 都不是 “auto”，那么定位就显得很牵强，其中一个不得不被舍弃。如果包含块的 ‘direction’ 属性是 “ltr”， 那么 ‘left’ 将获胜，’right’ 值变成 -left。如果包含块的 ‘direction’ 属性是 ‘rtl’，那么 ‘right’ 获胜，’left’ 值将被忽略。 示例代码：123&lt;div style=&quot;width:100px; height:100px; overflow:auto; border:1px solid blue;&quot;&gt; &lt;div style=&quot;width:20px; height:20px; background-color:red; position:relative; left:60px; right:60px;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 最后，’left’ 应该比较强悍才对。 floathttp://efe.baidu.com/blog/float/ float时 position是fixed和absolute则浮动相对于失效 其他float有效，position失效 浮动元素的特点 元素被视作块级元素，相当于display设置为“block”； 元素具备包裹性，会根据它所包含的元素实现宽度、高度自适应； 浮动元素前后的 ###块级兄弟元素### 忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素； 浮动元素前后的行内元素环绕浮动元素排列； 浮动元素之前的元素如果也是浮动元素，且方向相同，它会紧跟在它们后面；父元素宽度不够，换行展示； 浮动元素之间的水平间距不会重叠； 当包含元素中只有浮动元素时，包含元素将会高度塌陷； 浮动元素的父元素的非浮动兄弟元素，忽视浮动元素存在，覆盖浮动元素； 浮动元素的父元素的浮动兄弟元素，会跟随浮动元素布局，仿佛处在同一父元素中。 浮动对兄弟元素的影响 Since a float is not in the flow, non-positioned block boxes created before and after the float box flow vertically as if the float did not exist. However, the current and subsequent line boxes created next to the float are shortened as necessary to make room for the margin box of the float. 块级非定位元素自动排列就好像没有浮动元素似的，行内元素则需要为浮动元素腾出位置(对于层级上下文来说，浮动元素高于块级盒子) 浮动元素之间不重叠；尽可能像边缘漂浮，但不越界。 那么第八条、第九条为什么？看CSS标准中的下面的描述： References to other elements in these rules refer only to other elements in the same block formatting context as the float. 也就是说，float对同一个BFC内的元素有效。如果父元素没有触发生成新的BFC，那么父元素的兄弟元素都算是跟父元素中的元素处于同一BFC，也就会受浮动的影响，并且行为规则与同处于同一个父元素之中的元素的规则相同：块级元素重叠(和float元素重叠)；行内元素环绕；浮动元素跟随。12345678910111213141516171819202122232425262728&lt;div id=&quot;a&quot;&gt; &lt;div id=&quot;b&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;c&quot;&gt;&lt;/div&gt;#a &#123; width: 300px; background: blue;&#125;#b &#123; width: 200px; height: 10px; background: red; float: left;&#125;#c &#123; width: 200px; height: 100px; background: green;&#125; 正是因为浮动元素的这三条特点，因此，在使用了浮动元素以后，通常都要做“清除浮动“或”闭合浮动“的操作，来避免浮动元素对其他元素的影响 flexboxflex: flex-grow(相对于其他元素的增长比例) flex-shrink(相对于其他元素的缩小比例) flex-baisis(基础大小) flexbox 无法使用float 其他定位元素照用 overflow 可以使用 flex-container 回创建一个containing-block vertical-align无法使用在flex-item block containerExcept for table boxes, which are described in a later chapter, and replaced elements, a block-level box is also a block container box. A block container box either contains only block-level boxes or establishes an inline formatting context and thus contains only inline-level boxes. Not all block container boxes are block-level boxes: non-replaced inline blocks and non-replaced table cells are block containers but not block-level boxes. Block-level boxes that are also block containers are called block boxes. 块级盒子都是block container, 但block container不都是块级盒子，还有非替换行内块级盒子等 indeterminate 属性 只能通过js操作，半赋值https://imququ.com/post/native-tri-state-checkbox.html svg 多色图标 https://css-tricks.com/icon-fonts-vs-svg/css hack各个浏览器的方法对内 css apicss in jsprops(react 社区的 style components): local namespace &amp; scoped Smarter critical css extraction // 更精细的加载 css Dynamic styles Shared style values Manageable API(对外提供了可控的 api) cons: runtime 级别的无法使用现有的静态 css 处理器 重新开发工具链 对外的 api，扩展某一个组件 css in js: 预定义样式（className）, 以 enum 方式开放， 就可以修改这些 className 的样式 css out of js: 让使用者写 css 样式，这样就无法修改 htmL 结构 全局 样式样式代码尽可能少的 hard code互操作的 apiweb 本身是开放的BEM &amp; atomiccss hover 子元素时 父元素也处于 hover 状态典型的就是菜单，当我们 hover 父元素显示出菜单然后挪到子元素时子元素依然在（采用父元素 hover 子元素 来显示）反例是当你把菜单子元素挪出去放到作为父元素的兄弟元素然后继续使用 hover 显示，你在去挪动就会发现兄弟元素不会再显示了。()[https://codepen.io/dengshen/pen/erGyaP] mouseout/mouseleavemouseout 当从父元素移到子元素时即使没有出父元素也会触发 mouseoutmousleave 即使从父元素移到子元素时 在子元素上移动也不会触发 mouseleave 视差滚动 background-attachment: fixed 滚动背景固定不跟随滚动，改变 background-position 来滚动 onscroll: 改变各个元素的 style.top 来滚动（同上 chrome 会有跳动，因为 chrome 对滚动做了优化，很多次滚动才触发一次 scroll 事件, 相当于多帧时间只有一帧动画） mousewheel： 同上 滚动性能优化(https://www.cnblogs.com/coco1s/p/5499469.html)img 标签多三像素的问题（https://github.com/muwenzi/Program-Blog/issues/121）原因是因为 img 标签是 inline 元素对齐方式是 base-line 和文字的对齐方式一致， 因此设置 font-size: 0 getBoundingClientRect() 来获取页面元素的位置（https://juejin.im/entry/59c1fd23f265da06594316a9）使用 获取元素在视窗的位置 1234let box = document.getElementId(&apos;box&apos;)const rect = box.getBoundingClientRect()rect.left 就是元素左边距距离视窗的距离rect.top 就是元素上边距距离视窗的距离 获取元素在页面的位置 1234let box = document.getElementId(&apos;box&apos;)const rect = box.getBoundingClientRect()rect.left + document.documentElement.scrollLeftrect.top + document.docuemntElement.scrollTop 判断元素是否在可见区域 123456789function isElementInViewport (el) &#123; var rect = el.getBoundingClientRect(); return ( rect.top &gt;= 0 &amp;&amp; rect.left &gt;= 0 &amp;&amp; rect.bottom &lt;= (window.innerHeight || document.documentElement.clientHeight) &amp;&amp; /_or(window.height() _/ rect.right &lt;= (window.innerWidth || document.documentElement.clientWidth) /_or $(window.width() _/ );&#125; 获取元素的各种高度(https://blog.csdn.net/woxueliuyun/article/details/8638427) clientHeight大部分浏览器对 clientHeight 都没有什么异议，认为是元素可视区域的高度，也就是说元素或窗口中可以看到内容的这个区域的高度，即然是指可看到内容的区域，滚动条不算在内。但要注意 padding 是算在内。其计算方式为 clientHeight = topPadding + bottomPadding+ height - 水平滚动条高度。 offsetHeight在 IE6，IE7，IE8， IE9 以及最新的的 FF, Chrome 中，对于一般元素，都是 offsetHeight = padding + height + border = clientHeight + 滚动条 + 边框 scrollHeightscrollHeight 的争议比较大，有些浏览器认为 scrollHeight 可以小于 clientHeight，有些认为 scrollHeight 至少应该等于 clientHeight。但有一点是一样的，就是 scrollHeight &gt;= topPadding + bottomPadding + 内容 margin box 的高度。 在浏览器中的区别在于：IE6、IE7 认为 scrollHeight 是内容高度，可以小于 clientHeight。 FF 认为 scrollHeight 是内容高度，不过最小值是 clientHeight。 注： 以上都是对于一般元素而方言的，body 和 documentElement 的 clientHeight, offsetHeight 和 scrollHeight 在各个浏览器中的计算方式又不同。 在所有的浏览器中，如果你想获取视窗可见部分的高度，应该使用 documentElement.clientHeight，因为 body.clientHeight 是由它的内容决定的。 viewport 通常被称作视口（视窗 ），是指设备的屏幕上能用来显示网页的那一块区域如何获取设备像素（屏幕尺寸）？通常我们可以从 BOM(Browser Object Model) 中通过 screen.width/screen.height 获取。 如何获取窗口尺寸？如果你想知道用户访问的页面中有多少空间可以用来 CSS 布局，那么你需要获取浏览器窗口的内部尺寸。可以通过 window.innerWidth/window.innerHeight 来获取这些尺寸。注意度量的宽度和高度是包括滚动条的。它们也被视为内部窗口的一部分。（这大部分是因为历史原因造成的。） 如何获取 HTML 文档的尺寸？可见宽度：document.documentElement.clientWidth 实际宽度：document.documentElement.offsetWidth 实际上，document.documentElement 指的是 &lt;html&gt; 元素：即任何 HTML 文档的根元素。 layout viewport 和 visual viewport当我们比较移动浏览器和桌面浏览器的时候，它们最显而易见的不同就是屏幕尺寸。当我们打开一个未针对移动端做任何 CSS 适配的页面时，我们会不由的慨叹：viewport 太窄了！viewport 并不能按照写给桌面浏览器的 CSS 正确布局。明显的解决方案是使 viewport 变宽一些。聪明的人们想到了一个解决办法：把 viewport 分成两部分：visual viewport 和 layout viewport。 两个 viewport 都是以 CSS 像素度量的。但是当进行缩放（如果你放大，屏幕上的 CSS 像素会变少）的时候，visual viewport 的尺寸会发生变化，layout viewport 的尺寸仍然跟之前的一样。 George Cummins 在 Stack Overflow 上对基本概念给出了最佳解释： 把 layout viewport 想像成为一张不会变更大小或者形状的大图。现在想像你有一个小一些的框架，你通过它来看这张大图。（译者：可以理解为「管中窥豹」）这个小框架的周围被不透明的材料所环绕，这掩盖了你所有的视线，只留这张大图的一部分给你。你通过这个框架所能看到的大图的部分就是 visual viewport。当你保持框架（缩小）来看整个图片的时候，你可以不用管大图，或者你可以靠近一些（放大）只看局部。你也可以改变框架的方向，但是大图（layout viewport）的大小和形状永远不会变。 我们工作中所谓的 CSS 布局，尤其是百分比宽度，是以 layout viewport 做为参照系来计算的，它被认为要比 visual viewport 宽。即：&lt;html&gt; 元素在初始情况下用的是 layout viewport 的宽度，这使得站点布局的行为与其在桌面浏览器上的一样。 layout viewport 有多宽？每个浏览器都不一样。Safari iPhone 为 980px，Opera 为 850px，Android WebKit 800px，最后 IE 为 974px。 如何获取两个 viewport 的宽度？如果理解了上面讲述的内容，不难理解下面获取 viewport 的方式： layout viewport: document.documentElement.clientWidth/document.documentElement.clientHeight visual viewport: window.innerWidth/window.innerHeight canvas 适配retina","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"关于react","slug":"关于react","date":"2018-05-03T16:00:00.000Z","updated":"2018-07-14T13:00:30.100Z","comments":true,"path":"2018/05/04/关于react/","link":"","permalink":"http://yoursite.com/2018/05/04/关于react/","excerpt":"","text":"什么 jsxFundamentally, JSX just provides syntactic sugar for the React.createElement(component, props, …children) function. The JSX code: react element vs componentelement Simply put, a React element describes what you want to see on the screen. Not so simply put, a React element is an object representation of a DOM node.’ react element 简单说就是描述了你在屏幕上所看到的，复杂点说就是一个 DOM node 的 js object 表现代理 In order to create our object representation of a DOM node (aka React element), we can use React’s createElement method. 为了创建一个 DOM node 的 js object 表现代理，我们需要使用 react 的 createElement 方法12345const element = React.createElement( &apos;div&apos;, &#123;id: &apos;login-btn&apos;&#125;, &apos;Login&apos;) 而我们所看到的所有如图片里的写法都是 jsx, 当他们被 babel 转义后就是这个1React.createElement(Icon, null) So finally, what do we call it when we write out our component like this, ? We can call it “creating an element” because after the JSX is transpiled, that’s exactly what’s happening.也就是我们在 jsx 文件里的所有的类似的写法都是在写 createElement()方法（jsx 会被 babel 转义） 如下1234567891011121314function Button (&#123; addFriend &#125;) &#123; return ( &lt;button onClick=&#123;addFriend&#125;&gt;Add Friend&lt;/button&gt; )&#125;function User (&#123; name, addFriend &#125;) &#123; return ( &lt;div&gt; &lt;p&gt;&#123;name&#125;&lt;/p&gt; &lt;Button addFriend=&#123;addFriend&#125;/&gt; &lt;/div&gt; )&#125; 会被转为1234567891011121314151617181920function Button (&#123; addFriend &#125;) &#123; return React.createElement( &quot;button&quot;, &#123; onClick: addFriend &#125;, &quot;Add Friend&quot; )&#125;function User(&#123; name, addFriend &#125;) &#123; return React.createElement( &quot;div&quot;, null, React.createElement( &quot;p&quot;, null, name ), React.createElement(Button, &#123; addFriend &#125;) )&#125; component “Components are the building blocks of React”. Notice, however, that we started this post with elements. The reason for this is because once you understand elements, understanding components is a smooth transition. A component is a function or a Class which optionally accepts input and returns a React element. 理解了上面的 react element 就知道 component 了，对上段英文翻译一下就是， component 是构建 react 应用的基础，理解了 element 就知道了，component 就是一个类或者是一个函数，他接收输入 并且返回一个 element 以供 react 使用 createElement(type, props, […children])type 是 tagName string, 或者 component(class, function) 又或者是 fragment 1createElement -&gt; 解析props, 生成key或者ref, -&gt;生成vnode http://blog.csdn.net/liangklfang/article/details/72782920getSnapshotBeforeUpdate（https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-b=】、【这个生命周期函数是在 render 之后 DOM 更新之前调用的 若是想要获取 DOM 更新之前的 DOM 数据可以在这个函数里获取 react 关于 props 和 state 的函数或属性123static defaultProps = &#123;&#125; // 默认属性getDefaultProps , 函数的形式获取默认属性getInitialState , 函数的形式获取初始state ts中的keyof 是展示一个对象中的 key12345678910111213keyof &#123;a: 3&#125; // atype Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P]; // P是T中的key, 且加了？ 就是可选的意思&#125;;type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P]; // -? 就是去掉 ？ 去掉可选性， 也可以使+？添加可选属性&#125;;type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P]; // 全部加上readonly属性&#125;;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"分布式基础","slug":"分布式基础","date":"2018-04-29T16:00:00.000Z","updated":"2018-07-14T13:00:30.101Z","comments":true,"path":"2018/04/30/分布式基础/","link":"","permalink":"http://yoursite.com/2018/04/30/分布式基础/","excerpt":"","text":"分布式的三个状态 成功 失败 超时(未响应) 当超时了可以发起读数据操作，验证是否成功，就好比银行转账，转失败了，他会让你去看看是否成功了，避免多次操作 操作幂等则可以发起重试操作 tcp 不可靠就是说网络不可靠 应用程序的消息发给 tcp 协议栈，宕机了，消息没法出去，可是对于应用程序来说它认为消息是发出去了的。 异常处理黄金原则: 任何在设计阶段考虑到的情况都会在实际系统中发生；在实际运行中发生的异常反而没有在设计阶段想到。因此不要放过，设计阶段想到的任何异常。副本副本(replica/copy)指在分布式系统中为数据或服务提供的冗余。 副本一致性系统通过副本控制协议，是得从系统外部读取内部各个副本的数据在一定条件下，读到的数据相同称之为副本一致性(consistency)。 强一致性(strong consistency) 无论怎么读都 ok 单调一致性(monotonic consistency)：任何时刻，任何用户一旦读到某个数据在某次更新后的数据，这个用户就不会再读到比这个值更旧的值。单调一致性弱于强一致性。确实非常实用的一种一致性。因为通常来说，用户只关心自己读到的数据，而不会关心其他人的情况。 会话一致性(session consistency)：任何用户在某一次会话内一旦读到某个数据某次更新后的值，在此次会话中就不会再读到比这个值更旧的值。这个一致性比单调一致性再稍弱一些。会话一致性只保护了单个用户在单次会话内的数据一致性，不同永不不同会话之间的一致性没有保障。例如 php 中的 session 概念。可以将数据版本号等信息保存在 session 中，读取数据时验证副本的版本号，只读取版本号大于等于 session 中版本号的副本，从而实现会话一致性 最终一致性(eventual consistency)：就是一旦更新了数据，各个副本最终将达到完全一致。若用户在一个副本上一直读取可以达到类似单调一致性的效果，但若是换个副本去读取就无法保证了。 弱一致性(week consistency)：一旦某个更新成功，用户无法在一个确定时间内读到这次更新的 值，且即使在某个副本上读到了新的值，也不能保证在其他副本上可以读到新的值。弱一致性系统 一般很难在实际中使用，使用弱一致性系统需要应用方做更多的工作从而使得系统可用。 衡量分布式系统的指标 性能 系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量; 系统的响应延迟，指系统完成某一功能需要使用的时间; 系统的并发能力，指系统可以同时完成某一功能的能力，通常 也用 QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往 很难做到低延迟;系统平均响应时间较长时，也很难提高 QPS 可用性 可扩展性 一致性 分布式系统原理数据分布方式 哈希方式 缺点：1.哈希分布数据的缺点同样明显，突出表现为可扩展性不高，一旦集群规模需要扩展，则几乎所 有的数据需要被迁移并重新分布，因为所有的数据都需要再次进行哈希，而哈希的结果则有可能就不同了。工程中，扩展哈希分布数据的系统时，往往使得集群规模成倍扩 展，按照数据重新计算哈希，这样原本一台机器上的数据只需迁移一半到另一台对应的机器上即可 完成扩展。2.哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”(data skew)问题。导致某些机器上的数据过多 按数据范围分布，比如用户 id[0-100],30 个一分区，工程中，为了数据迁移等负载均衡操作的方便， 往往利用动态划分区间的技术，使得每个区间中服务的数据量尽量的一样多。一般的，往往需要使用专门的服务器在内存中维护数据分布信息， 称这种数据的分布信息为一种元信息。实际工程中，一般也不按照某一维度划分数据范围，而是使用全部数据划分范围，从而避免数 据倾斜的问题。 按数据量分布，就是把固定大小的数据放在一起，好比 linux 中的 page，一个 page 一管理 一致性哈希，一致性哈希的基本方式是使用一个哈希函数计算数据或数据特征的哈希值，令该哈希函数的输出值域为一个封闭的环，即哈希 函数输出的最大值是最小值的前序。将节点随机分布到这个环上，每个节点负责处理从自己开始顺 时针至下一个节点的全部哈希值域上的数据。一致性哈希 的优点在于可以任意动态添加、删除节点，每次添加、删除一个节点仅影响一致性哈希环上相邻的 节点。 为此一种常见的改进算法是引入虚节点(virtual node)的概念，系统初始时就创建许多虚节点， 虚节点的个数一般远大于未来集群中机器的个数，将虚节点均匀分布到一致性哈希值域环上，其功能与基本一致性哈希算法中的节点相同。为每个节点分配若干虚节点。操作数据时，首先通过数据 的哈希值在环上找到对应的虚节点，进而查找元数据找到对应的真实节点。使用虚节点改进有多个 优点。首先，一旦某个节点不可用，该节点将使得多个虚节点不可用，从而使得多个相邻的真实节 点负载失效节点的压里。同理，一旦加入一个新节点，可以分配多个虚节点，从而使得新节点可以 负载多个原有节点的压力，从全局看，较容易实现扩容时的负载均衡。(原理是增加很多的虚拟节点，再将虚拟节点对应到真实节点参见) 副本与数据分布 以机器为单位进行数据冗余，就是有 a,b,c 三台机器，b,c 分别有 a 的全量数据，但是有缺点 1.宕机恢复，若 b 挂了，就得从 a，或 c 进行全量数据同步，效率低下。2.b 挂了以后，a，c 的负载就高了，b 的负载就全到了 a,c 上了 以数据块为单位进行数据冗余，将数据拆为较合理的数据段，以数据段为单位作为副本。实践中，常常使得每个数据段的大小尽量相等且控制在一定的大小以内。数据段有很多不同的称谓，segment，fragment，chunk，partition 等等。以数据段为单位的副本一旦副本分布与机器无关，数据丢失后的恢复效率将非常高，可以同时从多太物理机 copy 数据。工程中，完全按照数据段建立副本会引起需要管理的元数据的开销增大，副本维护的难度也相 应增大。一种折中的做法是将某些数据段组成一个数据段分组，按数据段分组为粒度进行副本管理。 这样做可以将副本粒度控制在一个较为合适的范围内。 本地化计算 移动数据不如移动计算基本副本协议 中心化副本协议 primary-secondary 协议 * Primary-secondary 协议的数据更新流程 1. 数据更新都由 primary 节点协调完成。 2. 外部节点将更新操作发给 primary 节点 3. primary 节点进行并发控制即确定并发更新操作的先后顺序 4. primary 节点将更新操作发送给 secondary 节点 5. primary 根据 secondary 节点的完成情况决定更新是否成功并将结果返回外部节点有些系统(例如，GFS)，使用接力的方式同步数据, primary 同步给 secondary1, secondary1 同步给 secondary2 去中心化副本控制协议,与中心化副本系统协议最大的不同是，去中心化副本控制协议没有中心节点，协议中所有的节点都是完全对等的，节点之间通过平等协商 达到一致 Lease 机制 (租赁机制)lease 机 制最重要的应用:判定节点状态。 基于 lease 的分布式 cache 系统基本的问题背景如下:在一个分布式系统中，有一个中心服务器节点，中心服务器存储、维护 着一些数据，这些数据是系统的元数据。系统中其他的节点通过访问中心服务器节点读取、修改其 上的元数据。由于系统中各种操作都依赖于元数据，如果每次读取元数据的操作都访问中心服务器 节点，那么中心服务器节点的性能成为系统的瓶颈。为此，设计一种元数据 cache，在各个节点上 cache 元数据信息，从而减少对中心服务器节点的访问，提高性能。另一方面，系统的正确运行严 格依赖于元数据的正确，这就要求各个节点上 cache 的数据始终与中心服务器上的数据一致，cache 中的数据不能是旧的脏数据。最后，设计的 cache 系统要能最大可能的处理节点宕机、网络中断等 异常，最大程度的提高系统的可用性。 lease cache 的实现原理 首先假设中心服务器与节点之间的时间同步。中心服务器向 cache 节点发送数据的同时下发一个 lease,每个 lease 都一个过期时间，并且这个过期时间是一个明确的时间点，例如 12：00 一旦过了这个时间，那么所有的缓存数据都将过期，lease 失效。这也意味着 lease 的过期时间与发放时间无关，也就是说有可能节点收到数据时 lease 就已经过期了。中心发出的 lease 的含义是：在 lease 时间内服务器保证不修改数据。 cache 节点收到 lease 以及数据后，把数据加入 cache，所有的在 lease 时间内的读请求都可以直接返回 当 lease 到期后，清掉本地缓存，并向中心服务器发出获取数据的请求，此时到 cache 节点的请求都会被阻塞，直到中心服务器返回新的数据以及 lease 当修改数据时，修改请求发到中心服务器，此时应当等到所有发出的 lease 都过期后，再修改中心服务器，并且再把数据发给 cache 节点。此时若是有 cache 的读请求，应当阻塞 读流程：判断元数据是否已经处于本地 cache 且 lease 处于有效期内1.1 是:直接返回 cache 中的元数据1.2 否:向中心服务器节点请求读取元数据信息1.2.1 服务器收到读取请求后，返回元数据及一个对应的 lease1.2.2 客户端是否成功收到服务器返回的数据1.2.2.1 失败或超时:退出流程，读取失败，可重试1.2.2.2 成功:将元数据与该元数据的 lease 记录到内存中，返回元数据 修改流程： 节点向中心服务器发起修改元数据请求。 服务器收到修改请求后，阻塞所有新的来自 cache 的读数据请求，即接收读请求，但不返回数据。 服务器等待所有与该元数据相关的 lease 超时。 服务器修改元数据并向客户端节点返回修改成功。优化 中心服务器收到修改请求时，会阻塞所有的新的来自 cache 节点。这么做是为了防止一直在发放 lease, 导致一直无法等到所有的 lease 过期。但是我们可以不阻塞，直接返回新的数据却不发放 lease。 中心服务器可以不等待，而是主动通知各个 cache 节点数据过期，让 lease 失效，若是所有节点均返回 true，则可以进行更新，若有一个返回 false 则不可以更新。经过这两个优化，则可以大大提高性能，cache 的数据可以随时丢弃，可是副本的数据却不可以丢弃。 lease 机制的分析首先给出本文对 lease 的定义:Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发 出 lease，则无论接受方是否收到，也无论后续接收方处于何种状态，只要 lease 不过期，颁发者一 定严守承诺;另一方面，接收方在 lease 的有效期内可以使用颁发者的承诺，但一旦 lease 过期，接 收方一定不能继续使用颁发者的承诺。 由于 lease 是一种承诺，具体的承诺内容可以非常宽泛，可以是上节的例子中数据的正确性;也 可以是某种权限，例如当需要做并发控制时，同一时刻只给某一个节点颁发 lease，只有持有 lease 的节点才可以修改数据;也可以是某种身份，例如在 primary-secondary(2.2.2 )架构中，给节点颁发 lease，只有持有 lease 的节点才具有 primary 身份。Lease 的承诺的内涵还可以非常宽泛，这里不再 一一列举。 关于时钟同步问题可以让 client 在申请 lease 时带上自己的时间戳，server 判断若是相差太大就不允许接入 基于 lease 机制确定节点状态分布式主要是 3 点 节点 – 系统中按照协议完成计算工作的一个逻辑实体，可能是执行某些工作的进程或机器 网络 – 系统的数据传输通道，用来彼此通信。通信是具有方向性的。 存储 – 系统中持久化数据的数据库或者文件存储。 心跳无法解决节点状态问题是指分布式系统的状态，点对点的还是可以使用的 lease 的有效期时间选择Lease 的有效期虽然是一个确定的时间点，当颁发者在发布 lease 时通常都是将当前时间加上一 个固定的时长从而计算出 lease 的有效期。如何选择 Lease 的时长在工程实践中是一个值得讨论的问 题。如果 lease 的时长太短，例如 1s，一旦出现网络抖动 lease 很容易丢失，从而造成节点失去 lease， 使得依赖 lease 的服务停止;如果 lease 的时长太大，例如 1 分钟，则一旦接受者异常，颁发者需要 过长的时间收回 lease 承诺。例如，使用 lease 确定节点状态时，若 lease 时间过短，有可能造成网络 瞬断时节点收不到 lease 从而引起服务不稳定，若 lease 时间过长，则一旦某节点宕机异常，需要较 大的时间等待 lease 过期才能发现节点异常。工程中，常选择的 lease 时长是 10 秒级别，这是一个经 过验证的经验值，实践中可以作为参考并综合选择合适的时长。 一致性种类于是就有人提出相对弱一点的一致性模型，这些模型包括：线性一致性，原子一致性，顺序一致性，缓存一致性，静态一致性，处理器一致性，PRAM一致性，释放一致性，因果一致性，TSO一致性，PSO一致性，弱序一致性，本地一致性，连续一致性等等，当然，也包括我们要详细介绍的最终一致性。 https://pure-earth-7284.herokuapp.com/2016/02/14/talk-about-consistency/","categories":[],"tags":[]},{"title":"quicksort","slug":"quicksort","date":"2018-04-29T16:00:00.000Z","updated":"2018-07-14T13:00:30.069Z","comments":true,"path":"2018/04/30/quicksort/","link":"","permalink":"http://yoursite.com/2018/04/30/quicksort/","excerpt":"","text":"快速排序时为什么一定要把pivot放到头或尾最后在放回去呢？因为我们在把头尾index往里缩时我们判断的是小于和不小于(大于同理)，比如我们把pivot 5 放在中间，当我们的头index判断不小于时，若是到了pivot条件也是成立的就跳到了pivot右侧，此时若是尾index也在右边发现了小于pivot的值在交换时就会出现，小于pivot的值出现在pivot的右侧，当然我们也可以做额外操作，判断若是头index到了pivot的位置时则不再继续12345678910111213141516171. | | V V4, 5, 8, 2 头 尾2. | | V V4, 5, 2, 8 头 尾3. 此时找到了大于以及小于的pivot的值交换4，5，2，8， 显然出问题了、、、、、、但是若是5在头部5，4，8，2， 交换就没事了，因为接下来会有把pivot和low或者high交换的过程 我们每进行一次交换就会找到一个元素的正确位置，此时接下来再排序时就不要再把他算进去了12,1,2,1,3,4,5 上述3已经在正确位置了，再接下来的排序应当是4,5和2，1，2，1两组进行排序而不是3，4，5和2，1，2，1或者4，5和2，1，2，1, 3进行排序, 因为3已经是在正确位置了，没必要再排一次。 我们可看看golang源码的排序 若是小于12个元素时它采用shell希尔排序 他会计算一个深度2 * lg(n+1), 然后采用快速排序，没进行一次就深度减一，当为0时就用堆排序,至于这个数字咋算出来的可以查查 解析：元素较少时，大家都差不多，反而是希尔排序这样的好一些，好在哪啊？我们都知道快排在元素基本有序时是最慢的最坏能达到o(n^2),所以当序列基本有序时我们可以采用堆排序 一个简单的快排版本12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot;) // threads 线程标识创建线程的个数func quicksort(nums []int, length int) &#123; if length &lt;= 1 &#123; return &#125; left := 1 right := length - 1 pivot := nums[0] for&#123; for; left &lt; right &amp;&amp; nums[right] &gt; pivot; right--&#123; &#125; for; left &lt; right &amp;&amp; nums[left] &lt;= pivot; left++ &#123; &#125; if left &gt;= right &#123; break &#125; nums[left], nums[right] = nums[right], nums[left] &#125; nums[0], nums[left] = nums[left], nums[0] quicksort(nums[0:left], left) //分任务 temp := nums[left + 1: length] quicksort(temp, len(temp)) return&#125;func main() &#123; x := []int&#123;3, 41, 24, 76, 11, 45, 3, 3, 64, 21, 69, 19, 36&#125; quicksort(x[:], len(x)) fmt.Println(x);&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"hyperledger-fabric基础","slug":"hyperledger-fabric基础","date":"2018-04-09T16:00:00.000Z","updated":"2018-07-14T13:00:30.039Z","comments":true,"path":"2018/04/10/hyperledger-fabric基础/","link":"","permalink":"http://yoursite.com/2018/04/10/hyperledger-fabric基础/","excerpt":"","text":"流程问题关于使用 kafka 实现共识重新部署 chaincode 时要删除 chaincode 生成的 docker 镜像fabric-ca 就是发证方，类似于银行发行信用卡。http://hyperledger-fabric.readthedocs.io/en/latest/identity/identity.html1A PKI is like a card provider – it dispenses many different types of verifiable identities. An MSP, on the other hand, is like the list of card providers accepted by the store – determining which identities are the trusted members (actors) of the store payment network. MSPs turn verifiable identities into the members of a blockchain network. MSPs 把可验证的身份证明集成到了区块链网络的成员中。 anchor peerchannel 上的其他节点都能够发现他并和他进行交流，并且 channel 上的每个 member 都会有 anchor peers(注意复数可以不只有一个 anchor peer)，这样所有的 peer(注意所有的 peer 就是指所属不同的 memer 的 peer 也是可以相互发现的) 之间可以通过 anchor peer 互相发现。 只读的 chaincode 调用客户端一般是不会将其记录进 ledger 的，除非客户端明确要求。transaction我们的 invoke(显然 query 也是 invoke 就意味着 query 也是可以提交到 ledger 的)和 instantiate 都成为 transaction 客户端从背书节点收集返回结果并将其打包提交到 ledger。 configtx.yml Consortium 联盟 系统链码 cscc：负责 joinchannel／config update 等 escc：负责对传入数据进行签名（msp 管理） lccc：负责 deploy invoke vscc：负责签名验证／策略验证（这里如何进行策略验证？） qscc：负责 ledger 查询 A principal is described in terms of the MSP that is tasked to validate the identity of the signer and of the role that the signer has within that MSP. Currently, two roles are supported: member and admin. Principals are described as MSP.ROLE, where MSP is the MSP ID that is required, and ROLE is either one of the two strings member and admin. Examples of valid principals are ‘Org0.admin’ (any administrator of the Org0 MSP) or ‘Org1.member’ (any member of the Org1 MSP).(http://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html)configtx.yml Profiles Organizations Application Orderer Capabilities Resources policy The primary purpose of this document is to explain how policies are defined in and interact with the channel configuratio UNKNOWN = 0; // Reserved to check for proper initialization SIGNATURE = 1; 使用 MSP = 2; IMPLICIT_META = 3; 使用 MSP OU organizationalUnitNamemsp config a folder admincerts to include PEM files each corresponding to an administrator certificate a folder cacerts to include PEM files each corresponding to a root CA’s certificate (optional) a folder intermediatecerts to include PEM files each corresponding to an intermediate CA’s certificate (optional) a file config.yaml to configure the supported Organizational Units and identity classifications (see respective sections below). (optional) a folder crls to include the considered CRLs a folder keystore to include a PEM file with the node’s signing key; we emphasise that currently RSA keys are not supported a folder signcerts to include a PEM file with the node’s X.509 certificate (optional) a folder tlscacerts to include PEM files each corresponding to a TLS root CA’s certificate (optional) a folder tlsintermediatecerts to include PEM files each corresponding to an intermediate TLS CA’s certificate Unlike today’s systems, where a participant’s private programs are used to update their private ledgers, a blockchain system has shared programs to update shared ledgers.不像现在的那些系统，参与者用他们私有的程序修改他们私有的账本，而区块链系统则是使用共享的程序修改共享的账本。 hyperledger 是由他们的参与者管理他们的交易participants manage their transactions hyperledger 不是一个公开的任何人都可以进行交易的系统，他是需要登录管理的，依靠 Membership Service Provider（MSP）来管理。多 channel 机制可以对参与者的信息进行隔离管理。hyperledger fabric 账本子系统包括 world state 和 transaction log 两部分。 world state 用来描述某一指定时间点时 ledger 的状态。他是 ledger 的数据库。 transaction log 记录了所有导致 world state 状态发生改变的 transaction smart contracts只能合约是以 chaincode 的形式体现的，当外部 application 想和 blockchain 交互时都是通过 chaincode, chaincode 和 blockchain 交互则是通过 world state 来进行的。并不是直接和 transaction log 交互的。 区域内信任即私链The ledger is the sequenced, tamper-resistant record of all state transitions in the fabric防篡改记录 features每一个 channel 有一个 ledger, 对于参与到 channel 的 peer 他们都是这个 channel 的 member 并且会有一份 ledger 的 copy 查询更新可以基于 key, 范围查询，组合 key 查询 只读的查询可以提供丰富的查询语句(world state 使用 CouchDB) 当启用数据来源功能时，可以查询某一 key 的历史数据 交易包括了 chaincode read set 和 write set 中 key/value 的版本号 transaction 包含所有 peer 的签名，并且提交给 ordering service transaction 在 blocks 中是有序的 peers 使用背书策略验证交易并执行这些策略 采用多版本管理，执行 chaincode 操作时会验证在执行时间内状态是否被改变过 交易一旦通过并且提交，则不允许在被改变 一个 channel 的 ledger 会有一个配置块来定以策略，acl 以及其他信息 channel 有 MSP 来 msp 目录 组织 ca 组织的根证书和对应的私钥 msp 代表该组织的身份信息 admincerts 组织管理员的身份验证证书，被根证书签名 cacerts 组织的根证书 tlscacerts 用于 tls 的 ca 证书，自签名 peers peer0 第一个 peer 的信息 msp admincerts 组织管理员的身份验证证书。peer 将基于这些证书来验证交易签署者是否为管理员 keystore 本节点自己的身份私钥，用来签名 signcerts 验证本节点签名的证书，被组织更证书签名 users 存放属于该组织用户的实体 configtx.yml Consortiums Order 所服务的联盟列表 Consortium 该应用通道锁关联的联盟的名称 MSP 分为 local msp 和 channel msp local msp 就是给 peer, orderer and users 使用的只针对其自身 channel msp 则是 channel 使用的多个组织都回去使用的，每个 peer 节点都会有一个 copy identity cert public key IdentityIdentifier: { msg.name, 以及一个唯一 id } 一个区块链网络拥有不同的参与者，包括 peer, orderer, client applications, administrators 等等。每一个参与者都会有一个身份证（Identity）以 x.509 数字证书的形式封装。这些身份证很重要，因为他决定了你对于整个区块链网络资源的权限。hyperledger 使用参与者身份证中的一些属性来确定权限，hyperledger 给他们定了一个特殊的名字：principal。Pricipals 就好比是 userIDs 或者是 groupIDs,但是他更灵活，因为他可以包含很多关于参与者身份的属性。当我们说 principals 的时候，我们就是在参与者在系统中的决定参与者权限的身份属性。这些属性通常是 organization, organizational unit, role 或者就是参与者的身份证。 还有参与者的身份证得是合法的被验证过的，并且是来自被系统所信任的权威组织。MSP(memebership service provider)就是用来验证 Identity 的是否是被信任的，更详细的说就是，MSP 是用来表示组织中成员关系规则的模块。MSP 定义了组织中成员身份（Identity）是否有效的规则。默认的 MSP 使用 X.509 证书来作为身份证，并且整个体系结构采用传统的 PKI 模型。 Identity 是身份证，CA 是发放身份证的，MSP 是验证身份证的。 msp 最多包含 9 项 root CAs(cacerts): 包含根证书，不只一个，可以有多个，对具体的 node 来说可能只有一个，就是 orgs 的根证书而对于一些 orgs 来说则有可能有很多个根证书，他标识了哪些 CAs 是属于相同的 orgs。（必有） Intermediate CAs(intermediatecerts): 同上中间级的 CA Organizational Units (config.yaml): 是用来严格指定 orgs 成员，若是没有则所有可以通过根 CA 认证的都被认为是相同组织的。 是需要在根证书中有体现的, 也就是在下发证书时是要表明你是属于哪个 ou 的, 这里还有问题就是可以根据具体的 node 的类型来设置 ou, 只有两类： client 和 peer 123456789101112131415161718OrganizationalUnitIdentifiers: Certificate: &quot;cacerts/cacert.pem&quot; OrganizationalUnitIdentifier: &quot;COP&quot;NodeOUs: Enable: false ClientOUIdentifier: # if Certificate is empty, then the certifier identifier will not be enforced Certificate: &quot;cacerts/cacert.pem&quot; OrganizationalUnitIdentifier: &quot;OU_client&quot; PeerOUIdentifier: Certificate: &quot;cacerts/cacert.pem&quot; OrganizationalUnitIdentifier: &quot;OU_peer&quot;``` Administrators(admincerts): 管理的证书（必选） Revoked Certificates(crls): 被撤销的证书 Node Identity(signcerts): 自身的身份识别证书，被组织根证书签过名的（必选） keystore(keystore): 上述证书身份认证证书的私钥（必选） tls root CA(tlscacerts): tls 链接使用的证书（必选） TLS Intermediate CA(tlsintermediatecerts):未见到是 tls 中间层的证书 资源权限的确认是用 principal 来确定一共有以下几类 pricinpal MSPPrincipal_ROLE：角色类, 参与者在网络的角色 admin member peer client MSPPrincipal_ORGANIZATION_UNIT：组织类，参与者在网络中的组织 MSPPrincipal_IDENTITY：身份证类，具体到某一个参与者的权限设置 application 与 fabric 的交互app 要和 fabric 交互是需要通过 peer 的 connect to peer invoke chaincode(proposal) peer invokes chaincode with proposal chaincode generates query or update proposal response proposal response request that transaction is ordered transactions sent to peers in blocks( from order to peers) peer updates ledger using transaction blocks ledger update event 通过以上我们得出 我们的客户端想要和 fabric 交互是先连接到 peer, 可 MSP 还记得否，因此 app 必须得有和 MSP 同一个 CA 下发的证书。 还有我们知道同一个组织的 peer 的证书是被同一个根证书所信任的，意味着，同一个组织间的 peer 的才可以进行 gossip 通信。不同组织间的通信通过 anchor peer 进行。 configtxgenconfigtx.yml 顶层 Profiles map[string]*Profile： 包括 order 以及 channel 配置 Organizations []*Organization：各个组织的配置（公共配置） Name string yaml:&quot;Name&quot; ID string yaml:&quot;ID&quot; MSPDir string yaml:&quot;MSPDir&quot; MSPType string yaml:&quot;MSPType&quot; AdminPrincipal string yaml:&quot;AdminPrincipal&quot; AdminRoleAdminPrincipal = “Role.ADMIN” MemberRoleAdminPrincipal = “Role.MEMBER” AnchorPeers []*AnchorPeer yaml:&quot;AnchorPeers&quot; Application *Application：应用通道的配置（公共配置） Orderer *Orderer：order 配置（公共配置） Capabilities map[string]map[string]bool （未知）(个人理解绝得他应该是指定 channel 或者其他实体对某项功能是否支持) Resources（未知）：权限判定 目前看到 Toplevel 有 resource, 还有 application 有 resource, 同以前讲的路径权限类似， /channel/application/admins configtxgen 工具生成 tx 文件依靠的就是 profile 中的配置项。 policy 规则 Policy_UNKNOWN Policy_PolicyType = 0 Policy_SIGNATURE Policy_PolicyType = 1： n_out_of 规则 Policy_MSP Policy_PolicyType = 2：就是 msp 证书验证规则（这里又有 MSPPrincipal role 角色规则判定） Policy_IMPLICIT_META Policy_PolicyType = 3：路径判定规则 比如：Admins 意味着只有某个实体或者组织的管理员才能操作/channel/order/Admins 意味只有 channel 中的 order 的管理员才能操作 ModPolicy 是指对策略的修改权限 国家部门规定药企需要自建追溯系统医药（溯源），供应链金融群托管的公共交换协议专业投资者（专业投资者可以做一些投资策略的事情但也以区块链的形式存储）与普通投资者的交互平台（Dao 以太坊） 发基金 购买 安全的智能合约形式化验证技术 定理证明（定理库） 模型检测（模型爆炸，程序太长） hyperledger 的密码算法应用场景 数字证书做身份认证 client 和 peers 之间的节点的交易数据是会被加密的，order 是无发探查到 client 提交的交易信息bccsp 统一密码服务入口接口描述 秘钥声明周期管理 keyGen 秘钥派生（通过一个秘钥生成另一个秘钥） 秘钥导入 获取秘钥 秘钥操作 验签 签名 hash 实现方案 software pkcs11 硬件（保证私钥不出设备） plugin(自实现 bccsp) msp Indentity 接口， 同上所描述的身份 可以从 channel 中获取其他 org 的 msg 信息 国密算法（是国内一些领域的准入门槛） sm2 椭圆曲线算法 sm3 hash 算法 sm4 对称算法 可以通过扩展 fabric 的 sw 来增加国密算法还可以使用硬件的方法实现还有 plugin 的方式实现 bccsp 的实现国密算法加入-msp 的支持 go 的运行时环境改造 go lib 层更改 重新实现 msp 也实现 msp 的插件形式 国密算法的其他支持 工具链支持 ca 支持 sdk 支持 msp 还可以根据 x.509 的属性来判断 1.1.0 中 增加了一个新的属性，可以在 chaincode 中调用接口来获取属性 cryptogen 的工具是没有中间 CA 的CA 推荐加上中间 CA 使用 fabric-ca 使用 可信第三方权威 CA 作为根 CA， fabric-ca 作为中间 CA 全部使用外部 CA,应当支持 fabric 所支持的 rest api，以及 x.509 的实现，添加属性等 用户操作 regist 注册 enroll 登录（登录后需要把返回的 secret 等信息保存在本地） reenroll(快到期的是后) revoke(吊销证书， 需要把吊销的证书放到 msp 的目录下) msp 分为 localmsp channelmsp msp 与 创世块 各个组织的 msp 信息都会被打倒创世块中 idmex 是另一种 bccsp 的实现添加 admins 需要在 fabric-ca 中注册一个新的用户，在把他的证书 copy 到 msp 的 amdincerts 中1.1.0 中 Identity 增加了很多借口transientMap 是可以被 chaincode 的代码访问到的，可以提供一些加密秘钥或者是其他的一些东西，但他们都不会记录到 ledger 的。登录过期问题用户登录以后缺少检查登录过期的问题 背书策略有如下三类，在创建 channel 的时候就确定了 role: memeber, admin ou: 部门名称 indenti 初始块解析出来以后可以看到很多的策略权限，但是目前还没看到可以有设置修改的位置所有的镜像版本号得一致若是 1.1.0 的那就都得是 1.1.0 的，比如 fabric-ccenv客户端链码安装时 go 版本是会去 GOPATH 下面去找的history 查询需要开启 history db一次 chaincode 调用，可以调用多次 putState123putState(&apos;k1&apos;, &apos;1&apos;);putState(&apos;k2&apos;, &apos;2&apos;);putState(&apos;k3&apos;, &apos;3&apos;); 链码（不同 channel 之间也可以）之间可以互相调用使用 invokeChaincode 但是只能是只读的。kafka 排序最少需要 4 个节 https://zhuanlan.zhihu.com/p/25358 https://www.jianshu.com/p/bd00f24a4771 https://docs.google.com/document/d/1vNMaM7XhOlu9tB_10dKnlrhy5d7b1u8lSY8a-kVjCO4/edit ca-server 需要先初始化， 再启动实例化 chaincode 时可以指定，背书策略如下，指定 admin 和 member 然后指定由谁来背书 123456789101112131415&apos;endorsement-policy&apos;: &#123; identities: [ &#123; role: &#123; name: &apos;member&apos;, mspId: ORGS[&apos;org1&apos;].mspid &#125; &#125;, &#123; role: &#123; name: &apos;member&apos;, mspId: ORGS[&apos;org2&apos;].mspid &#125; &#125;, &#123; role: &#123; name: &apos;admin&apos;, mspId: ORGS[&apos;org1&apos;].mspid &#125; &#125; ], policy: &#123; &apos;1-of&apos;: [ // &#123; &apos;signed-by&apos;: 2&#125;, // &#123; &apos;2-of&apos;: [&#123; &apos;signed-by&apos;: 0&#125;, &#123; &apos;signed-by&apos;: 1 &#125;]&#125; &#123; &apos;signed-by&apos;: 0 &#125;, &#123; &apos;signed-by&apos;: 1 &#125; ] &#125;&#125; 没有加入 channel 的 peer 是可以安装 chaincode 的但是无法实例化指定 channel 的 chaincode。peer 的配置 CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fixtures_default（当前目录名_network 名字） 很重要关系到 chaincode 容器是否能链接到相应的 peer fabric 网络中加入新的 peer，可以不需要再重新配置 config, 只需要相应的 org 向他颁发证书即可 msp admincerts 是 org 的 cert cacerts 是 org 的 ca 的 cacerts（最顶层的根证书） peer 自己的证书由 org 的 ca 签发 还有对应的私钥 tlscacerts 是 org 的 tlscacert(最顶层的根证书) tls ca.crt 由 org 的 tlscacert 颁发 server.crt 由 ca.crt 颁发 颁发的 x509 证书的域名是要和节点的域名相匹配例如我给 order 节点颁发的是 example.com 这个域名那么，order 机器对外的域名就得是 example 的子域名，若 order 对外的是 ip，则证书失效，证书里面必须体现 ip 才可以。 hyperledger 的 gossip 协议 简介 当我们配置 peer.gossip.orgLeader = true， 那么每个节点启动后都会去和 orderer 连接并接收消息 当我们配置 peer.gossip.userLeaderElection = true, 那么组织内配的节点启动后， 会参与 leader 的选举，选出一个 leader 和 orderer 进行通信，其他节点则是通过 leader 节点同步小心。 上面两项属于 bootstrap 配置，与 anchor peer 无关，anchor peer 是用来和其他组织进行通信的接口","categories":[],"tags":[{"name":"fabric","slug":"fabric","permalink":"http://yoursite.com/tags/fabric/"}]},{"title":"css 变量(慎重，有大图)","slug":"css-variables","date":"2018-04-06T02:05:27.000Z","updated":"2018-07-14T13:00:30.000Z","comments":true,"path":"2018/04/06/css-variables/","link":"","permalink":"http://yoursite.com/2018/04/06/css-variables/","excerpt":"","text":"原文地址 本文是 CSS Variables 的第一章(作者的新书) 大多数的语言都有变量，可是 css 里面是没有的（话说 css 是编程语言么？） 但是像一些 css 预处理器如 sass 等都会提供对变量的支持 值得高兴的是 css 现在也开始支持变量了(can i use)。 这篇文章里我会介绍一下 css variables 的使用，让我们 css 更利于维护吧！ 我们会学到什么？学习基础知识是非常好玩的，尤其是当我们用这些知识构造一个真实的 app。 Project 1: 使用 css Variables 创建一个可变的组件 Codepen Project2: 使用 CSS Variables 改变主题 Codepen Project3: 创建 CSS Variable booth Codepen 为什么变量这么重要呢？这里有几个原因大家可以一起看看 代码可阅读性增强，这个很明显，不会看到的都是字面量比如 #0f0f0f 等等，而可以看到的是 bg-color 修改也变得容易了，好比我们的盒子高度都是 40px，我想都修改为 42px，我就不需要一个一个去改了。。。 快速定位错误，你写一堆的 42px, 手一抖写了个 41px 咋办? 还有其他的由于不小心敲错的错误等等。。。 我们可以看到 css variables 的 可读性，可维护性都是很好的。 定义 css variables在 css 中 css variables 是以–开头的‘property’, 如下 12345/* can you spot the variable here ? */.block &#123; color: #8cacea; --color: blue;&#125; css variables 的作用域我们都知道在 js 里面，变量都是有作用域的。在 css 里也是一样的。 123:root &#123; --main-color: red;&#125; :root 选择器允许我们指定 DOM 中最顶级的元素或者是 document tree 因此我们在这个范围指定的 css variables 就是在全局范围内都可以使用的了。 举个 🌰1：假设你想创建一个 css variable 来存储主题的主色 先创建:root 选择器来指定‘全局’变量 123:root &#123;&#125; 定义变量 123:root &#123; --primary-color: red&#125; 一定要记住 css variable 必须以‘–’开头 eg: –color 使用 css variables一旦一个变量被定义了且初始化了，你就可以使用了。 这里有一些小陷阱。 如果你用过 css 预处理器，那么你就知道他们的变量的使用方式 12345$font-size: 20px;.test &#123; font-size: $font-size&#125; 但是 css variables 的使用时不同的， 你需要是用 var()来使用变量。如下： 1234567:root &#123; --font-size: 20px&#125;.test &#123; font-size: var(--font-size, 30px)&#125; 注意其中的第二个参数，是的 var 允许设置默认值，若是–font-size 未定义他就会使用默认值 另一个需要注意的地方是，css variables 不想预处理器里的变量那样，可以用在很多的地方以及进行数学运算，css variables 值允许作为属性值来使用。 12345/*this is wrong*/.margin &#123; --side: margin-top; var(--side): 20px;&#125; 你也不可以进行数学运算，除非使用 calc() 12345/*this is wrong*/.margin &#123; --space: 20px * 2; font-size: var(--space); // not 40px&#125; 而应该使用下面这种方式 1234.margin &#123; --space: calc(20px * 2); font-size: var(--space); /*equals 40px*/&#125; 值得一提的地方这里还有一些其他需要值得注意的地方 自定义属性（css variables）就是普通的属性，因此你可以在任何元素中声明他们可以在 p, section, aside, root 设置伪元素中使用。 css variables 也拥有正常继承和层叠规则就像其他属性似的（例如 color 属性可以被继承似的） 12345678910div &#123; --color: red;&#125;div.test &#123; color: var(--color);&#125;div.ew &#123; color: var(--color);&#125; –color 会被 divs 所继承。 css variables 也可以使用在媒体查询里面或者其他条件规则例如 123456:root &#123; --gutter: 10px&#125;@media screen and (min-width: 768px) &#123; --gutter: 30px;&#125; css variables 还可以在 html style 属性里面使用 1234567&lt;!--HTML--&gt;&lt;html style=&quot;--color: red&quot;&gt;&lt;!--CSS--&gt;body &#123; color: var(--color)&#125; 还有就是 css variables 是大小写敏感的 12345/*these are two different variables*/:root &#123; --color: blue;--COLOR: red;&#125; 多次声明 多次声明同一个 variable 如下 1234567/*define the variables*/:root &#123; --color: blue; &#125;div &#123; --color: green; &#125;#alert &#123; --color: red; &#125;/*use the variable */* &#123; color: var(--color); &#125; 然后看看下面这写元素的颜色吧 123456&lt;p&gt;What&apos;s my color?&lt;/p&gt;&lt;div&gt;and me?&lt;/div&gt;&lt;div id=&apos;alert&apos;&gt; What&apos;s my color too? &lt;p&gt;color?&lt;/p&gt;&lt;/div&gt; 第一个 p 的颜色是 blue, 因为 p 没有直接的–color 定义，因此继承了:root 内的–color 定义。 第一个 div 是绿色的 因为 div 内有直接的–color 定义 id 是 alert 的 div 是 red，因为#alert 也有直接的–color 定义，按照 css 选择器的权重来看也是 red，因为 id 选择器是仅次于内联 和 important 的, so… 最后在#alert 里的 p 也是红色的，因为 p 继承了#alert 的–color 属性 循环依赖的解析 看下面 当一个变量依赖他自己时使用 var()来引用 1234567:root &#123; --m: var(--m)&#125;body &#123; margin: var(--m)&#125; 当多个变量相互依赖 1234:root &#123; --one: calc(var(--two) + 10px); --two: calc(var(--one) - 10px);&#125; 注意千万不要创建循环依赖发，循环依赖是不 ok 的。 使用无效的变量会发什么什么？ 语法错误会被丢弃，那么无效的 var()会发生什么？ 看下面： 12345:root &#123; --color: 20px;&#125;p &#123; background-color: red; &#125;p &#123; background-color: var(--color); &#125; –color 会被替换为 20px, 然而 20px 这个值对于 background-color 是个无效的值，并且他是非继承属性，因此它的值会被设置为 initial: transparent。尴尬了吧。 接下来高能了，上面那个呢是给设置成了 initial 值，那么要是不用 css 变量直接写个 20px 呢，这个属性会被丢弃的，啥都木有 可以再 dev-tools 里面验证一下就得到了，直接写错是无效的。 在 chrome65 下验证过了，确实是的 设置数值请注意–单一实体 见下： 1font-size: 20px; 20px 就是一个单一实体，是个整体 当使用 css variables 时一定要注意，如下 123456:root &#123; --size: 20&#125;div &#123; font-size: var(--size)px /*wrong*/&#125; 如上的代码你可能想要的结果是 20px,可惜你错了， 浏览器会把他解析为 20 px; 请注意 20 和 px 中间有空格哦！说白了就无法生效 如果一定要这么用的话就得这么用 calc(var(–size) * 1px), ok! 下面来一点儿实操创建颜色不同的 button 可以看到他们的不同是 border-color 和 background-color，那么我们会怎么做呢？ 如下 12&lt;button class=&quot;btn&quot;&gt;Hello&lt;/button&gt;&lt;button class=&quot;btn red&quot;&gt;Hello&lt;/button&gt; .btn 会包含基本的 style,如下 1234567891011121314.btn &#123; padding: 2rem 4rem; border: 2px solid black; background: transparent; font-size: 0.6em; border-radius: 2px;&#125;/*on hover */.btn:hover &#123; cursor: pointer; background: black; color: white;&#125; 那么那些可变的因素在哪呢？ 123456.btn.red &#123; border-color: red&#125;.btn.red:hover &#123; background: red&#125; 接下来我们用 css 变量来改写一下 12345678910111213.btn &#123; padding: 2rem 4rem; border: 2px solid var(--color, black); background: transparent; font-size: 0.6em; border-radius: 2px; &#125; /*on hover*/ .btn:hover &#123; cursor: pointer; background: var(--color, black); color: white; &#125; var 第二个参数在上面我们说过了是 default value 接下来看 123.btn.red &#123; --color: red&#125; 此时再来看看比较 如果你有更多的颜色的 button,如下 总结其实变量这个东西是个语言都支持了，为啥 css 没有呢，在我看来因为是一开始就没把 css 当做编程语言来用。 其实 web 也是 GUI 编程，我们纵观一下 GUI 编程，其实一开始都是直接语言去控制的，比如 QT, 所有的图形都是 C++去操作的，无论是按钮啊，tabel 啊都是的。可是人们就发现 UI 是可以和逻辑分开的。于是就出了可视化的 GUI 编程，妥妥拽拽啥的，最后是用 XML 来表达的，android,ios 都是差不多的。 那 web 呢，我在我的一片文章里说过了，一开始 web 就不是打算来进行 UI 的，他只是像做一些文档展示的工作，可是社会是前进的，web 越来越火，对页面样式的控制也是极度强烈，但一开始都是一些简单的控制，一点一点才复杂化的，从简单开始 css 就出现了，在我看来 css 就好比是 GUI 中的 XML，但是用他们总是会有限制的。 因此 css 的出现就好比是 XML 我只需要配置就好了，那么复杂干什么！！！要啥变量啊！要啥变量！！ 可随着 web 的功能性越来越强他需要 GUI 的能力，于是出现了 canvas, css variables, 硬件加速等等。 web 的发展已经完全超出了他最初的目的，只要性能问题解决了，往后哪有 GUI 编程啊，都是 web(虽然 web 也可以看做 GUI，但他的限制还是太多了)。 写到这其实我觉 GUI 编程或者说 application 的编程需要新的语言来解决一些问题了，无论是包袱太多还是什么其他问题，web 不应该再用 js 了(可惜不现实)，因为 js 的缺点确实多，历史包袱多，很难再有大的进化了。GUI 也不应该再用 C#, Java, C++了，他们都带繁重了。我看到了 Dart, 虽然出了很久了，可惜不火，dart 是新时代设计的语言，经过深思熟虑，不想 js 10 天就出来。 新的时代就应该用新的语言。当然这很难…","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"js中的委托vs继承","slug":"js中的委托和继承","date":"2018-04-04T16:00:00.000Z","updated":"2018-07-14T13:00:30.043Z","comments":true,"path":"2018/04/05/js中的委托和继承/","link":"","permalink":"http://yoursite.com/2018/04/05/js中的委托和继承/","excerpt":"","text":"曾经 James Gosling（java 之父） 回答过一个问题，那就是如果让他从头重写一遍 java，那会有什么不同的地方？他回答说那就是不要继承只有委托。 使用继承来重用代码就好比是你想要一个塑料碗于是你定了一个外卖似的。事实上当你按照教课书似的来使用继承，你回发现你的整个继承架构是那么的脆弱和随意。子类会一直拥有它根本不需要的方法或者属性，这就违背了最小知识原则。 而委托则是通过运行时在具体的实例上下文中进行函数调用来实现代码重用的。如下： 1Object.prototype.toString.call(&#123;&#125;); 在 js 中同 call 和 apply 我们可以很轻松的实现委托。 自定义函数委托假设我们的有一款绘画 app, 我们需要一个矩形对象。我们先用如下的方法实现： 1234567891011121314const Rectangle = function(left, top, length, width, options) &#123; this.left = left; this.top = top; this.length = length; this.width = width; if (options) &#123; this.color = options.color; this.border = options.border; this.opacity = options.opacity; //... etc. &#125;&#125;const myRectangle = new Rectangle(10, 10, 30, 20, &#123;color:&apos;#FAFAFA&apos;, opacity:0.7&#125;); 我们也需要知道两个矩形是否重叠，因此有如下的方法： 1234567891011121314Rectangle.prototype.overlaps = function(another) &#123; const r1x1 = this.left, r1x2 = this.left + this.width, r1y1 = this.top, r1y2 = this.top + this.height, r2x1 = another.left, r2x2 = another.left + another.width, r2y1 = another.top, r2y2 = another.top + another.height; return (r1x2 &gt;= r2x1) &amp;&amp; (r1y2 &gt;= r2y1) &amp;&amp; (r1x1 &lt;= r2x2) &amp;&amp; (r1y1 &lt;= r2y2);&#125;myRectangle.overlaps(myOtherRectangle); 现在假设我们的 app 有一个用来渲染 dashlets 的 dashbord。我们也需要判断这些 dashlets 是否重叠。因此我们可以使用继承，然后让他们继承自 Rectangle。但其实我们也可以使用委托来实现 1Rectangle.prototype.overlaps.call(dashlet1, dashlet2); 完整的如下： 12345678910111213141516171819202122232425const Rectangle = function(left, top, length, width, options) &#123; //whatever...&#125;Rectangle.prototype.overlaps = function(another) &#123; const r1x1 = this.left, r1x2 = this.left + this.width, r1y1 = this.top, r1y2 = this.top + this.height, r2x1 = another.left, r2x2 = another.left + another.width, r2y1 = another.top, r2y2 = another.top + another.height; return (r1x2 &gt;= r2x1) &amp;&amp; (r1y2 &gt;= r2y1) &amp;&amp; (r1x1 &lt;= r2x2) &amp;&amp; (r1y1 &lt;= r2y2));&#125;Rectangle.prototype.overlaps.call( &#123;left: 10, top: 10, width 12, height: 6&#125;, &#123;left: 8, top: 15, width 9, height: 16&#125;);//true Rectangle.prototype.overlaps.call( &#123;left: 10, top: 10, width 12, height: 6&#125;, &#123;left: 8, top: 25, width 9, height: 16&#125;);//false; 泛型函数（generic）那么内置函数是否都可以像上面那么使用么？不幸的是许多内置函数都不行，若是 this 不是指定的类型就会抛出 TypeError。 12Date.prototype.getMilliseconds.apply(&#123;year:2010&#125;);//TypeError: Date.prototype.getMilliseconds called on incompatible Object 幸运的是 es5 规范明确的描述了 generic functions 的概念。泛型函数是指那些允许 this 的类型是任意类型的函数。举个例子： 1const hasNumbers = &apos;&apos;.search.call([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], /[0-9]/) &gt; -1 委托，组合，继承继承链太长，继承结构机会很脆弱，就会给子孙添加很多不必要的东西。能用委托和组合就不要使用继承。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Object.prototype.toString是什么鬼？","slug":"fix-typeof","date":"2018-04-04T16:00:00.000Z","updated":"2018-07-14T13:00:30.002Z","comments":true,"path":"2018/04/05/fix-typeof/","link":"","permalink":"http://yoursite.com/2018/04/05/fix-typeof/","excerpt":"","text":"发生了什么问题：类型的判断我想判断一个变量 a 是什么类型，那么我们会怎么做? typeof a? ok，我们来看看 12345let a = 2;typeof a; // &apos;number&apos;let c = &apos;as&apos;;typeof c; // &apos;string&apos; 嗯 ：），看着不错哦！似乎我们是解决了，可惜啊，让我们来看一张表 Type of val result Undefined “undefined“ Null “object“ Boolean “boolean“ Number “number“ NaN “object“ String “string“ Object (native and not callable) “object“ Object (native or host and callable) “function“ Object (host and not callable) 不同实现有不同表现 额 ：（ 看完是不是就有一丝丝不高兴了，因为他并不是很好，因为有些类型他也没办法区分比如 null, Array 他都识别为对象了，不高兴啊！总之在 js 里面进行类型判断是一件很不爽的事情，不像 java 和 golang 这种强类型的语言，他们总是有很明确的方法来判断自己是啥类型因为他们都有自己的反射机制。 有没有更好的办法呢：[[class]][[class]]是什么呢？ es5 规范里面规定的所有的 js 对象都有的一个内部属性（es 规范使用[[]]表示内部属性），用来表明对象分类的字符串属性，就是说他是用来表示对象类型。对于我们来说，这意味着，所有的内置对象类型都有一个唯一的不可修改的，规范强制规定的值，很明显要是咱们能拿到这个值，对象类型识别问题就解决了。。。 此时 Object.prototype.toString 就要登场了。让我们看看 es5 规范里对于他的描述 如果 this 的值是 undefined, 返回 “[object Undefined]”. 如果 this 的值是 null, 返回 “[object Null]”. 令 O 为以 this 作为参数调用 ToObject 的结果 . 令 class 为 O 的 [[Class]] 内部属性的值 . 返回三个字符串 “[object “, class, and “]” 连起来的字符串 . ToObject 就是把 this 转换为对象，比如 4-&gt; Number, ‘’ -&gt; String 等等 简单描述一下就是 toString 的调用会返回如下的格式 1[object [[class]]] 看到没，通过他就可以拿到对象的内部[[class]]属性了。但这是时候有人就会说了，你瞅瞅下面的 12345[1,2,3].toString(); //&quot;1, 2, 3&quot;(new Date).toString(); //&quot;Sat Aug 06 2011 16:29:13 GMT-0700 (PDT)&quot;/a-z/.toString(); //&quot;/a-z/&quot; 你看，你看，还是不行啊！ 上面现象的原因在于，打部分的内置对象都重写了 Object.prototype.toString 函数。比如Number。 显然直接调用时不行的，但坏就坏在我们在用 js, 好也好在我们在用 js, 估计大家都想到了，我们还有两个方法 call 和 apply， 如下 12345Object.prototype.toString.call([1,2,3]); //&quot;[object Array]&quot;Object.prototype.toString.call(new Date); //&quot;[object Date]&quot;Object.prototype.toString.call(/a-z/); //&quot;[object RegExp]&quot; js 这门语言本身就积累了太多的弊端了，好好在用的人多，坏也坏在用的人多 用的人多语言本身才能发展的好，用的人多反而也会让 js 本身的发展瞻前顾后，就好比 c++似的。就 cs 发展到现在，我觉得其实是需要新的 GUI 语言的出现或者说专注于 application 的语言，比如我最近看了 Dart 就不错，语法合适，没有很多奇怪的问题，可惜也没有太好的发展，这个可以再开一篇来讲了。（劣币驱逐良币么？） 更好的[[class]]获取封装来，咱们封装一个 toType 吧！ 123const toType = function(obj) &#123; return (&#123;&#125;).toString.call(obj).match(/\\s([a-zA-Z]+)/)[1].toLowerCase()&#125; 为什么要用({}).toString.call,在我看了就是少写几个字符而已，但其实若是我调用 toType 的次数太多，({})这种方式我觉得也不行啊，因为每次调用都要再创建一个对象啊！ 我们来试试这个函数吧 1234567891011toType(&#123;a: 4&#125;); //&quot;object&quot;toType([1, 2, 3]); //&quot;array&quot;(function() &#123;console.log(toType(arguments))&#125;)(); //argumentstoType(new ReferenceError); //&quot;error&quot;toType(new Date); //&quot;date&quot;toType(/a-z/); //&quot;regexp&quot;toType(Math); //&quot;math&quot;toType(JSON); //&quot;json&quot;toType(new Number(4)); //&quot;number&quot;toType(new String(&quot;abc&quot;)); //&quot;string&quot;toType(new Boolean(true)); //&quot;boolean&quot; 我们再来看看 typeof 1234567891011typeof &#123;a: 4&#125;; //&quot;object&quot;typeof [1, 2, 3]; //&quot;object&quot;(function() &#123;console.log(typeof arguments)&#125;)(); //objecttypeof new ReferenceError; //&quot;object&quot;typeof new Date; //&quot;object&quot;typeof /a-z/; //&quot;object&quot;typeof Math; //&quot;object&quot;typeof JSON; //&quot;object&quot;typeof new Number(4); //&quot;object&quot;typeof new String(&quot;abc&quot;); //&quot;object&quot;typeof new Boolean(true); //&quot;object&quot; 其实 typeof 也可以用函数调用的方法来书写， typeof(a)，大家可以试试是 ok 的。 那么 instanceof 呢？instanceof 又是什么呢？简单的说是用来测试一个对象是否是一个类的是实例（按照面向对象的说法）。他的实现方式是检测第二个输入参数的 prototype 是否在第一个输入参数的原型链上出现过(第二个参数必须是一个 constructor)，比如： 1234567let a = [1,2,3];a.__proto__; // []Array.prototype; // []和上面的那个是同一个对象a instanceof Array; // truea.__proto__ = &#123;&#125;a instanceof Array; // false 有几个关于 instanceof 的点需要我们注意 有一些内置对象是没有相应的 constructor 的，比如 Math, JSON and arguments, 因此他们是没办法使用 instanceof 的 当我们使用 iframe 的时候，就会产生多个上下文，此时就没办法保证 instanceof 的准确行了 12345678const iFrame = document.createElement(&apos;IFRAME&apos;);document.body.appendChild(iFrame);const IFrameArray = window.frames[1].Array;const array = new IFrameArray();array instanceof Array; //falsearray instanceof IFrameArray; //true; 在 node 里面就应该到此为止了，但是对于浏览器来说还没有结束呢！因为不同的浏览器还有各自的宿主对象呢？很可惜的是我们的 toType 对他们并不管用：（, 比如： 1234567891011toType(window);//&quot;global&quot; (Chrome) &quot;domwindow&quot; (Safari) &quot;window&quot; (FF/IE9) &quot;object&quot; (IE7/IE8)toType(document);//&quot;htmldocument&quot; (Chrome/FF/Safari) &quot;document&quot; (IE9) &quot;object&quot; (IE7/IE8)toType(document.createElement(&apos;a&apos;));//&quot;htmlanchorelement&quot; (Chrome/FF/Safari/IE) &quot;object&quot; (IE7/IE8)toType(alert);//&quot;function&quot; (Chrome/FF/Safari/IE9) &quot;object&quot; (IE7/IE8) 其实对于 Dom 对象来说使用 nodeType 来判断是最好的了，兼容性也 ok。 123function isElement(obj) &#123; return obj.nodeType;&#125; 但这其实是一个 duck-typing, 因此也是没有保证的。 到此总结一下即使我们做了上面那么多的是事情依然不能够保证完美，因为 js 太灵活了。比如我们可以重写了 Object.prototype.toString 的实现，那么我们所提供的稍微靠谱的解决方案就 GG 了，因此我们最好不要随意去重写原生的 prototype 的方法。请避免把 toType 用到 host object 的判断以及要检查是否传入了未定义的变量。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"postgres基础学习","slug":"postgres基础学习","date":"2018-04-03T16:00:00.000Z","updated":"2018-07-14T13:00:30.068Z","comments":true,"path":"2018/04/04/postgres基础学习/","link":"","permalink":"http://yoursite.com/2018/04/04/postgres基础学习/","excerpt":"","text":"sql 语句就好比pipeline似的，上一个的执行结果喂给下个语句（select 语句永远在最后）使用汉语时需要使用’’单引号select 不但可以使用列名还可以写常量比如“商品”等字符串。1select &quot;商品&quot; as &apos;name&apos;, id from product; 在 SELECT 语句中使用 DISTINCT 可以删除重复行, DISTINCT 关键字只能用在第一个列名之前123456select distinct product_id from product;or select distinct product_id, purchase_price from product;// 这是会按照product_id, 和purchase_price进行合并去重的// 因此如下写是错误的select product_id, distinct purchase_price from product; // error WHERE 子句要紧跟在 FROM 子句之后。单行注释书写在“–”之后，只能写在同一行 多行注释/ /类c select 字句也可以使用算数运算，比如2倍价钱， 常用的4则运算，当查询结果是null时，那所有的运算结果都是null1select purchase_price * 2 as &apos;purchase_price2&apos; from product; 运算就是这样以’行’为单位执行的, 查出一行执行一行SELECT 子句中可以使用常数或者表达式比较运算符在where字句中的有 = 相等， &lt;&gt; 不等 &gt;=, &lt;=, &lt;, &gt;WHERE 子句的条件表达式中也可以使用计算表达式 比如查询卖出价比买入价多600的商品,相当与在找单品利润大于600的12select product_id, product_name, product_type from productwhere sale_price - purchase_price &gt; 600 insert into table_name values (‘field’, …), (‘field_value’, …) …;插入多行数据字符串类型的数据原则上按照字典顺序进行排序，不能与数字的大小顺序混淆说白了，就是ascii的大小对null 不能使用比较运算符，sql 有专门的is null 和is not null来判断12select product_name from productwhere purchase_price is null; 逻辑运算符，not, and, or 售价不大于1000的 12select product_name from productwhere not sale_price &gt; 1000; and 条件都满足, 售价大于100的衣服 12select product_name from productwhere sale_price &gt; 100 and product_type = &apos;衣服&apos; AND 运算符的优先级高于 OR 运算符。想要优先执行 OR 运算符时可以使用括号count聚合函数应用在具体列时，不会对null进行计算就是不包括nullCOUNT 函数的结果根据参数的不同而不同。COUNT(*) 会得到包含 NULL 的数据 行数，而 COUNT(&lt; 列名 &gt;) 会得到 NULL 之外的数据行数。12select count(purchase_price) from product;// 假设一共有8行2行purchase_price是null，则上面的输出是6 当select字句中使用了聚合函数后，则整个select语句中只能使用聚合函数，或者常量而不允许在直接使用列名了。所有的聚合函数，如果以列名为参数，那么在计算之前就已经把 NULL 排除在外了，聚合函数会将 NULL 排除在外。但 COUNT(*) 例外，并不会排除 NULL。由于有上述原因所以在我们计算平均值时avg，也会出问题，他会把null也排除，那么平均值得分母也就少了。MAX/MIN 函数几乎适用于所有数据类型的列。SUM/AVG 函数只适用于数值类型的列。想要计算值的种类时，可以在 COUNT 函数的参数中使用 DISTINCT。1select count (distinct product_type) form product 所有的聚合函数都可以使用 DISTINCT, 在聚合函数的参数中使用 DISTINCT，可以删除重复数据。使用聚合函数和GROUP BY子句时需要注意以下4点。 GROUP BY子句也和SELECT子句一样， 可以通过逗号分隔指定多列。GROUP BY 就像是切分表的一把刀。 此外，GROUP BY子句的书写位置也有严格要求，一定要写在 FROM 语句之后(如果有 WHERE 子句的话需要写在 WHERE 子句之后)。 聚合函数只能写在SELECT子句之中 GROUP BY子句中不能使用SELECT子句中列的别名 GROUP BY子句的聚合结果是无序的 WHERE子句中不能使用聚合函数 聚合键中包含 NULL 时，在结果中会以“不确定”行(空行)的形式表现出来。GROUP BY和WHERE并用时SELECT语句的执行顺序FROM → WHERE → GROUP BY → SELECT 使用聚合函数与group by字句时常见的错误 在select 语句中写了多余的列在使用了聚合函数，以及group by字句时，select字句中的列是有严格限制的 常数 聚合函数 group by 字句中指定的列名（就是聚合键） 使用 GROUP BY 子句时，SELECT 子句中不能出现聚合键之外的列名。 使用 GROUP BY 子句时，SELECT 子句中不能出现聚合键之外的列名。 GROUP BY子句的结果能排序吗? 答案随机的， GROUP BY 子句结果的显示是无序的。 在 WHERE 子句中使用聚合函数, where 字句中是不能使用字句的。 只有SELECT子句和HAVING子句(以及ORDER BY子句)中能够使用聚合函数， where是不对分组数据处理的where处理的是单行数据。对聚合结果操作，指定条件having 子句HAVING 子句要写在 GROUP BY 子句之后having 子句与select子句类似只能包含以下 常数 聚合函数 group by 字句中指定的列名（就是聚合键）1234select product_type, count(*) from productgroup by product_typehaving product_name = &apos;圆柱笔&apos;// error 错误 在where字句中和having字句中都可以出现的条件是聚合键所对应的条件 WHERE 子句 = 指定行所对应的条件 HAVING 子句 = 指定组所对应的条件但应当符合上述的要求，聚合键的条件写在where子句会更好 where字句中的条件执行速度会比having子句的执行性能好一些ORDER BY 子句通常写在 SELECT 语句的末尾。排序键中包含 NULL 时，会在开头或末尾进行汇总。带有order by 子句的整体执行流程FROM→WHERE→GROUP BY→HAVING→SELECT→ORDER BY 在 ORDER BY 子句中可以使用 SELECT 子句中定义的别名。在 ORDER BY 子句中可以使用 SELECT 子句中未使用的列和聚合函数在 ORDER BY 子句中可以使用 SELECT 子句中使用的列和聚合函数定义视图时不要使用ORDER BY子句子查询一言以蔽之，子查询就是一次性视图(SELECT语句)。与视图不同，子查 询在 SELECT 语句执行完毕之后就会消失子查询作为内层查询会首先执行。标量子查询标量子查询就是返回单一值的子查询。标量子查询有一个特殊的限制，那就是必须而且只能返回 1 行 1列的结果，也就是返回表中某一行的某一列的值，例如“10”或者“东京都” 这样的值。 标量子查询的书写位置并不仅仅局限于 WHERE 子句中，通常任何可 以使用单一值的位置都可以使用。也就是说，能够使用常数或者列名的 地方，无论是 SELECT 子句、GROUP BY 子句、HAVING 子句，还是 ORDER BY子句，几乎所有的地方都可以使用。使用标量子查询时的注意事项，那就是该子查询 绝对不能返回多行结果where 子句是一行一行处理数据的，所以不能使用聚合函数，WHERE 子句中不能使用聚合函数关联子查询是指内部自查使用了外包部查询的变量在细分的组内进行比较时，需要使用关联子查询。关联子查询也是用来对集合进行切分的 作用group by 类似别名的使用’内部可以看到外部，而外部看不到内部‘select 子句中若是出现了，聚合函数则其他列就不能使用，除非这个列是聚合件exist 谓词通常指定关联子查询作为 EXIST 的参数\\dt 显示表详细信息关于数据库join的问题 数据库join service应用层joinhttps://www.zhihu.com/question/68258877 重代码和重sql的两种编码方式https://zhuanlan.zhihu.com/p/36585028","categories":[],"tags":[{"name":"sql postgres","slug":"sql-postgres","permalink":"http://yoursite.com/tags/sql-postgres/"}]},{"title":"为什么不要使用setInterval?","slug":"why-not-use-setinterval","date":"2018-04-01T16:00:00.000Z","updated":"2018-07-14T13:00:30.099Z","comments":true,"path":"2018/04/02/why-not-use-setinterval/","link":"","permalink":"http://yoursite.com/2018/04/02/why-not-use-setinterval/","excerpt":"","text":"最近我遇到了一个情况，就是需要在一个特定的时间间隔后调用一个函数。好比说每隔十秒就发送一个 ajax 请求。显然，最好的选项似乎是 setInterval, 但是我被分分钟搞得灰头土脸。 为了了解为甚么 setInterval 是邪恶的，那么我们得先搞清楚一个事实那就是 js 是单线程的，也就是同一时间只能执行一个操作。 如果我们的函数的执行时间都比咱么的延时时间还长（好比 ajax call）, 我们就会发现我们的 setInterval 就不会准时触发了，事实上 js 的定时器就是这么无奈，他的定时总是不准时。 1234567891011121314151617181920212223const fakeCallToServer = () &#123; setTimeou(() =&gt; &#123; console.log(&apos;returning from server&apos;, new Date().toLocaleTimeString()); &#125;, 4000)&#125;setInterval(function()&#123; let insideSetInterval = new Date().toLocaleTimeString(); console.log(&apos;insideSetInterval&apos;, insideSetInterval); fakeCallToServer();&#125;, 2000);//insideSetInterval 14:13:47//insideSetInterval 14:13:49//insideSetInterval 14:13:51//returning from server 14:13:51//insideSetInterval 14:13:53//returning from server 14:13:53//insideSetInterval 14:13:55//returning from server 14:13:55 尝试一下上面的代码 就像你看到的一样 setInterval 中的 console.log 一直在输出 ajax calls, 根本就不会理会之前的请求是否返回或是其他的情况。这样就会在后端 server 囤积大量的请求。 现在咱们再来试试同步操作： 12345678910111213141516171819202122232425262728293031323334353637var counter = 0;var fakeTimeIntensiveOperation = function() &#123; for(var i =0; i&lt; 50000000; i++) &#123; document.getElementById(&apos;random&apos;); &#125; let insideTimeTakingFunction = new Date().toLocaleTimeString(); console.log(&apos;insideTimeTakingFunction&apos;, insideTimeTakingFunction);&#125;var timer = setInterval(function()&#123; let insideSetInterval = new Date().toLocaleTimeString(); console.log(&apos;insideSetInterval&apos;, insideSetInterval); counter++; if(counter == 1)&#123; fakeTimeIntensiveOperation(); &#125; if (counter &gt;= 5) &#123; clearInterval(timer); &#125;&#125;, 1000);//insideSetInterval 13:50:53//insideTimeTakingFunction 13:50:55//insideSetInterval 13:50:55 &lt;---- not called after 1s//insideSetInterval 13:50:56//insideSetInterval 13:50:57//insideSetInterval 13:50:58 可以很明显的看到，当 setInterval 遇到了 cpu 敏感的操作时，setInterval 就完全乱了节奏。 结论异步操作时，setInterval 有可能会堆积很多的异步操作，而同步操作则会打乱 setInterval 的节奏。并且当函数报错时 setInterval 也是不会停止的，但其实可以使用 clearInterval 在停止 setInterval。我们可以使用 setTimeout 递归调用来模拟 setInterval 这可以让我们更好的控制代码。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"mirror-git","slug":"mirror-git","date":"2018-03-05T14:00:59.000Z","updated":"2018-07-14T13:00:30.043Z","comments":true,"path":"2018/03/05/mirror-git/","link":"","permalink":"http://yoursite.com/2018/03/05/mirror-git/","excerpt":"","text":"镜像代码库的方法我希望这篇文章能够清晰的描述一下如何镜像 git 仓库—即我有一个 github 仓库 example.git, 还有一个 sourceforge 仓库 example.git, 我希望这两个仓库的代码可以镜像同步，就是我无论更新哪一个都会同步到另一个仓库上去。 建立一个本地的仓库，并且设置 upstream(就是添加 remote)。重点：这得是个 bare 仓库123cd /srv/gitsyncgit clone --bare git@github.com:[account]/[repository].gitmv [repository].git [repository] 接下来，我们删除 origin ‘remote’，并且配置两个远程仓库为 upstream 就是添加 remote,看代码更详细： 1234cd [repository]git remote remove origingit remote add github git@github.com:[account]/[repository].gitgit remote add sourceforge ssh://[account]@git.code.sf.net/p/[repository]/code 镜像意味着无论哪个仓库有更新都会同步到另外一个仓库上去。因此我们应当有个 webhook 来触发我们镜像脚本。每个代码管理都会提供这样的 hook 的。 镜像脚本我们使用如下的代码来实现真正的同步逻辑。123456789101112131415161718192021222324252627282930313233#!/bin/bashfunction sync_repo &#123; cd /srv/gitsync cd $1 echo $1 # fetch all known remotes 获取所有remote的代码更新 git fetch --all -p # 我们可以看同步就在下面进行 # push branches from sourceforge to github and via versa. 先同步sourceforge 到github. 注意 push的目的remote是github, 源remote是在refs/remote中指定的sourcefore git push github &quot;refs/remotes/sourceforge/*:refs/heads/*&quot; # 同理推送 github上的代码更新到sourceforge git push sourceforge &quot;refs/remotes/github/*:refs/heads/*&quot;&#125;# 处理参数，进入指定的bare仓库进行推送cd /srv/gitsyncif [ &quot;$1&quot; == &quot;&quot; ]; then # no command line parameters, print help message echo &quot;gitsync [report]|--all&quot;elif [ &quot;$1&quot; == &quot;--all&quot; ]; then # &quot;--all&quot;: for all known repositories for D in *; do if [ -d &quot;$&#123;D&#125;&quot; ]; then sync_repo $D cd /srv/gitsync fi doneelif [ -d &quot;$1&quot; ]; then # sync only the specified repository sync_repo $1else echo &quot;gitsync [report]|--all&quot;fi 我们可以看到在 sync_repo 函数中我们把 github 和 sourceforge 进行了互相推送。当然你还可以进行更多的映射。 就像我们上面讨论的，我门使用 webhooks 来触发我们的 mirror 行为。可以使用如下的 php 脚本 12345678910111213141516if ($_SERVER[&apos;REQUEST_METHOD&apos;] !== &apos;POST&apos;) &#123; die(&apos;POST required&apos;);&#125;if (!isset($_REQUEST[&apos;repository&apos;])) &#123; die(&apos;repository not specified&apos;);&#125;// validate repository name to prevent injection and traversing attacks$repo = $_REQUEST[&apos;repository&apos;];if (!preg_match(&apos;/^[a-zA-Z0-9]+$/&apos;, $repo)) &#123; die(&apos;invalid repository name&apos;);&#125;header(&apos;HTTP/1.0 204 Found&apos;);system(&apos;sudo -Hu gitsync /usr/local/bin/gitsync &apos;.$repo); 安全 我们必须的校验仓库名称，以防止 shell 命令注入，git 命令注入，以及目录遍历等非法行为。 上面的代码使用了 sudo 的权限，显然 webserver 不应该拥有可访问仓库的权限。 大部分代码管理都支持 webhook 验证，但是我么上面的例子没有使用验证，那意味着任何人都可以触发我们的同步行为。 删除分支这里还没有好的方法可以让我们同步删除分支的行为。但是我们还是通过我们脚本以 push 的方法来进行删除。且看下面的方法123git branch -d [branchName]git push github --delete [branchName]git push sourceforge --delete [branchName] 虽然麻烦但是我们还是实现了：)。","categories":[],"tags":[{"name":"git mirror","slug":"git-mirror","permalink":"http://yoursite.com/tags/git-mirror/"}]},{"title":"从web的历史看起来，说不定会有收获哦！","slug":"从web的历史看起来","date":"2018-01-30T05:05:06.000Z","updated":"2018-07-14T13:00:30.100Z","comments":true,"path":"2018/01/30/从web的历史看起来/","link":"","permalink":"http://yoursite.com/2018/01/30/从web的历史看起来/","excerpt":"","text":"啥都不说先上图 题目有些大，我肯定cover不住，只是最近了有这么个想法，看看能不能梳理一下。 其中多是猜测臆想，见识浅陋还请担当。接下来带领大家看看当年的牛人是有多凶残！！ 别跟老夫说什么语言说什么技术，说什么计算机理论，老夫做东西那都是原创的都是独自发明！！！前期哥都做了啥我是谁？我是大名鼎鼎的蒂姆·伯纳斯-邓，我工作在CERN，这是哪呢？欧洲核子研究组织。 我要做啥呢？刚开始我也不知道，反正我在那里工作着工作着，我就发现了可以把超文本系统与互联网结合在一起, 具体是干啥呢？就是把超文本系统，传输控制协议，域名系统给结合起来。 我为啥发现我要做这个呢？哎，还不是为了那帮不争气的人儿啊？那么的文档，咋才能让大家都共享阅读使用呢？这是个问题！ 我要先准备点儿啥呢？ 话说我知道一个东西叫超文本,可这些东西都是大家自己写的啊？也没个规范啥的，呃😂,这群不省心的人儿啊！不怕，哥无敌啊，于是哥-DD发明了HTML(HyperTextMarkupLunguage)-超文本标记语言,咳咳，你们这群鳖孙往后都用这个标记语言来写你们的文档(一种Markdown的即时感)。不过有点儿low的是哥这是1.0的标记不多先凑合用吧啊。 我还有另外一个东西要做呢，就是得把这群鳖孙写的HTML，显示出来给大家看啊？于是呢，DD哥魔性大发有写了个软件来阅读我发明的html(说白了我其实写的是个html阅读器😎)。 哎呦哟，我好像还忘了另外一个事儿？我写个html阅读器，然后html问价我咋传输呢？哥哥要的可是超文本系统，可以随意跳转查看的哦！嗯，定了，DD哥再给这群鳖孙写个服务器端的软件让他们可以从服务器获取html文档，正好可以用到我另一个发明的uri。坏了，那怎么招也得来个html文档的传输协议吧？嗯，机智如我这个也不能少，哦了，那个DD哥我在造个传输协议吧，有了就它了HTTP(HyperTextTransportProtocol)。哦了，这就彻底ok了！ 终于给那群鳖孙搞定了，那我就可以把这个玩意儿给他们用了，妈妈再也不用担心他们看文档费事儿了。(因为得到处找，共享也不方便)带领大家看看我的第一个website, 是的website我管我发布的那个域名 http://info.cern.ch/。哦我还给我的html阅读器取起了名字叫WorldWideWeb, 可惜后来改名了叫Nexus，来再给你们看看他的源代码，不用说谢谢。 哥做了个伟大的决定我把我发明的所有的东西都无偿开放出来了，为哥点赞吧！向蒂姆·伯纳斯-李，脱帽致敬。(提供岗位并不一定伟大的，但创造岗位的一定是伟大的-不准跟哥叫板) 前期哥都是咋做的哎，创新力爆棚，不要问我为什么就会有这些想法，一句话哥就是厉害。先说说我是咋做的html阅读吧(现在都叫浏览器了，哎，得持续学习啊)其实大家看看我的1.0规范会看到里面其实没啥太多的标签，都是基本常用的，比如a, plaintext,title, ul/li, h2等等。我既然要做规范，那我也得让我的阅读器显示是规范的哦了，走起。(以下纯属臆想，如有冒犯，删，图形库代码以skia(blink使用gui2D库)函数名字为例（就像用canvas画图是一样的）) 那哥这个阅读器得用GUI编程了，可哥最烦的就是这个了。。。呃好吧，我决定了，我要把我的没个标签长啥样都给定死咯，大小，我定，宽度我定，统统都放进长宽固定的盒子里就像乐高似的，为啥，好实现啊。。。就是。。。厉害 a，标签加个下划线就行了，😎可以，这样我只需要调用gui接口的drawText,drawPath就好了，哎，机智 plaintext，就直接drawText就好了，别跟我说什么字体,系统用啥字体我就用啥字体，服不服！还有也别和哥说什么baseline，说什么行高,说什么大小，哎，大小可以说，我都固定就14px吧。 哥用的gui库咋处理，哥都随他，谁让哥这会懒了呢？ 都不听，哦了plaintext标签页搞定了, 哦 对了，听说你们想换色，嘿嘿，哥不支持，谁让这是哥写的浏览器呢。 最后再举一个栗子吧，比如ul列表，嗯，这个吗我给你们个前缀图形吧，就圆吧，黑色，不允许再挑了，要不连这个都没有！ 最后总结一下啊，就是我看到plaintext标签呢，我就drawText,不序调色，不许换字体，总之啥都不许。然后看到a标签呢？我就drawText,和drawPath就好了，其他都不许，没有事件，没有颜色。。。其他同理 请看1.0版预览图 看到没有我的第一个html阅读器就在这样的思想下完成了，yes! 哎我好想少了点儿啥？我的这些标签的展示顺序是啥啊？呵呵，哥会忘么，自上之下，就行了，yes!呵呵空格统统忽略，哥就是任性。 接下来是我怎么拿到html文档了，我按照http协议像后台服务器发起一个tcp连接，然后把http协议内容发送到后台，后台再把html返回给我，我再解析，遍历html每个标签生成一个标签树，然后在我的浏览器按照1的步骤遍历标签树，画出整个html。 ok。 好了该哥的服务器端了呃，这个还要说么？要得，哥的浏览器按照我的http协议向我发起tcp连接我收到内容得解析啊，看看请求的是哪个html，然后在文件系统中找到再返回回去就好了。 大功告成嗯，哥的浏览器，后台服务程序都成功完成了，可以给那帮鳖孙使用了。哎，不对啊，那html文件谁来写呢，呵呵，他们的文档让他们自己写去，前提得用的标记语法！什么嫌我的标记语法太简单了要更多功能，呵呵，哥没时间。 接下来哥发明创造发光发亮的历程啊！！！第一个普遍可用的使用GUI的网页浏览器是Erwise接下来是Mosaic浏览器，紧接着是Netscape这个可以多说几句 这货嫌哥的html标签不够多还添加了几个 他还觉得哥设计的http是无协议，还来了个cookie 更甚至他还来个js,放到浏览器里，方便与用户交互(mmt,哥只是想让大家好好的分享文档啊！！！！，瞎说的，文档也是可以交互的文档啊！) 呃，他还嫌我的协议没有保密性，于是又来了个sslie(浏览器的届无耻流氓，很显然，我也没办法)opera, safari, firefox, chrome等等。 web 到底如何改变了我们生活想必大家都有感受 那么这么厉害的netscape，吃瓜群众现在为啥都看不到了呢？请参考浏览器大战，哥痛心啊呵呵哥才是朕鉴于这么多中的浏览器，他们都有自己随意添加的html标签，以及标签样式也有可能实现的不一样。于是哥牵头成立了w3c-万维网联盟，来制定各种标准，你们都得按照哥说的来做ok？比如html标准，我说有哪些标签就得有哪些，功能是啥样交互是啥样也得听哥的，长啥样么？这个可以交给你们！(当然这不是真的，哥还得考虑各大浏览器厂商的实现，以及一线开发人员的需要) 哎嗨，此时就会有群众问了，我们经常见的css呢？js，cookie是netscape, 那么css呢？惭愧啊，他们这些鳖孙都嫌我设计的样式不好看，我就想说了，看个文档要啥样式，要啥样式？不过我是大度的，好啊，我给html标签加点儿属性，比如：width, 让你来告诉我我的标签有多夸好吧，mmt的，不对啊，你要是不给我，我还得自己设置宽度，又得自己干了，mmt的。啥这样写不好维护？结构与样式分离？ 你咋不上天去呢？ 文档还要维护啊？mmt的。(显然我们doctor 李肯定不是我这样，人肯定是开放包容的态度。。。) 此时有人站出来了, 吃瓜的你们看看去吧你别说，这玩意儿也还凑活着用。 嘚吧嘚吧的也差不多了，web的历史就是这么一步一步的走过来了。小总结一下：我觉得web的核心思想还在于李博士创建的初期思想，共享与开放！而不是现在的某鹅或者其他什么的动不动就屏蔽啥的！他有屏蔽的能力并且做了，那就说明他已经在违背的道路上开始行走了，他若是走的越远，那我们的世界就真越窄。 ps: 下面是附带的关于在构建我的第一版浏览器时对css的一些总结。当我开始思考我的浏览器的实现的时候就发现了一些问题诸如元素怎么计算宽度，怎么定位，怎么布局？在联合css一想发现这些属性的存在都是很有道理的。 接下来我想接着上面我的那版粗糙的浏览器实现讲讲css的一些东西布局，什么是布局，我觉得得是页面的整体框架我们的1.0版本啥都不支持，其实css中目前也没有哪个具体说就是用来布局的除了grid还有flexbox，这两个对布局来说是利器，可是要是有浏览器兼容性问题的话就惨喽。那么flexbox在我们的版本中如何实现呢？我不知道，得先看看flexbox的规范😇，那么我们以前的布局都用的啥呢？都是再用定位来做布局的工作。 定位我们看了我的1.0版本中时不支持定位的就是说标签都是一行一个排列的，显然对于想要，左移一点儿右移一点儿的需求就实现不了了。那么我们定位到底咋来呢？按照规范来说就是使用flow算法来的。分为normal flow、float flow 和 absolutely flow。至于具体就得去啃规范了 这里有某人总结的, 很不错，显然我们若是照着这个算法，咱们的1.0也行啊！！！！ 插一个浮动的问题，加入我想让我的1.0实现文字绕着元素周围布局我该怎么做呢？思考一下我发现让他从常规定位中独立出来反而最好实现的了，我可以给他一个特殊标记，就好比float: left, 那么我就知道他要文字绕着他，那我就把他后面的文字绕着他呗，而且他不参与其他元素的属性计算，但是他还占着父元素的布局位置，只是不参与其他属性计算如高度等。很显然我的想法很幼稚，其实可以参考一下规范到底实现算法是咋样的！！！参见张鑫旭关于float的看法 排版这里的排版是指文字的排版，比如行间距，行高，我们1.0的版本就不支持你们设置这些东西，因为我们就不解析他们啊哈哈哈。这个要实现就好办了，在drawText的时候把这些属性都加上，但是我们是否应该直接给出行间距这个属性呢?显然现在的css中并没有。而是根据line-height, vertical-align等值计算出来的。那么baseline呢 所有的文本排版的时候得有个纵向的对比啊，大家纵向是不是得和谁对齐啊。等等等，这都在这里了 层叠和继承我们第一版没有样式可供你调整的，但是有了css就不一样了，有html作者写的样式有我的浏览器自定义的样式，有css的样式，这么多的样式怎么处理呢，于是就有了层叠和权值的概念。我的浏览器可以根据这些来决定用哪个样式。那么还有我我希望我的所有的字体都是12px大小那么，我总不能每一个标签都去设置一边吧，我的浏览器可以实现一个继承的概念，我解读到顶层的font-size后我就设置他的子标签都继承他。 盒式模型我们的1.0版本在实现时就没考虑这些，我们把宽度，大小统统都定死了。但是我们也可以从这里看到其实我们所有的元素最终都是有个大小的，在我们的版本里，其实我们把所有的元素都放进了相同的盒子，实现省事儿啊！css也是盒式模型的，感觉就和咱们的思想很像所有的元素都放进一个盒子里这样就都是矩形，实现时布局也省事儿啊！只是css的盒子比咱们的有些复杂，他还有margin,padding,border等。但最起码为啥是盒式的我觉得我的理由就很有说服力，好实现，易于理解。 块级元素和行内元素为啥会有这些区别呢？在我们1.0里那全都是块级的，不也好好的啊，不是的，我们的1.0里两个文本是没办法放在一行的，多尴尬，我写了两个plaintext标签一个是‘我’另一个是‘你’，f**k他俩居然还换行。。。因此行内元素的左右就有了。有些标签我们总是不想让他们换行的。。。 块级元素和行内元素的嵌套问题行内元素尽量不要嵌套块级元素语义不符合，而且浏览器的处理也不统一。尽量不要。但是块级元素可以嵌套行内和块级元素，并且这里有个知识点，块级元素内要是块级源，要么是一个ifc，显然这是在说要么里面全是块级要么全是行内元素，可事实我们可以两掺啊？为什么呢？因为若是两掺了，w3c规范规定，会为行内元素再生成一个匿名块级元素的。其实想想也可以的，好比让我们的1.0版来实现的话，显然也是按照规范的来走比较简单，当我们解析了块级元素那么他的内部布局就只有2种方式。 BFC和IFC我们既然有了块级和行内很显然，咱们的1.0版本要想实现他俩，那就意味着我们看到不同标签就应当采用不同的绘制方式，因为我们的块级元素要换行，行内不换行，那我们就对不同的元素采用不同的渲染方式，于是就有了BFC和IFC，但事实也不一定所有的块级元素就会触发BFC,是要满足一定的条件的，在我看来就是我们的渲染方式不止只有BFC和IFC还有一中就是遇到块级元素时默认采取的。 值和单位在我们的1.0里显然我是自己定义的，可若是用css的话，那么css的单位我们如何转换就又一个问题了，他的1px我们是否就要画1px呢？在pc端好像是的，但是在移动端就不一样了。一说到单位，那么我们的浏览器的画布宽度设置多少呢？是否是和设备宽度一致还是说要大一些，这方面我还有太多实践也就没有啥可说的。其实我们这里是有术语的viewport。显然我们的1.0升级时也得考虑这个问题，并且还有单位可不止只有px哦，rem,em,pt等等，我们在实现时又得考虑哪些问题呢？我是蒙了，再说吧！ 参考: css wiki html wiki 浏览器大战 http wiki netscape","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"web历史","slug":"web历史","permalink":"http://yoursite.com/tags/web历史/"}]},{"title":"关闭迭代器是一个抽象漏洞","slug":"iterator","date":"2018-01-21T09:30:06.000Z","updated":"2018-07-14T13:00:30.043Z","comments":true,"path":"2018/01/21/iterator/","link":"","permalink":"http://yoursite.com/2018/01/21/iterator/","excerpt":"","text":"原文地址 先上图 先来普及一下抽象漏洞wiki抽象漏洞总结一小下：抽象漏洞告诉我们出来混早晚要还的，无论你怎么去屏蔽复杂，怎么去抽象，总是不完整的总是会有漏洞的。 迭代器和可迭代对象的一个概述在js中，迭代器和可迭代对象是顺序访问数据的抽象层接口。我们可以在数组或者优先级队列中看到他们。 一个迭代器就是一个拥有next方法的对象。当你调用next()的时候，他会返回一个Plain Old Javascript Object。 这个返回值拥有done属性，当done值是false的时候，这个返回值还会有个value属性，数据就是value属性中的值。反而如果done是true，那么就应该不会有value属性。 迭代器不可以是async/await等异步方法 迭代器被设计为一个有状态的对象：重复调用next方法通常能获取到一系列的数据直到done为止。这里有一个栗子: jsbin123456789101112131415161718192021222324252627282930const iCountdown = &#123; value: 10, done: false, next() &#123; this.done = this.done || this.value &lt; 0; if (this.done) &#123; return &#123; done: true &#125;; &#125; else &#123; return &#123; done: false, value: this.value-- &#125;; &#125; &#125;&#125;;iCountdown.next() //=&gt; &#123; done: false, value: 10 &#125;iCountdown.next() //=&gt; &#123; done: false, value: 9 &#125;iCountdown.next() //=&gt; &#123; done: false, value: 8 &#125;// ...iCountdown.next() //=&gt; &#123; done: false, value: 1 &#125;iCountdown.next() //=&gt; &#123; done: true &#125; 可迭代对象是一个拥有[Symbol.iterator]方法的对象。当调用这个方法的时候他会返回一个迭代器。举个栗子：jsbin12345678910111213141516171819const countdown = &#123; [Symbol.iterator]() &#123; const iterator = &#123; value: 10, done: false, next() &#123; this.done = this.done || this.value &lt; 0; if (this.done) &#123; return &#123; done: true &#125;; &#125; else &#123; return &#123; done: false, value: this.value-- &#125;; &#125; &#125; &#125;; return iterator; &#125;&#125;; 我们可以使用for … of 来对这个对象进行迭代123for (const count of countdown) &#123; console.log(count);&#125; 或者我们还可以对他进行解构12345678910const [ten, nine, eight, ...rest] = countdown;ten //=&gt; 10nine //=&gt; 9eight //=&gt; 8rest //=&gt; [7, 6, 5, 4, 3, 2, 1] 接下来让我们看看如何对一个文件进行迭代？在看之前我们得先想想node有对文件有按行读的同步方法(上面我们提过了，迭代器只能使用同步方法)么？我找了一圈发现了一个异步读的方法，readline，这个包可以对文件流进行异步按行读取。1234567891011const readline = require(&apos;readline&apos;);const fs = require(&apos;fs&apos;);const rl = readline.createInterface(&#123; input: fs.createReadStream(&apos;sample.txt&apos;), crlfDelay: Infinity&#125;);rl.on(&apos;line&apos;, (line) =&gt; &#123; console.log(`Line from file: $&#123;line&#125;`);&#125;); 可以肯定的是node本身没有提供同步的按行读取文件的方法，那么我们就只能利用node的同步读方法来模拟按行读取了。每次读取一部分然后检查换行符，fs.readSync(fd, buffer, offset, length, position)。当然这里已然有一个包了‘n-readlines’。参见 好了这下我们可以看看对文件的按行迭代了1234567891011121314151617181920212223242526const fs = require(&apos;fs&apos;);const lineByLine = require(&apos;n-readlines&apos;);function lines (path) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; done: false, fileDescriptor: new lineByLine(path), next() &#123; if (this.done) return &#123; done: true &#125;; const line = this.fileDescriptor.next(); this.done = !line; if (this.done) &#123; this.fileDescriptor.fd &amp;&amp; fs.closeSync(this.fileDescriptor.fd); return &#123; done: true &#125;; &#125; else &#123; return &#123; done: false, value: line &#125;; &#125; &#125; &#125;; &#125; &#125;;&#125; 当我们想要对一个文件进行按行迭代时，我们就可以这么使用lines(‘./README.md’); 当我们调用了Symbol.iterator我们就会得到一个文件的迭代器。 如下123for (const line of lines(&apos;./iter.js&apos;)) &#123; console.log(line.toString());&#125; 当我们把文件内容都迭代的读取完了以后，我们自然会关闭了文件。 可是若是我们只想读取第一行呢？1234for (const line of lines(&apos;./iter.js&apos;)) &#123; console.log(line.toString()); break;&#125; 这样我们就会有一个问题了，就是该如何关闭文件。我们上面的代码是在读完以后回去检查文件是否关闭然后关闭。可是当我们只读取了一行就退出时，我们的文件时未关闭的。。。 这肯定是不好的。并且上面也不是唯一的情况，有时我们可能使用迭代器去管理我们的异步任务，比如我们通过指定端口和其他进程交互，很显然当我们完成了交互时我们会显式的去关闭指定的端口，我们可不想在使用中却被gc给收集了。 通过上面的描述，很明显我们需要一个能显式关闭迭代器的方法，以便迭代器能够释放他们所占用的资源。接下来让我们做一些尝试。 幸运的是，这里确实有这么一种机制来关闭迭代器。他设计的意图就是用来处理那些拥有各种各样的资源的迭代器，好比是文件描述符，一个打开的端口，大量的内存等等。 迭代器需要释放资源这是个问题，js为我们提供的机制来解决这些问题。但是我们依然先采用自己的方式来试试。 我们来看看 123456789101112131415161718192021222324252627const countdown = &#123; [Symbol.iterator]() &#123; const iterator = &#123; value: 10, done: false, next() &#123; this.done = this.done || this.value &lt; 0; if (this.done) &#123; return &#123; done: true &#125;; &#125; else &#123; return &#123; done: false, value: this.value-- &#125;; &#125; &#125;, return(value) &#123; this.done = true; if (arguments.length === 1) &#123; return &#123; done: true, value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; return iterator; &#125;&#125;; 永远都会被调用的return我们在前面看到了迭代器的主要方法next,其实这里还有一个return方法，它的签名时return(optionalValue),它的使用如下 当optionalValue为空时他应当返回{ done: true }， 否则返回{ done: true, value: optionalValue } 此后，再调用next方法时迭代器应当永远都返回 { done: true } 我们再回头看看我们的countdown,来实现一下.return123456789101112131415161718192021222324252627const countdown = &#123; [Symbol.iterator]() &#123; const iterator = &#123; value: 10, done: false, next() &#123; this.done = this.done || this.value &lt; 0; if (this.done) &#123; return &#123; done: true &#125;; &#125; else &#123; return &#123; done: false, value: this.value-- &#125;; &#125; &#125;, return(value) &#123; this.done = true; if (arguments.length === 1) &#123; return &#123; done: true, value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; return iterator; &#125;&#125;; 这里我们看到了一些重复的逻辑，但他们是有用的，尤其是释放资源时，让我们再整理一下123456789101112131415161718192021222324252627const countdown = &#123; [Symbol.iterator]() &#123; const iterator = &#123; value: 10, done: false, next() &#123; if (this.done) &#123; return &#123; done: true &#125;; &#125; else if (this.value &lt; 0) &#123; return this.return(); &#125; else &#123; return &#123; done: false, value: this.value-- &#125;; &#125; &#125;, return(value) &#123; this.done = true; if (arguments.length === 1) &#123; return &#123; done: true, value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; return iterator; &#125;&#125;; 现在我们可以看到如何编写一个在耗尽整个迭代器之前打破的循环：1234567891011121314count iCountdown = countdown[Symbol.iterator]();while (true) &#123; const &#123; done, value: count &#125; = iCountdown.next(); if (done) break; console.log(count); if (count === 6) &#123; iCountdown.return(); break; &#125;&#125; 调用return可以保证我们的iCountdown能够释放资源。那么如果for…of也是这么做的话(先调用next,最后调用return)那就完美了。我们可以加一个输出1234567891011return(value) &#123; if (!this.done) &#123; console.log(&apos;Return to Forever&apos;); this.done = true; &#125; if (arguments.length === 1) &#123; return &#123; done: true, value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125;&#125; 接着可以尝试1234567891011for (const count of countdown) &#123; console.log(count); if (count === 6) break;&#125; //=&gt; 10 9 8 7 6 Return to Forever 并且12const [ten, nine, eight] = countdown; //=&gt; Return to Forever 整体jsbin 当我们没有消费整个迭代器时,就是说中途break，js会自动调用return方法jsbin 我们也可以看出来return方法是可选的，若是实现了js就会去自动调用，没有则不回去调用。 调用return也不总是那么简单看了上面，我们就会为我们的可迭代对象实现return方法尤其是那些需要释放资源的迭代对象，以便js为我们自动调用。 来看一个比较棘手的问题，若是我们就像构造一个函数来返回迭代对象的第一个元素(如果有的话)，如下12345function first (iterable) &#123; const [value] = iterable; return value;&#125; 解构会替我们把迭代对象的迭代器给关掉。当然如果我们高兴我们也可以自己来手动实现123456function first (iterable) &#123; const iterator = iterable[Symbol.iterator](); const &#123; done, value &#125; = iterator.next(); if (!done) return value;&#125; 但我们可能会忽略了关闭我们所提取的迭代器，所以我们又必须得这么做：12345678910function first (iterable) &#123; const iterator = iterable[Symbol.iterator](); const &#123; done, value &#125; = iterator.next(); if (typeof iterator.return === &apos;function&apos;) &#123; iterator.return(); &#125; if (!done) return value;&#125; 一个很好的启发是，我们可以使用JavaScript的内置功能来关闭从可迭代对象中提取的迭代器。 而我们也知道解构会为我们关闭迭代器。我们也知道打断for … of 循环也会关闭迭代器， 不管我们是否消费了整个迭代器。 还有上面所说的对于在一个生成器内从for … of 中yield数据也是成立的。举个栗子，我们可以看看下面的函数mapWith12345function * mapWith (mapFn, iterable) &#123; for (const value of iterable) &#123; yield mapFn(value); &#125;&#125; 这是个generator函数接收了一个迭代对象作为参数，并且返回一个可迭代对象。当我消耗了返回的迭代对象，那么内部的迭代对象也会被消耗掉，可若是我们中途断了，又会如何呢？jsbin123456const countdownInWords = mapWith(n =&gt; words[n], countdown);for (const word of countdownInWords) &#123; break;&#125;//=&gt; Return to Forever 是的完全ok js的内置功能又帮了我们, 而且在这里我们也看到了，生成器的返回值是可以和for…of一起使用的。 但不幸的是我们也不能总是成功 更多关于显示关闭迭代器的栗子zipWith 函数会接受多个可迭代对象，并且把他们’zip’到一起返回，若是把他也写成一个生成器函数，我们是无法依靠js的内置功能去关闭所有的迭代器的。来看1234567891011121314151617181920212223242526function * zipWith (zipper, ...iterables) &#123; const iterators = iterables.map(i =&gt; i[Symbol.iterator]()); while (true) &#123; const pairs = iterators.map(j =&gt; j.next()), dones = pairs.map(p =&gt; p.done), values = pairs.map(p =&gt; p.value); if (dones.indexOf(true) &gt;= 0) &#123; for (const iterator of iterators) &#123; if (typeof iterator.return === &apos;function&apos;) &#123; iterator.return(); &#125; &#125; return; &#125; yield zipper(...values); &#125;&#125;const fewWords = [&apos;alper&apos;, &apos;bethe&apos;, &apos;gamow&apos;];for (const pair of zipWith((l, r) =&gt; [l, r], countdown, fewWords)) &#123; //... diddley&#125; //=&gt; Return to Forever 这段代码我们使用了显式关闭的方法，当所有迭代对象中的任何一个消耗尽了我们就显示关闭所有的迭代器(jsbin)。但是若是我们提前终止了外部循环，sorry是没人来擦屁股的(jsbin)。12const [[firstCount, firstWord]] = zipWith((l, r) =&gt; [l, r], countdown, fewWords); //=&gt; 试过栗子就知道了，没有Return to Forever输出，尽管js的内置功能帮我们把generator返回的迭代器关闭了，但其他的都没有关闭。但是也很明显，我们的迭代器和generator返回的迭代器毛关系都没有，他哪知道啥时候关闭啊。 根据 jaffathecake的建议，我们可以这么来1234567891011121314151617181920212223242526272829function * zipWith (zipper, ...iterables) &#123; const iterators = iterables.map(i =&gt; i[Symbol.iterator]()); try &#123; while (true) &#123; const pairs = iterators.map(j =&gt; j.next()), dones = pairs.map(p =&gt; p.done), values = pairs.map(p =&gt; p.value); if (dones.indexOf(true) &gt;= 0) &#123; for (const iterator of iterators) &#123; if (typeof iterator.return === &apos;function&apos;) &#123; iterator.return(); &#125; &#125; return; &#125; yield zipper(...values); &#125; &#125; finally &#123; for (const iterator of iterators) &#123; if (typeof iterator.return === &apos;function&apos;) &#123; iterator.return(); &#125; &#125; &#125;&#125; 这个时候我们要是关闭了那肯定可以啊，这就是借助了，try/catch/finally, 就不试了，大家可以试试 还有另外一招我们也可以实现上述目的123456789101112131415161718192021222324252627282930313233343536373839function zipWith (zipper, ...iterables) &#123; return &#123; [Symbol.iterator]() &#123; return &#123; done: false, iterators: iterables.map(i =&gt; i[Symbol.iterator]()), zipper, next() &#123; const pairs = this.iterators.map(j =&gt; j.next()), dones = pairs.map(p =&gt; p.done), values = pairs.map(p =&gt; p.value); if (dones.indexOf(true) &gt;= 0) &#123; return this.return(); &#125; else &#123; return &#123; done: false, value: this.zipper(...values) &#125;; &#125; &#125;, return(optionalValue) &#123; if (!this.done) &#123; this.done = true; for (const iterable of this.iterators) &#123; if (typeof iterable.return === &apos;function&apos;) &#123; iterable.return(); &#125; &#125; &#125; if (arguments.length === 1) &#123; return &#123; done: true, value:optionalValue &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; &#125; &#125;;&#125; jsbin, 这相当于显示实现了一个可迭代对象。无论哪种方式，我们都必须明确地安排这样的事情，当它自己的迭代器关闭时，zipWith关闭所有的迭代器。 到了这步我们可以来说说迭代器和生成器了，生成器可以看做对coder友好的迭代器。因为迭代器虽然很强大但是需要我们自己去维护迭代器的状态，而生成器则无须我们来维护状态，他会替我们去维护，而我们只需要告诉生成器如何产生数据就好了。很显然生成器的返回值就是个迭代器无疑了。 可迭代对象，可迭代对象就是那些实现了Symbol.iterator这个方法的对象，就是说若是调用Symbol.iterator这个方法会返回一个迭代器。 那么什么语法可以用于迭代器呢？ for-of 循环， 我们见过了 spread syntax, 意味着我们可以这么使用 1const a = &#123; ...iterable &#125; yield 我们知道yield 后面跟的是另一个生成器，事实他还可以跟一个可迭代对象 12345function* gen() &#123; yield* [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];&#125;gen().next(); // &#123; value: &quot;a&quot;, done: false &#125; destructuring assignment解构我们也见过了 怎么样突然发现可迭代对象居然这么厉害了吧 总结一小下生成器就是coder友好版的迭代器，而可迭代对象则是实现了Symbol.iterator方法的对象且该方法返回一个迭代器。而且迭代器可以使用的语法，显然生成器的返回值当然也可以哦。 好了我们言归正传，接上话。 隐藏的功能我们已经看到了，迭代器需要关闭。我们还知道迭代器的关闭是不可见的。有个return 方法需要我们去实现，并且需要被调用。但通常我们都是把迭代器和生成器，for … of循环或者解构一起使用，他们把调用return这件事给我们隐藏了。 这种有意识的设计让我们对迭代器的学习和使用变得容易。当我们看到下面的代码12345678function * take (numberToTake, iterable) &#123; const iterator = iterable[Symbol.iterator](); for (let i = 0; i &lt; numberToTake; ++i) &#123; const &#123; done, value &#125; = iterator.next(); if (!done) yield value; &#125;&#125; 我们可以很快的明白这段代码是要干啥了，但是下面这段代码是不是更好呢:1234567891011function * take (numberToTake, iterable) &#123; let i = 0; for (const value of iterable) &#123; if (i++ === numberToTake) &#123; return; &#125; else &#123; yield value; &#125; &#125;&#125; 但这里有一个关于显式还是隐式的永恒争论点123456789101112131415function * take (numberToTake, iterable) &#123; const iterator = iterable[Symbol.iterator](); try &#123; for (let i = 0; i &lt; numberToTake; ++i) &#123; const &#123; done, value &#125; = iterator.next(); if (!done) yield value; &#125; &#125; finally &#123; if (typeof iterator.return === &apos;function&apos;) &#123; iterator.return(); &#125; &#125;&#125; for … of 是不是更优雅？若是for(let i = 0; i &lt; numberToTake; ++i)更快呢？ try…finally是不是更好呢？因为他显式的关闭了迭代器。又或者他是不好的因为他引进了额外的代码？ 所有的所有我觉得又回到了那句话：写代码写程序没有最好的，都是取舍问题。你们觉得呢？虽然我还做不到，因为取舍很难确定，因为有的时候是自己写的代码总想找点儿理由来维护他。 chesterton’s 的围栏和抽象漏洞在改造事物方面，不同于改变事物，有一个简单朴素的原则;这个原则我们或许可以称之为悖论。在这种情况下存在某种制度或定理;为了简单起见，我们可以这么举例，有一个围栏或者大门设置在了路上。更现代的改革者到了这里并且说“我看不见他的作用，把他清理了吧”，对于更有智慧的改革者会说“如果你看不见他的用处，我是不会让你清理的，再去想想吧，等你想明白了，并且告诉我你看到了他的用处，那么我就会允许你把他彻底毁了。” - G.K.Chesterton …省略一万字看原文吧总结一小下就是：无论我们是函数式或者是OO，还是其他的，我们都会有像迭代器一样的抽象漏洞。当我们在大多数情况下使用他是好的，当我们到达使用的边缘的时候就会出问题。因此我们需要了解他的底层原理，若是不了解就不会知道到底除了啥问题。 结尾我们有时候还是需要去了解一些底层的问题，否则有时候会真的很无能为力，尤其是出错的时候，我们可以使用抽象去减少一些复杂度，但这不代表我们完全不需要去了解抽象。 reddi讨论 大大的总结一下第一次听说抽象漏洞，学习了，非不证自明的东西总是会存在漏洞的。也加深了对迭代器，迭代对象，生成器的理解。其实还有一个更重要的就是，资源的关闭，我们的资源是有限的，一定要有收尾操作。 再来列举一下迭代对象可以使用的语法，生成器(准确说他的返回值)也可以哦 for … of 解构赋值 rest syntax yield * 迭代对象的三个方法 next return (可选) throw (可选) js 会在for… of, 解构赋值，之后为我们自动调用return，当然是在没有完全消费掉数据的时候才会为我们调用。注意释放资源。我们可以利用这个功能。 在使用generator和迭代器的过程中要注意释放资源。能用js内置的最好不能就try/catch/finally","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"iterator","slug":"iterator","permalink":"http://yoursite.com/tags/iterator/"},{"name":"iterable","slug":"iterable","permalink":"http://yoursite.com/tags/iterable/"}]},{"title":"node，setImmeidate, setTimeout, nextTick你真的了解么？","slug":"node定时器相关详解","date":"2018-01-10T12:27:18.000Z","updated":"2018-07-14T13:00:30.044Z","comments":true,"path":"2018/01/10/node定时器相关详解/","link":"","permalink":"http://yoursite.com/2018/01/10/node定时器相关详解/","excerpt":"","text":"先来温习一下event loop中的几个phase可参见我的上篇文章libuv概览 timers: 这个phase是来检查定时器是否到期的，并执行的 poll(I/O): 这个是用来监听fd的事件的，比如socket的可读，可写，文件的可读可等 check: 当事件循环被I/O阻塞结束之后立刻调用check handle的回调。本质上他是和prepare phase(在循环被I/O阻塞之前（right before the loop will block for I/O）prepare回调就会立即被调用) 相反的。 为什么会强调上述几个阶段呢？可以参见一下node官网对于event loop的解释 node的定时器setTimeout,setInterval是在timers 阶段检查是否过期执行的 node的setImmediate 是在check阶段执行的 其他的一些监听文件描述符而执行的cb是在poll(I/O)阶段执行的 其实我们可以总解一下js代码的执行时间有哪些？ event loop 开始之前的代码 event loop 中各个phase执行的代码也就是说node的js代码会在两种情况下执行(纯属自己的看法) 接下来就是解析一下他们的执行顺序问题 setTimeout(n) VS setImmediate setImmediate 一定会在本轮event loop内的check 阶段执行，若是check阶段已经错过了，那就只能在下一轮的check阶段执行了。参见上篇文章)，见下图 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ 可以看出来在同一次event loop内，timers阶段是在check阶段之前的,也就是说若是在同一个event loop内既有定时器到期又有setImmediate那肯定是setTimeout先执行。若不在一个event loop内那就不好说了，要具体情况具体分析了。那么setTimeout(n) 和 setImmediate的执行顺序到底是啥？ 当setTimeout与setImmediate在同一时间执行且是在event loop之前执行的设置代码, 又且 n &lt;= t(t是当执行event loop时setTimeout刚好过期的那个时间)此时就相当于 在第一次event loop内既有setTimeout 过期又有 setImmediate，显然 setTimeout先执行。 1234567891011// test.jssetTimeout(() =&gt; &#123; console.log(&apos;setTimeout&apos;);&#125;, 1)setImmediate(() =&gt; &#123; console.log(&apos;setImmediate&apos;);&#125;);// 假设我的t 是2，那么输出就是# setTimeout# setImmediate 当setTimeout与setImmediate在同一时间执行且是在event loop之前执行的设置代码, 又且 n &gt; t(t是当执行event loop时setTimeout刚好过期的那个时间)此时就相当于 在第一次event loop内只有 setImmediate，setTimeout的过期只有在接下来的event loop内被检查到了显然 setImmediate先执行。代码同上，把n 换成 大于2的时间。 t的抉择就完全取决于机器的性能了而且在此处还有一个问题就是node中setTimeout最小时间1毫秒，见源码如下 1234567891011//lib/internal/timers.js~line#34after *= 1; // coalesce to number or NaNif (!(after &gt;= 1 &amp;&amp; after &lt;= TIMEOUT_MAX)) &#123; if (after &gt; TIMEOUT_MAX) &#123; process.emitWarning(`$&#123;after&#125; does not fit into` + &apos; a 32-bit signed integer.&apos; + &apos;\\nTimeout duration was set to 1.&apos;, &apos;TimeoutOverflowWarning&apos;); &#125; after = 1; // schedule on next tick, follows browser behavior&#125; 也就是说你设置0，最下也是1，那么就是说若你的机器性能很好，在1毫秒之前就开始执行event loop了，那么将会永远只看到setImmediate在setTimeout之前执行了。 前面说的都是在event loop之前设置，那么在event loop的期间执行js代码时设置的呢（我们只说同时设置的执行顺序）？(参见我前面的关于js代码的执行时机解释) timers阶段设置123456789setTimeout(() =&gt; &#123; // 1 console.log(&apos;外层timeout&apos;); setTimeout(() =&gt; &#123; // 2 console.log(&apos;set timeout in timeout&apos;); &#125;); setImmediate(() =&gt; &#123; // 3 console.log(&apos;set immediate in timeout&apos;); &#125;);&#125;); 1的回调是在timers阶段执行的，而setTimeout内部的定时器一定是不可能在本次event loop的timers阶段执行的(分析后面再说)，那就是说2的回调一定是在本次event loop之后的某次loop中的timers阶段执行的，可我们也要注意，本次loop的check阶段还没执行，因此就很明显了，3的回调会在本次loop的check阶段执行，因此得到总结在timer阶段设置的setTimeout和setImmediate一定是setImmediate先执行。 I/O callbacks, idle, prepare, poll, 同理这些阶段也一定是setImmediate先执行，我们最常处于的阶段可能就是poll阶段了，因为这是描述符事件回调的触发阶段，在这个阶段，本轮loop的timers阶段已经执行过了，所以setTimeout,一定是后面的loop timers阶段执行，而本轮loop的check阶段还没有执行，因此在这些阶段设置的setImmediate可以在本轮loop得到执行，所以在timer阶段之后，check阶段之前设置的setTimeout和setImmediate一定是setImmediate先执行。 12345678910const fs = require(&apos;fs&apos;);fs.readFile(&apos;./test.js&apos;, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;set timeout in poll phase&apos;); &#125;); setImmediate(() =&gt; &#123; console.log(&apos;set immediate in poll phase&apos;); &#125;);&#125;); check阶段，在本轮设置的setTimeout和setImmediate执行顺序与在event loop执行之前设置的是一样的，执行顺序不定取决于设置的超时时间t(原因同在event loop执行之前设置的是一样，甚至可以说两者就是可以看做是等同的)。因为在这一阶段设置的setImmediate是不会在本轮check阶段执行的，同理setTimeout也是没办法在本轮执行的。 总的可以用一个流程图来概括 接下来 process.nextTick VS setImmediate事实上这两者是没有可比的 process.nextTick的实现是基于v8 MicroTask(是在当前js call stack 中没有可执行代码才会执行的队列,低于js call stack 代码，但高于事件循环，浏览器中也是如此可参见)机制的。不属于event loop(v8 microtask是怎么和node结合起来的还没看明白失败啊)但是可以确定是nextTick走的是v8的mircotasks机制，且在当前js calk stack 结束后event loop 继续进行之前调用，也就是说要是写一个递归nextTick调用会把整个node阻塞掉 12345678910setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;);&#125;);function a() &#123; process.nextTick(() =&gt; &#123; console.log(&apos;set nextTick&apos;); a(); &#125;);&#125;a(); 可以试一下上面的代码, 你会发现这就是无限调用了。还有我们所熟知的promise也走的是v8 microtask机制(并且Promise使用时v8实现的promise)。那么同理，promise的then的回调和nextTick中的回调也是由v8 microtask机制来确定执行的，也是与event loop 无关的。当然这在promiseA+规范里面也是有相应描述的。为了测试我们可以执行以下代码 1234567891011121314const promise = Promise.resolve(234)setImmediate(() =&gt; &#123; console.log(&apos;immediate&apos;);&#125;);testPromise();function testPromise() &#123; promise = promise.then(() =&gt; &#123; console.log(&apos;promise&apos;); testPromise(); &#125;);&#125; 是的结果和执行pross.nextTick是一样的event loop被阻塞了。 在源代码里我们也可以看到见下主要代码在/lib/internal/procss/next_tick.js(这里有太多的逻辑没搞明白只是知道了一个大概) 我们所创建的nextTick都是由这个全局的NextTickQueue来管理的，当我们执行nextTick,就push进去一个TickObject 执行nextTick的逻辑如下 接下来就是触发nextTickQueue里面的tickObject的执行了 在接下来就是设置_tickCallback（_tickDomainCallback是使用了Domain的版本）这个回调的执行时机了 失败的地方就来了，我跟到C++代码里面后就完全没找到_tickCallback的具体执行时机的设置了，而且这里面也有太多的逻辑了，完全不知道是在干啥，还有待慢慢揭秘求高手。 setImmediate是基于libuv的event loop的。 到了这里我可以知道了nextTick一定是先执行的（同时设置） 总结一下 当同时设置nextTick, setImmediate, setTimeout时一定是nextTick先执行，nextTick不属于event loop属于v8的micro tasks setImmediate, setTimeout是属于event loop的，但是执行的阶段不同。 nextTick的promise的回调执行是在event loop继续执行之前的，也就是说他们的调用是会阻塞event loop的。也就是说在使用nextTick和promise编写递归调用或者大循环时要小心阻塞event loop 在setImmediate, setTimeout设置再次设置自己时，一定不会再本次loop中执行的 在浏览器中我猜测setTimeout和promise, MicroTasks也是这样的 最后再来点儿，对于setTimeout和setImmediate的代码分析，来具体解释为什么4成立 setTimeout当我们执行setTimeout时，node会创建一个Timeout对象来存储 Timeout具体属性见下 其中_idleStart很重要，是指这个定时器的起始时间，比如在10秒的时候设置了一个40秒的定时器，那么到期的时候就检查这个now - _idleStart 是否大于定时的40秒，而这个时间应当是程序启动后经过的毫秒数。（纯属个人猜测）生成了定时器对象后，怎么组织管理就是个问题了，定时器在node中是以对象加链表来组织的，相同时间的定时器会被放到同一个链表中，如都是定时的40毫秒，但设置的时间不同，那么他们就会被放到同一个list中,见下图 12345678910111213141516171819// ╔════ &gt; Object Map// ║// ╠══// ║ refedLists: &#123; &apos;40&apos;: &#123; &#125;, &apos;320&apos;: &#123; etc &#125; &#125; (keys of millisecond duration)// ╚══ ┌─────────┘// │// ╔══ │// ║ TimersList &#123; _idleNext: &#123; &#125;, _idlePrev: (self), _timer: (TimerWrap) &#125;// ║ ┌────────────────┘// ║ ╔══ │ ^// ║ ║ &#123; _idleNext: &#123; &#125;, _idlePrev: &#123; &#125;, _onTimeout: (callback) &#125;// ║ ║ ┌───────────┘// ║ ║ │ ^// ║ ║ &#123; _idleNext: &#123; etc &#125;, _idlePrev: &#123; &#125;, _onTimeout: (callback) &#125;// ╠══ ╠══// ║ ║// ║ ╚════ &gt; Actual JavaScript timeouts// ║// ╚════ &gt; Linked List 插入的流程如下 初始化TimerList的如下 在初始化一个TimersList时就会以他所属的过期的时间设置一个libuv的定时器，到期后处理自己这个list中node定时器，若是，还有未到期的，那么就继续设置libuv的定时器接下来就是定时器到期后怎么处理了 上面我的截图里说的语句不通了激动了，从上面可以看到，我们新设置的相同的定时器尤其是针对setTimeout(0)(虽然我们不可能有零这种情况),其实我想说的是，假设我们设置了两个1msecs的定时器，见代码吧 123456789setTimeout(() =&gt; &#123; // 1 console.log(1); setTimeout(() =&gt; &#123; // 2 console.log(2); &#125;); setImmediate(() =&gt; &#123; // 3 console.log(3); &#125;)&#125;) 上述代码1，2的过期时间都是1，所以他们在同一个timerList中，还有我们看到前面的描述，当我们是while去处理timerlist的，根据前面的讲述我们知道3一定比2先输出，但是我们是while处理timerlist的，为什么没有判断2过期呢，我就发现了，因为判断过期取的是now - timer._idleStart, 而这个now是在定时器cb执之前取的，而timer._idleStart是在setTimeout时设置的，那就意味着，2的_idleStart 一定比1的到期是去的now 大，那就很明显了，无论如何都是是无法判断2过期(在本次loop期间判断2过期)了，即使是下面的代码也不行 123456789101112 setTimeout(() =&gt; &#123; // 1 console.log(1); setTimeout(() =&gt; &#123; // 2 console.log(2); &#125;); for(let i = 0; i &lt; 100e100; i ++) &#123; // 1msec的时间绝对有了，那么是不是在本轮loop就可以判断timer过期呢，不会 let c = 0; &#125; setImmediate(() =&gt; &#123; // 3 console.log(3); &#125;)&#125;) 定时器的整体组织方式就是为了方便管理，减少底层真实定时器的使用。 setImmediate那么setImmediate内设置setImmediate呢？看代码吧，immediate是通过一个全局的list来管理的 调用setImmediate Immediate构造函数的处理 加下来就是处理 check阶段处理immediate了 上图解释的很清楚了，这就告诉了我们另一个问题，在同一时期设置的setImmeidate会放到同一个队列，并且在一次loop check阶段就把所有的immediate回调给执行了。 123456789101112131415setTimeout(() =&gt; &#123; // 1 console.log(1); setTimeout(() =&gt; &#123; // 2 console.log(2); &#125;); for(let i = 0; i &lt; 10e10; i++) &#123; let c = 0; &#125; // 上面的那个肯定过期了 for(let i = 0; i &lt; 100; i++&gt;) &#123; setImmediate(() =&gt; &#123; // 3 console.log(3); &#125;) &#125;&#125;) 上面的代码我们的2在1的回调执行之后一定是过期的，那么若是同一时间设置的setImmediate不会在同一个loop的check阶段那么，我们的2输出之后就一定会有3，可以执行一下是没有的，也就证明了我们上面的源码分析是正确的。 最终总结打完收工，源码阅读很考验啊，应当先知道代码的最终功能是什么？你想要知道的问题是什么？然后再去跟代码，一定要先找到函数入口，在就是一步一步调试是很有用的，等着看看怎么调试v8以及node的c++代码势要把microtasks也高明白了。 参考 task, micro tasks node source code event loop","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"setTimeout","slug":"setTimeout","permalink":"http://yoursite.com/tags/setTimeout/"},{"name":"setInterval","slug":"setInterval","permalink":"http://yoursite.com/tags/setInterval/"},{"name":"setImmediate","slug":"setImmediate","permalink":"http://yoursite.com/tags/setImmediate/"},{"name":"process.nextTick","slug":"process-nextTick","permalink":"http://yoursite.com/tags/process-nextTick/"}]},{"title":"libuv设计概览","slug":"libuv概览","date":"2018-01-10T02:29:28.000Z","updated":"2018-07-14T13:00:30.043Z","comments":true,"path":"2018/01/10/libuv概览/","link":"","permalink":"http://yoursite.com/2018/01/10/libuv概览/","excerpt":"","text":"先上图 设计概览libuv是一个跨平台的异步事件库。libuv对于不同的I/O轮询机制提供了很多的抽象。例如：handle和stream是对socket和其他实体的高等抽象。还提供了跨平台的文件I / O和线程功能。以及一些其他的功能。此处图一张： handles 和requestslibuv给用户提供了两个抽象用于和事件循环进行交互： handle和request。handle表示长期存在的对象，当它激活时，它是用来处理特定的操作。例如： 当激活时，prepare handle 会在每次循环时调用一次他的回调。 当每次有新的连接到来时tcp handle就会调用他的连接回调。 request是用来表示短期存在的操作。这些操作可以通过一个handle来执行：写request通常是用来在一个handle上写数据；或者是独立于handle的： getaddrinfo rquest就不需要一个handle可以直接在事件循环上执行。 I/O 循环I/O(或者)循环是libuv的核心。它用来建立所有的I/O操作的内容，并且这意味着I/O 循环是一个单线程的。当然当我们在多个线程上运行的时候就可以跑多个事件循环了。libuv事件循环（或涉及循环或handle的任何其他API）就不是线程安全的，除非另有说明。事件循环遵循常见的单线程异步I/O方法：所有（网络）I/O在非阻塞套接字上执行，使用给定平台上可用的最佳机制：epoll on linux, kqueue on OSX其他等等。作为循环迭代的一部分，循环将阻塞等待已经添加到轮询器的套接字上的I/O活动，并且将触发回调来指示套接字条件（可读，可写的挂断），因此句柄可以读，写或执行期望的I/O操作。见图 loop的now会被更新，在循环开始前，循环会缓存当前的时间以减少和和时间相关的系统调用。 如果循环处于活动状态，则开始迭代，否则循环将立即退出。 那么，什么时候循环被认为是活着的呢？ 如果一个循环有处于激活状态或者被ref的handle，或者活动的请求或者正在被关闭的句柄，它就被认为是活着的。 运行(due)到期的定时器。所有活跃的的定时器如果他们的时间在now之前就会运行他们的cb。 处于等待的回调被调用。虽然所有的I/O回调都会在循环之后立即调用，但是还有这样的一些例子，比如一个回调被延迟到下一此循环了。因此如果上次循环有延时的I/O回调会在这个时间点调用。 Idle handle callbacks are called. Despite the unfortunate name, idle handles are run on every loop iteration, if they are active. prepare handle 回调被调用。在循环被I/O阻塞之前（right before the loop will block for I/O）prepare回调就会立即被调用。 轮询超时时间计算。在循环被阻塞之前计算他会被阻塞多久。这里有一些计算的规则： 如果UV_RUN_NOWAIT标志为true则timeout是0。 若果循环将要停止(uv_stop())，timeout是0。 若果没有处于活跃的handle或者request，timeout是0。 若果有idle handles处于活跃状态，timeout是0。 若果有等待被关闭的handle,timeout是0。 若果上述条件没一个满足的，就挑选一个最近的定时器的时间。如果连timer都没有那么timeout 是无限的(infinity)。 循环被I/O阻塞。在这一步，循环会被阻塞一段时间而这个时间就是上一步计算来的。所有的相关handles都会在给定的文件描述符上等待读或写事件若是有就调用他们的回调。 Check handle的回调被调用。当事件循环被I/O阻塞结束之后立刻调用check handle的回调。本质上他是和prepare handle 相反的。 关闭回调被调用。如果一个handle呗uv_close()关掉了，此时就会在这个点调用关闭的回调。 在UV_RUN_ONCE的情况下的特殊情况，他意味着进一步的处理。比如在循环被I/O阻塞时没有回调被触发，但是已经过去一段时间了，有可能会有定时器到期，那么在进行一次定时器的回调就可以被调用了。 循环结束。当循环是在UV_RUN_NOWAIT或者UV_RUN_ONCE模式下运行的，那么循环将结束。uv_run会返回。如果实在UV_RUN_DEFAULT模式下运行的，若是他还处于alive状态那么循环会继续，否则也会结束。 重要提示：libuv使用线程池来使异步文件I/O操作成为可能，但是网络I/O总是在单个线程（每个循环的线程）中执行。 文件I/O与网络I/O不同，没有libuv可以依赖的特定于平台的文件I/O原语，因此当前的方法是在线程池中运行阻塞文件I/O操作。 libuv目前使用一个全局的线程池，所有的循环都可以和其交互。有如下3种操作使用的是线程池: 文件系统的操作 DNS的功能（getaddrinfo and getnameinfo） 用户通过uv_queue_work指定的代码 线程池的大小是相当受限制的。 参考 为什么使用thread pool来处理文件I/O 关于怎么使用libuv libuv 的队列操作 2. 定义基本操作 12#define QUEUE_NEXT(q) (*(QUEUE **) &amp;((*(q))[0]))#define QUEUE_PREV(q) (*(QUEUE **) &amp;((*(q))[1])) 数组的第0个表示下一个，1表示上一个。这里使用((QUEUE **) &amp;(((q))[0]))这么复杂的表达是有两个原因。一个是转成左值（这里指的左值是指从数组元素的赋值的角度去看，就是指能不能给数组元素赋值），另一个是保存类型信息。 这样会丢失类型信息1#define QUEUE_NEXT(q) ((*(q))[0]) // 这个是数组的0号元素 这样不是左值1#define QUEUE_PREV(q) ((QUEUE *) ((*(q))[1])) // QUEUE* 是个数组指针非左值 123456q是 QUEUE * 这个是数组指针非左值*(q) 是QUEUE(*(q))[0]是数组第一个元素的值&amp;((*(q))[0])第一个元素的地址 （非左值）(QUEUE **) &amp;((*(q))[0]) 还是数组第一个元素之的地址但是这次保存了类型* (QUEUE **) &amp;((*(q))[0]) 是第一个元素的值得地址即保存了类型又是左值 3. 取值 这个队列的实现和数据无关，所以宏里面看不到data的定义，是不是很神奇，像在c++这种面向对象的语言中，我们一般通过迭代器来实现操作和数据的分离，而c语言可以用很巧妙的方式去高效的实现哦。 12#define QUEUE_DATA(ptr, type, field) \\ ((type *) ((char *) (ptr) - ((char *) &amp;((type *) 0)-&gt;field))) ((char ) &amp;((type ) 0)-&gt;field))是拿到偏移量。为什么这样就可以拿到偏移量？其实很好理解，把0当做其实地址，取field的地址，就是偏移量啦。 解释出处另一篇解释还有一篇参考","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"libuv","slug":"libuv","permalink":"http://yoursite.com/tags/libuv/"}]},{"title":"better developer之4个黄金规则","slug":"four-golden-rules","date":"2018-01-01T07:58:56.000Z","updated":"2018-07-14T13:00:30.003Z","comments":true,"path":"2018/01/01/four-golden-rules/","link":"","permalink":"http://yoursite.com/2018/01/01/four-golden-rules/","excerpt":"","text":"先上图研究如何才能成为一个更好的开发者是每一个开发者的核心。一个好的开发者的表现直接体现在他所生产的代码，你越是一个好的开发者，那么你代码的bug就会越少，并且你的代码更容易阅读以及维护。下面是我所遵守的4条黄金法则 规则1：我的代码像屎一样。所有的代码都像屎一样包括我自己的。无论你的代码有多好，总是会有一个更好的实现方式，并且也总是会有人觉得他像屎一样。 规则2：尽管他像屎一样，我依然关心我的代码。并不是只有在一开始才要写出好的代码，而是随时都要让你的代码保持更好。没有谁会在第一次就能写出好的代码，好的代码是需要打磨的，就像玉一样。重构应当是你的主要工作之一。 规则3：对于我自己的代码，我自己的观点都是错的。对于我们自己的代码，有时候我们过于以自我为中心了，无论这代码有多烂，我们总是会觉得这就是最好的解决方案。绝不要相信自己的观点，应当把你的代码尽可能多的给其他开发者看并听取他们的意见。 规则4：我的经理才不关心我的代码呢，他只是给我发工资而已这则规定决定了其他3个，我们总是容易忘记我们是被付了工资来把事情做完的。你的经理也是应该关注代码的，但是他更关注的是把事情以可接受的质量按时做完。因此也不要把过多的时间花在如何让你的代码不那么屎上。关键是要在做完和质量之间做一个平衡或者说是取舍。 一些其他可以帮助你的建议 Code reviews keep it simple test refactor Non technical factors 总结上面所说的是每一个开发者都曾经历过的事儿，却不是所有开发者都明白的事儿，软件开发不止是个技术活更是个艺术活。需要自然科学的支撑，更需要人文科学陪伴。是这两者的有机结合，才能写出好的代码，才能做一个更好的开发者。建议的五篇文章都值得一读。有时间了在继续写一写。 参考： blog","categories":[],"tags":[{"name":"software","slug":"software","permalink":"http://yoursite.com/tags/software/"}]},{"title":"代码的金字塔","slug":"pyramid-of-code","date":"2018-01-01T07:09:46.000Z","updated":"2018-07-14T13:00:30.069Z","comments":true,"path":"2018/01/01/pyramid-of-code/","link":"","permalink":"http://yoursite.com/2018/01/01/pyramid-of-code/","excerpt":"","text":"废话不说先上图 代码的质量可以被看作是上图的金字塔，每个顶点都代表这代码质量的一个特点。但总体来说一共包含两方面，基础和顶点（base and apex） 基础是什么呢？ 基础是那些让我们的代码可靠，可面向未来的特点的集合。而顶点则是代码的功能和可靠性。 你想让你的顶点越高，那么基础就应当越大。 基础包括那些特征呢？ 可读性这个特征代表了代码是否易于阅读，是否易于理解代码的内容及其目的。他又包括以下几个特征： 好的注释，注意不是过多的注释，过多的注释可不是什么好事儿 好的命名无论是类，函数，变量等, 见我的这篇文章 一致的代码规范 干净的逻辑，说白了就是没有废话 可扩展性这个特征代表了是否易于添加功能(对产品来说做减法的太少，做加法的太多了),好的设计应当具有高扩展性。扩展越高意味添加功能就越轻松，改动也越少。 原子性（低耦合，高内聚）这个特征代表了我们的功能模块之间是否低耦合，高内聚，模块内修改不影响其他模块。这里有一些好的原则： SOLID 原则) 单一功能原则 开闭原则 里氏替换原则 接口隔离原则 依赖反转原则 DRY 持续重构可测试性这个特征代表了我们的代码覆盖度有多少，我们的自动化程度有多少。还有单元测试，集成测试以及e2e测试的情况。 金字塔的顶点顶点代表了，我们的代码做了多少事，以及他的可靠程度 保持顶点与基础平衡要让我们的基础足够大，整体机构自然就会很好。 那么这个金字塔会有那些形状呢？ 代码需要重构，不在是个上小下大的机构了，就是个棍儿了。 所有的都是ok的，完美的金字塔。 底儿太大了，都成了个扁的了，过度设计，只是在浪费资源罢了。 那么怎么测量这个金字是否合适呢？不幸的是目前还没有什么具体的方法能够测量代码的可测试性，可读性，可扩展性，以及原子性，我们只能靠经验来判断。这是个悲哀。 总结无数先贤都在探索怎么才能把软件工程化做的更好，我也希望会做的更好，我也会为此做出努力。可这里隐含着一个问题，就好建筑业，他的工程化很成熟，因此带了无数的建筑工人，拿着微薄的工资，做着最累的工作。希望我们这里没有。 参考： blog","categories":[],"tags":[{"name":"software","slug":"software","permalink":"http://yoursite.com/tags/software/"}]},{"title":"fuck fuck fuck","slug":"programmers-top-10-sentences","date":"2018-01-01T06:52:57.000Z","updated":"2018-07-14T13:00:30.068Z","comments":true,"path":"2018/01/01/programmers-top-10-sentences/","link":"","permalink":"http://yoursite.com/2018/01/01/programmers-top-10-sentences/","excerpt":"","text":"看到了一篇列举程序员最常说的10句话 WTF! code reviews时最常听到的 It works in my machine! 在我这运行的好好的啊！当我们因为某一个问题被责怪时… D’oh!hi boy，你把debug代码从生产环境去掉了么？ It will be ready tomorrow. 明天就可以了明日复明日 Have you tried turning it off and on again? 你有没有尝试过重启一下试试？这是电视的话题，却被It人员搞火了 Why?为什么我们总是在问为什么？ Is not a bug, it’s a feature. 你懂的他不是bug他还是feature. That code is crap. 屎一样的代码。所有的代码都像屎一样，哦，当然只有我的不是 My code is compiling…快来干活，我的代码在编译呢。。好吧，加油 No, I don’t know how to fix the microwave。这句话我想改一下就是，不，我不会修电脑。 总结这里有的是实话，有的是玩笑话，有的自嘲话，可这些话是不是值得我们反思呢？","categories":[],"tags":[{"name":"software","slug":"software","permalink":"http://yoursite.com/tags/software/"}]},{"title":"software啊！你的命名为何这么难","slug":"naming","date":"2018-01-01T04:25:35.000Z","updated":"2018-07-14T13:00:30.044Z","comments":true,"path":"2018/01/01/naming/","link":"","permalink":"http://yoursite.com/2018/01/01/naming/","excerpt":"","text":"软件是如此的复杂之命名(我们只谈语义问题不谈逻辑问题)让机器懂的代码很简单，让人懂的代码就很难了。 其实代码也是在写作（虽然也大不相同），我现在发现能将自然科学和人文科学完美结合的就是计算机科学了。因为一段正确的代码需要正确的算法逻辑甚至是数学证明，事实上计算机科学发展的基础就是数。可是代码追求的不仅仅是正确，还得是可维护的，就是说是人可以读懂的。那么这时候就要看你的英语功底了，其实也不尽然，但是良好英语功底得是有的，只要你想写出大家可以看懂的代码（此处省略一万字别较真…）。关于代码写作，大部分不是在写完整的句子，反而大部分是在写短语，是在给事物进行命名处理。而是否写的好，这里有两方面的问题： 大家的英语都是very good, 但这里有个问题, 就是这段代码里的命名是否真正的体现了代码的核心含义就很重要了。举个简单栗子, 在一个业务场景中有这样一个问题 ‘If your customer just considers “order” an “order” that has been approved, don’t call “order” to a non approved one in your code, call it “nonApprovedOrder”’ 翻译一下就是你的客户只会‘订购’那些被批准了的‘订单’，那么你在一段代码里出现了order这个变量，此时就会很模糊了，模糊的关键就在于order到底是被批准了，还是未批准呢？可能你会说order对象有个属性来表示是否批准了。当然这是可以的，但若是我直接使用nonApprovedOrder是否会更清晰呢！这里只是举个简单例子，也并不代表一定得这样，其实order下的属性判断我觉得也是可以的，这里只是为了说明一个问题，能让人一目了然的命名才是更合适的。 对于非英语母语的半吊子英语的人来说，用对词语就很关键了。但对像我这种半吊子的人来说这里除了用对以外还有一个不可谓不重要的陷阱，那就是关于大家所学英语的共识。比如我知道一个单词a,并且我认为他的意思就是a,可是若是对另一个人来说他所认识的a代表的是b，那此时对于这个变量a,双发就会产生歧义了，甚至会惹得其他人说这是什么意思，怎么可以这么用。我举这个栗子就是要说明，一个公司最好有自己的命名规范甚至是自己的业务词语汇总。能减少不必要的麻烦。 看了上面两个问题就会发现，你写了一个正确代码，但却不一定写得出可读的代码。接下给大家看一些关于命名原则 变量的名字尽可能的具有具体的意义，而不是过于泛化 好的栗子：daysDateRange, flightNumber, carColor坏的栗子：days,dRange,temp,data, aux 关于这个原则，是视具体环境而变化的，比如data这个命名，有的时候我需要的就是data啊，越往底层走就越会出现像data这种抽象的命名，越往业务逻辑层走就越会出现像carColor这种具体的命名 尽量短一些（毕竟我们不是在写以字数多就是好的文章） 坏的栗子：howLonDoesItTakeToOpenTheDoor, howBigIsTheMaterial…好的栗子：timeToOpenTheDoor, MaterialSize 用缩写没问题，关键得有注释，或者是大家都知道的通用缩写 在需要的时候适当使用匈牙利标记法。举个栗子： 你需要根据苹果的颜色来区分是否成熟 你可这么来命名red_apples, yellow_apples … 这条待定 保持一致性如果采用驼峰式就都使用驼峰式 把业务领域的术语对应到你所熟知的命名上去栗子： If your customer just considers “order” an “order” that has been approved, don’t call “order” to a non approved one in your code, call it “nonApprovedOrder” 同上 黄金条例： 花一些时间再命名上（我觉得这条是最靠谱的，我也要贯彻执行）当你近乎不加思索的使用一个变量命名的时候，你基本上就已经选择了一个不好的命名。反之，你总是在向着好的命名前进 那怎么判断我们的命名是合适呢？当我们的命名ok时代码应当呈现以下几个特征 easy to read easy to use it looks simple lean is straight forward但这并不代表我们有了好的命名就会写出可读的代码，好的命名只是我们写出可读的代码的第一步，但若是第一步都迈不出去，那可就惨了。。。 当然一次性就改好了是在太困难了，那我们以前的旧代码怎么办？一句话对我们的代码持续性重构，以及持续性的测试。因此我们需要大量的测试用例，是的，测试用例。 最后一个真的是太重要了。参考：blog","categories":[],"tags":[{"name":"software","slug":"software","permalink":"http://yoursite.com/tags/software/"},{"name":"naming","slug":"naming","permalink":"http://yoursite.com/tags/naming/"}]},{"title":"typescript的声明文件","slug":"typescript的声明文件","date":"2017-12-13T13:58:58.000Z","updated":"2018-07-14T13:00:30.095Z","comments":true,"path":"2017/12/13/typescript的声明文件/","link":"","permalink":"http://yoursite.com/2017/12/13/typescript的声明文件/","excerpt":"","text":"开篇扯淡上次我们谈论协变和逆变时提到了 typescript, ts 本身是 js 的超集，从名字就可以看出来 ts 为 js 带来了类型，那么如何能写好 typescript？答案是从声明文件开始，若是能写的一手好的 ts 的声明文件，那 ts 的书写必然是手到擒来啊！2333333（我们就不在这里再做 ts 的基本语法的普及了详见handbook） 为什么要有声明文件呢？ts 的声明文件又是什么呢（是以.d.ts 结尾的文件）？为什么？我们知道 ts 是 js 的超集也是会编译成 js 的，那么已有的 js 代码怎么和现有的 ts 项目融合呢（即在 ts 中引用 js）？因为 js 是弱类型的，是无法推导出变量的类型的，那么 ts 的编译器自然就无法集成 js 的代码了？此时声明文件就起到作用了，声明文件的目的就是告诉 ts 的编译器，我要引用 js 文件了，js 文件的内容有啥，暴露出来的变量叫啥，类型是啥等等，听着怎么那么像是 C/C++的头文件呢？ts 是强类型语言了，每个变量就都会有自己的类型(类型是不可变得哦)，这些类型都是要声明的，还有接口也是要声明的，而 js 代码是没有这些的，所以就需要声明文件了 123456789101112131415161718// 1interface Dog &#123; bark: (world: string) =&gt; void;&#125;const tuDog: Dog = &#123; bark: (world: string) &#123; console.log(&apos;bark&apos;); &#125;&#125;// 2interface TextSpan &#123; start: number; end: number;&#125;// 3type Test = (version: number) =&gt; void; 上面的代码我们定义了两个接口类型，和一个 Test 的函数类型，当我们把这些类型定义都放到一个文件里时就成了一个‘声明文件’了，这里打引号的意思是，正常 ts 之间引用是不用专门抽出来写一成一个文件的(当然你要是乐意那也是可以的)，这个例子就是在说声明文件就是一堆’类型声明‘(这里打引号是因为正式的声明文件里也是会声明变量的)，就好比的 C/C++的头文件 举个简单的栗子 新建一个 foo.js 12// foo.jsmodule.exports.say = require(&apos;./say&apos;); 新建一个 say.js 1234// say.js 我们在此假设 o 是stringmodule.exports = function say(o) &#123; return o;&#125; 在新建一个 index.ts 123// index.tsimport * as a from &apos;../foo&apos;; //此时是会报错的，因为没有foo.tsa.say(&apos;123&apos;) 此时编译 index.ts 是无法通过的, 因为没有 foo.ts 再新建一个 foo.d.ts 文件(需同名，这样 tsc–typescript 的编译器在加载时就会去找相应文件) 12// 但若是 再加一个foo.d.ts文件export function say(o: string): string; 此时再编译就会通过了，而且若是调用穿得参数不是 string，也是不会通过的 上面是通过包的形式引入的,那么全局方式引入的又该如何呢？答案是 declare 新建一个 foo.js 1234// foo.js 我们在此假设 o 是stringglobal.say = function(o) &#123; return o;&#125;; 在新建一个 index.ts 123// index.tsimport * as a from &apos;../foo&apos;; //此时是会报错的，因为没有foo.ts, 并且也没有barkbark(&apos;123&apos;) 此时编译 index.ts 是无法通过的, 因为没有 foo.ts 再新建一个 foo.d.ts 文件(需同名，这样 tsc–typescript 的编译器在加载时就会去找相应文件) 123// 但若是 再加一个foo.d.ts文件delcare function say(o: string): string;// delcare var say: (o: string) =&gt; string; 成功 ok 通过上面我们可以看出需要通过包引入的我们使用 export, 通过全局似的就可以使用 declaredeclare 的正式说明参见typescript spec总的来说就是 declare 使声明引用那些已经在代码执行环境中存在的 变量，函数，类，枚举，命名空间，或者 modules, 例如通过 script 标签引入的包。在 declare 命名空间和 modules 时应注意，只能在顶层是使用 declare, 命名空间内部是不允许使用的，命名空间内部的可访问情况可由 export 控制（想让谁可访问就 export 谁） 有很多的库都有相应的 ts 声明文件，那么怎么安装呢？1npm install --save-dev @types/node(package-name) 可以在这里搜索.d.ts 总结当然这里仅仅是简单的做了介绍，通过这个简单的介绍我们可以发现，当我们把声明文件写的完整的时候，基本就是 ts 出师的时候了。(举的栗子是两种分开的，那么在我的 node 项目的某个文件中既有 global 形式又有包的导出形式该怎么做呢？我还没写对，有待努力！各位看官要是知道的话忘不吝赐教（dj_amazing@sina.com）) 在声明文件中 export ** 和declare的差不多，import {export的， declare的 } from ‘’; 都可以被导出， 但是若是使用了 export = something, 那么就只有somethine会被导出了declare namespace看做是内部模块即可，不可作为类型，以及值，只是用来分隔代码 conditional type 中可以使用 infer 关键字，常规的类型定义中不能使用推到出 函数返回值类型1type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any; 普通类型定义 使用infer会报错1type ReturnType&lt;T extends (...args: any[]) =&gt; infer R&gt; = R; // Error, not supported 参考： handbook learn-ts DefinitelyTyped","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"说一个slide的实现方式","slug":"slide","date":"2017-12-12T14:44:35.000Z","updated":"2018-07-14T13:00:30.071Z","comments":true,"path":"2017/12/12/slide/","link":"","permalink":"http://yoursite.com/2017/12/12/slide/","excerpt":"","text":"画画有点儿难啊！","categories":[],"tags":[{"name":"slide","slug":"slide","permalink":"http://yoursite.com/tags/slide/"},{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]}]}