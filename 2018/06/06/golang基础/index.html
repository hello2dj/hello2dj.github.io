<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>golang基础 | hello2dj | if you can&#39;t explain it simply, you don&#39;t understand it well enough</title>

  
  <meta name="author" content="hello2dj (dj_amazing@sina.com)">
  

  
  <meta name="description" content="每个人都是带着棱角来到世上，只有磨平棱角才能走的更远">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="golang基础"/>

  <meta property="og:site_name" content="hello2dj"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="hello2dj" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">hello2dj</a>
    </h1>
    <p class="site-description">if you can&#39;t explain it simply, you don&#39;t understand it well enough</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>golang基础</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/06/golang基础/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-05T16:00:00.000Z">
          2018-06-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <blockquote>
<p>随时会更新</p>
</blockquote>
<h3 id="golang-的所有的都是-copy-赋值，-，传参，channel-发送等等都是。"><a href="#golang-的所有的都是-copy-赋值，-，传参，channel-发送等等都是。" class="headerlink" title="golang 的所有的都是 copy 赋值，=，传参，channel 发送等等都是。"></a>golang 的所有的都是 copy 赋值，=，传参，channel 发送等等都是。</h3><h3 id="这种声明方式若是已经定义了，则不会新建"><a href="#这种声明方式若是已经定义了，则不会新建" class="headerlink" title=":= 这种声明方式若是已经定义了，则不会新建"></a>:= 这种声明方式若是已经定义了，则不会新建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	pase_student()</span><br><span class="line">&#125;</span><br><span class="line">type student struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pase_student() &#123;</span><br><span class="line">	m := make(map[string]*student)</span><br><span class="line">	stus := []student&#123;</span><br><span class="line">		&#123;Name: &quot;zhou&quot;, Age: 24&#125;,</span><br><span class="line">		&#123;Name: &quot;li&quot;, Age: 23&#125;,</span><br><span class="line">		&#123;Name: &quot;wang&quot;, Age: 22&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	for i, stu := range stus &#123;</span><br><span class="line">		m[stu.Name] = &amp;stu; // 应该改为m[stu.Name] = &amp;stus[i]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for _, va := range m &#123;</span><br><span class="line">		fmt.Printf(&quot;%p \n&quot;, va)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stus 是个 map, stu 并不会每次新生成一个, 其实循环时每次都是相同的 stu, 而且 golang 每次都是 copy 语义，你再看一眼会发现，给 map 赋值的是指针，那就意味着无论你如何改变 map 都会是相同的值。:= 多次声明不会重新定义新的变量， 可见<a href="https://golang.org/ref/spec#Short_variable_declarations" target="_blank" rel="noopener">规范</a></p>
<p>见下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">field1, offset := nextField(str, 0)</span><br><span class="line">field2, offset := nextField(str, offset)  // redeclares offset</span><br><span class="line">a, a := 1, 2                              // illegal: double declaration of a or no new variable if a was declared elsewhere</span><br></pre></td></tr></table></figure>
<h3 id="golang-的字符串是不可变的，要想使用可变字符串可以使用-bytes，或者-rune-数组-string-类型不可变，他的-slice-也不可变"><a href="#golang-的字符串是不可变的，要想使用可变字符串可以使用-bytes，或者-rune-数组-string-类型不可变，他的-slice-也不可变" class="headerlink" title="golang 的字符串是不可变的，要想使用可变字符串可以使用 bytes，或者[]rune 数组, string 类型不可变，他的 slice 也不可变"></a>golang 的字符串是不可变的，要想使用可变字符串可以使用 bytes，或者[]rune 数组, string 类型不可变，他的 slice 也不可变</h3><h3 id="我们可以从关闭的-channel-中读取数据但是为空，就是说若是在-select-语句-case-中从关闭的-channel-是可以的。-参见"><a href="#我们可以从关闭的-channel-中读取数据但是为空，就是说若是在-select-语句-case-中从关闭的-channel-是可以的。-参见" class="headerlink" title="我们可以从关闭的 channel 中读取数据但是为空，就是说若是在 select 语句 case 中从关闭的 channel 是可以的。 参见"></a>我们可以从关闭的 channel 中读取数据但是为空，就是说若是在 select 语句 case 中从关闭的 channel 是可以的。 <a href="https://play.golang.org/p/zqR533gQiSJ" target="_blank" rel="noopener">参见</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case &lt;- stopCh:</span><br><span class="line">  fmt.Println(&quot;go&quot;)</span><br><span class="line">default:</span><br><span class="line">  fmt.Println(&quot;come&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在使用-Go-channel-的时候，一个适用的原则是不要从接收端关闭-channel，也不要关闭有多个并发发送者的-channel。-优雅关闭-go-channel-http-www-tapirgames-com-blog-golang-channel-closing"><a href="#在使用-Go-channel-的时候，一个适用的原则是不要从接收端关闭-channel，也不要关闭有多个并发发送者的-channel。-优雅关闭-go-channel-http-www-tapirgames-com-blog-golang-channel-closing" class="headerlink" title="在使用 Go channel 的时候，一个适用的原则是不要从接收端关闭 channel，也不要关闭有多个并发发送者的 channel。 优雅关闭 go channel(http://www.tapirgames.com/blog/golang-channel-closing)"></a>在使用 Go channel 的时候，一个适用的原则是不要从接收端关闭 channel，也不要关闭有多个并发发送者的 channel。 <a href="https://www.jianshu.com/p/d24dfbb33781" target="_blank" rel="noopener">优雅关闭 go channel</a>(<a href="http://www.tapirgames.com/blog/golang-channel-closing" target="_blank" rel="noopener">http://www.tapirgames.com/blog/golang-channel-closing</a>)</h3><p>channel 的使用，当 channel 是非缓冲的时候他就是阻塞读与写的， 所以使用 channel 的时候要小心同步阻塞，导致死锁 game over</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan string)</span><br><span class="line">ch &lt;- &quot;23&quot; // 此时就会阻塞</span><br><span class="line">// a &lt;- ch 单写他也是会阻塞的</span><br></pre></td></tr></table></figure>
<p>所以要小心不要出现只有读或者只有写的 channel 若是出现的话，分布在不同 goroutine 中时就会导致 golang 死锁，主在等子完成可是子阻塞在了 channel 读或者写上了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">    &quot;math/rand&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    log.SetFlags(0)</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">    const MaxRandomNumber = 100000</span><br><span class="line">    const NumReceivers = 10</span><br><span class="line">    const NumSenders = 1000</span><br><span class="line"></span><br><span class="line">    wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">    dataCh := make(chan int, 100)</span><br><span class="line">    stopCh := make(chan struct&#123;&#125;)</span><br><span class="line">        // stopCh is an additional signal channel.</span><br><span class="line">        // Its sender is the moderator goroutine shown below.</span><br><span class="line">        // Its reveivers are all senders and receivers of dataCh.</span><br><span class="line">    toStop := make(chan string, 1)</span><br><span class="line">        // 设为缓冲1是为了防止moderator还未准备好就停止了</span><br><span class="line">        // the channel toStop is used to notify the moderator</span><br><span class="line">        // to close the additional signal channel (stopCh).</span><br><span class="line">        // Its senders are any senders and receivers of dataCh.</span><br><span class="line">        // Its reveiver is the moderator goroutine shown below.</span><br><span class="line"></span><br><span class="line">    var stoppedBy string</span><br><span class="line"></span><br><span class="line">    // moderator</span><br><span class="line">    go func() &#123;</span><br><span class="line">        stoppedBy = &lt;- toStop // part of the trick used to notify the moderator</span><br><span class="line">                              // to close the additional signal channel.</span><br><span class="line">        close(stopCh)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    // senders</span><br><span class="line">    for i := 0; i &lt; NumSenders; i++ &#123;</span><br><span class="line">        go func(id string) &#123;</span><br><span class="line">            for &#123;</span><br><span class="line">                value := rand.Intn(MaxRandomNumber)</span><br><span class="line">                if value == 0 &#123;</span><br><span class="line">                    // here, a trick is used to notify the moderator</span><br><span class="line">                    // to close the additional signal channel.</span><br><span class="line">                    select &#123;</span><br><span class="line">                    case toStop &lt;- &quot;sender#&quot; + id:</span><br><span class="line">                    default:</span><br><span class="line">                    &#125;</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // the first select here is to try to exit the</span><br><span class="line">                // goroutine as early as possible.</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;- stopCh:</span><br><span class="line">                    return</span><br><span class="line">                default:</span><br><span class="line">                &#125;</span><br><span class="line">                // 为什么要在前面在加一个select stopCh呢? 因为若是到了这一步由于select的随机性（此时stopCh和dataCh都处于活跃状态select是随机选取的），有可能会继续发送，而没有选择stopCh</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;- stopCh:</span><br><span class="line">                    return</span><br><span class="line">                case dataCh &lt;- value:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // receivers</span><br><span class="line">    for i := 0; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">        go func(id string) &#123;</span><br><span class="line">            defer wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">            for &#123;</span><br><span class="line">                // same as senders, the first select here is to</span><br><span class="line">                // try to exit the goroutine as early as possible.</span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;- stopCh:</span><br><span class="line">                    return</span><br><span class="line">                default:</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                select &#123;</span><br><span class="line">                case &lt;- stopCh:</span><br><span class="line">                    return</span><br><span class="line">                case value := &lt;-dataCh:</span><br><span class="line">                    if value == MaxRandomNumber-1 &#123;</span><br><span class="line">                        // the same trick is used to notify the moderator</span><br><span class="line">                        // to close the additional signal channel.</span><br><span class="line">                        select &#123;</span><br><span class="line">                        case toStop &lt;- &quot;receiver#&quot; + id:</span><br><span class="line">                        default:</span><br><span class="line">                        &#125;</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.Println(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(strconv.Itoa(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">    wgReceivers.Wait()</span><br><span class="line">    log.Println(&quot;stopped by&quot;, stoppedBy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="golang-make-返回的是值类型，用-slice-map-channel-并且会给-map-和-slice-预分配空间"><a href="#golang-make-返回的是值类型，用-slice-map-channel-并且会给-map-和-slice-预分配空间" class="headerlink" title="golang make 返回的是值类型，用 slice, map, channel, 并且会给 map 和 slice 预分配空间"></a>golang make 返回的是值类型，用 slice, map, channel, 并且会给 map 和 slice 预分配空间</h3><h3 id="golang-slice-语法可以对值也可以对引用"><a href="#golang-slice-语法可以对值也可以对引用" class="headerlink" title="golang slice 语法可以对值也可以对引用"></a>golang slice 语法可以对值也可以对引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,34]</span><br><span class="line">t := a[1:3] // ok</span><br><span class="line">c := (&amp;a)[1:2] // ok</span><br></pre></td></tr></table></figure>
<h3 id="golang-切片的用法是-start-end-但不包括-end"><a href="#golang-切片的用法是-start-end-但不包括-end" class="headerlink" title="golang 切片的用法是 [start:end] 但不包括 end"></a>golang 切片的用法是 [start:end] 但不包括 end</h3><h3 id="new-返回的是指针类型"><a href="#new-返回的是指针类型" class="headerlink" title="new 返回的是指针类型"></a>new 返回的是指针类型</h3><h3 id="golang-也存在-js-中的那个经典问题就是"><a href="#golang-也存在-js-中的那个经典问题就是" class="headerlink" title="golang 也存在 js 中的那个经典问题就是"></a>golang 也存在 js 中的那个经典问题就是</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	runtime.GOMAXPROCS(1)</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(20)</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			fmt.Println(&quot;i: &quot;, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			fmt.Println(&quot;i: &quot;, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个打印的 i 都是 10， 因为他们打印的都是同一个变量 i。</p>
<h3 id="golang-中-return-defer-返回值的顺序"><a href="#golang-中-return-defer-返回值的顺序" class="headerlink" title="golang 中 return defer 返回值的顺序"></a>golang 中 return defer 返回值的顺序</h3><p>先来假设出结论，帮助大家理解原因：</p>
<p>多个 defer 的执行顺序为“后进先出”；</p>
<p>defer、return、返回值三者的执行逻辑应该是：return 最先执行，return 负责将结果写入返回值中；接着 defer 开始执行一些收尾工作；最后函数携带当前返回值退出。</p>
<p>如何解释两种结果的不同：</p>
<p>上面两段代码的返回结果之所以不同，其实从上面第 2 条结论很好理解。</p>
<p>a()int 函数的返回值没有被提前声名，其值来自于其他变量的赋值，而 defer 中修改的也是其他变量，而非返回值本身，因此函数退出时返回值并没有被改变。</p>
<p>b()(i int) 函数的返回值被提前声名，也就意味着 defer 中是可以调用到真实返回值的，因此 defer 在 return 赋值返回值 i 之后，再一次地修改了 i 的值，最终函数退出后的返回值才会是 defer 修改过的值。</p>
<p>defer 是在函数结束前执行的，当返回值的临时变量赋给外部时才算调用结束吧！a = fn(2) 当把值给了 a 才算结束</p>
<blockquote>
<p>我们可以这么理解 return 肯定先执行执行的结果就是把返回值计算出来并且赋值给返回值所存在的临时变量, 但我们命名返回值的时候，返回值并不是临时变量而是函数中声明的变量</p>
</blockquote>
<h3 id="在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名"><a href="#在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名" class="headerlink" title="在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名"></a>在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名</h3><h3 id="append-只能作用在-slice-上而不能是指针"><a href="#append-只能作用在-slice-上而不能是指针" class="headerlink" title="append 只能作用在 slice 上而不能是指针"></a>append 只能作用在 slice 上而不能是指针</h3><p>参见签名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func append(slice []Type, elems ...Type) []Type</span><br></pre></td></tr></table></figure>
<p>错误的栗子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s1 := []int&#123;1, 2, 3&#125;</span><br><span class="line">	s2 := []int&#123;4, 5&#125;</span><br><span class="line">	s1 = append(s1, s2)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">&#125; // 错误因为 append接下来的参数是以一个一个传递的切片中的元素，而不是切片 正确的是 s1 = append(s1, ...s2)</span><br></pre></td></tr></table></figure>
<h3 id="进行结构体比较时候，只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。并且结构体可比较的前提是结构的属性都可比较。map-和-slice-还有-function-不可比较"><a href="#进行结构体比较时候，只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。并且结构体可比较的前提是结构的属性都可比较。map-和-slice-还有-function-不可比较" class="headerlink" title="进行结构体比较时候，只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。并且结构体可比较的前提是结构的属性都可比较。map 和 slice 还有 function 不可比较"></a>进行结构体比较时候，只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。并且结构体可比较的前提是结构的属性都可比较。map 和 slice 还有 function 不可比较</h3><p>就是说属性名字不同，类型不同或者顺序不同都是不能比较的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	sn1 := struct &#123;</span><br><span class="line">		age  int</span><br><span class="line">		name string</span><br><span class="line">	&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line">	sn2 := struct &#123;</span><br><span class="line">		age  int</span><br><span class="line">		name string</span><br><span class="line">	&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line"></span><br><span class="line">	if sn1 == sn2 &#123;</span><br><span class="line">		fmt.Println(&quot;sn1 == sn2&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sm1 := struct &#123;</span><br><span class="line">		age int</span><br><span class="line">		m   map[string]string</span><br><span class="line">	&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line">	sm2 := struct &#123;</span><br><span class="line">		age int</span><br><span class="line">		m   map[string]string</span><br><span class="line">	&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">	if sm1 == sm2 &#123;</span><br><span class="line">		fmt.Println(&quot;sm1 == sm2&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处 sn1 可以和 sn2 使用==比较但是如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sn3:= struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;&#123;age:11,name:&quot;qq&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>sn3 就不能比较了</p>
<p>还有上例中，含有不可比较的 map,slice，func 等，所以 sm1 和 sm2 是不可比较的但是我们可以使用 deepEqual 来进行比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if reflect.DeepEqual(sn1, sm) &#123;</span><br><span class="line">    fmt.Println(&quot;sn1 ==sm&quot;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    fmt.Println(&quot;sn1 !=sm&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赋值模式的限制"><a href="#赋值模式的限制" class="headerlink" title=":= 赋值模式的限制"></a>:= 赋值模式的限制</h3><p>定义变量同时显式初始化不能提供数据类型只能在函数内部使用</p>
<h3 id="nil-可以用作-interface、function、pointer、map、slice-和-channel-的“空值”-是不可以作为其他类型的空值的，比如-String-string-的空值是“”"><a href="#nil-可以用作-interface、function、pointer、map、slice-和-channel-的“空值”-是不可以作为其他类型的空值的，比如-String-string-的空值是“”" class="headerlink" title="nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”, 是不可以作为其他类型的空值的，比如 String, string 的空值是“”"></a>nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”, 是不可以作为其他类型的空值的，比如 String, string 的空值是“”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a chan int</span><br><span class="line">// a 是空值nil</span><br><span class="line">// chan的初始化一定是用make</span><br><span class="line"></span><br><span class="line">var a map[int]string</span><br><span class="line">// a 是空值nil</span><br><span class="line">// map初始化一定使用make</span><br><span class="line">// 使用new 生成的map也是nil的map</span><br></pre></td></tr></table></figure>
<h3 id="itoa"><a href="#itoa" class="headerlink" title="itoa"></a>itoa</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	x = iota</span><br><span class="line">	y</span><br><span class="line">	z = &quot;zz&quot;</span><br><span class="line">	k</span><br><span class="line">	p = iota</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">	fmt.Println(x,y,z,k,p)</span><br><span class="line">&#125;</span><br><span class="line">// 结果</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">zz</span><br><span class="line">zz</span><br><span class="line">4（直接计算当前的值）</span><br></pre></td></tr></table></figure>
<h3 id="golang-const-常量可以使用-itoa-赋值，-甚至是自定义类型"><a href="#golang-const-常量可以使用-itoa-赋值，-甚至是自定义类型" class="headerlink" title="golang const 常量可以使用 itoa 赋值， 甚至是自定义类型"></a>golang const 常量可以使用 itoa 赋值， 甚至是自定义类型</h3><p><a href="https://segmentfault.com/a/1190000000656284" target="_blank" rel="noopener">参见</a></p>
<p>若是自定义类型类似于枚举，当我们传递字面量（如：2，3）时也是可以被识别为枚举值的。</p>
<ul>
<li>当在一行声明两个常量 itoa 时，itoa 是只有到了下一行才会增长</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Apple, Banana = iota + 1, iota + 2</span><br><span class="line">    Cherimoya, Durian</span><br><span class="line">    Elderberry, Fig</span><br><span class="line">)</span><br><span class="line">// 输出</span><br><span class="line">// Apple: 1</span><br><span class="line">// Banana: 2</span><br><span class="line">// Cherimoya: 2</span><br><span class="line">// Durian: 3</span><br><span class="line">// Elderberry: 3</span><br><span class="line">// Fig: 4</span><br></pre></td></tr></table></figure>
<ul>
<li>itoa 从 0 开始增长，当我们们不使用 itoa 时，且赋值一个则所有的都会是这个值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">  a = &quot;1&quot;</span><br><span class="line">  b</span><br><span class="line">  c</span><br><span class="line">  d</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="goto-不能跳转到其他函数或者内层代码-只能在本函数以及相同的-scope-内"><a href="#goto-不能跳转到其他函数或者内层代码-只能在本函数以及相同的-scope-内" class="headerlink" title="goto 不能跳转到其他函数或者内层代码, 只能在本函数以及相同的 scope 内"></a>goto 不能跳转到其他函数或者内层代码, 只能在本函数以及相同的 scope 内</h3><p>下面的就是错的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">    for i:=0;i&lt;10 ;i++  &#123;</span><br><span class="line">    loop:</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    goto loop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意-defintion-和-type-alias-的区别-defintion-是定义了一个新的类型，alias-仅仅是个别名"><a href="#注意-defintion-和-type-alias-的区别-defintion-是定义了一个新的类型，alias-仅仅是个别名" class="headerlink" title="注意 defintion 和 type alias 的区别 defintion 是定义了一个新的类型，alias 仅仅是个别名"></a>注意 defintion 和 type alias 的区别 defintion 是定义了一个新的类型，alias 仅仅是个别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    type MyInt1 int</span><br><span class="line">    type MyInt2 = int</span><br><span class="line">    var i int =9</span><br><span class="line">    var i1 MyInt1 = i // 错误 MyInt1是个新类型</span><br><span class="line">    var i2 MyInt2 = i // yes 是个别名</span><br><span class="line">    fmt.Println(i1,i2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-我们在返回值中定义的命名返回值，可以直接在函数中使用不用再重新定义-2-内部-scope-中新定义的内部变量是会覆盖掉外部的变量"><a href="#1-我们在返回值中定义的命名返回值，可以直接在函数中使用不用再重新定义-2-内部-scope-中新定义的内部变量是会覆盖掉外部的变量" class="headerlink" title="1. 我们在返回值中定义的命名返回值，可以直接在函数中使用不用再重新定义 2. 内部 scope 中新定义的内部变量是会覆盖掉外部的变量"></a>1. 我们在返回值中定义的命名返回值，可以直接在函数中使用不用再重新定义 2. 内部 scope 中新定义的内部变量是会覆盖掉外部的变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;errors&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ErrDidNotWork = errors.New(&quot;did not work&quot;)</span><br><span class="line"></span><br><span class="line">func DoTheThing(reallyDoIt bool) (err error) &#123;</span><br><span class="line">    if reallyDoIt &#123;</span><br><span class="line">        result, err := tryTheThing()</span><br><span class="line">        if err != nil || result != &quot;it worked&quot; &#123;</span><br><span class="line">            err = ErrDidNotWork</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func tryTheThing() (string,error)  &#123;</span><br><span class="line">    return &quot;&quot;,ErrDidNotWork</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(DoTheThing(true))</span><br><span class="line">    fmt.Println(DoTheThing(false))</span><br><span class="line">&#125;</span><br><span class="line">// 输出两个</span><br><span class="line">&lt;nil&gt;</span><br><span class="line">&lt;nil&gt;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func DoTheThing(reallyDoIt bool) (err error) &#123;</span><br><span class="line">    var result string</span><br><span class="line">    if reallyDoIt &#123;</span><br><span class="line">        result, err = tryTheThing() // 不要新定义变量</span><br><span class="line">        if err != nil || result != &quot;it worked&quot; &#123;</span><br><span class="line">            err = ErrDidNotWork</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="panic-仅有最后一个可以被-revover-捕获-panic-中可以传任何值，不仅仅可以传-string"><a href="#panic-仅有最后一个可以被-revover-捕获-panic-中可以传任何值，不仅仅可以传-string" class="headerlink" title="panic 仅有最后一个可以被 revover 捕获,panic 中可以传任何值，不仅仅可以传 string"></a>panic 仅有最后一个可以被 revover 捕获,panic 中可以传任何值，不仅仅可以传 string</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err:=recover();err!=nil&#123;</span><br><span class="line">            fmt.Println(&quot;++++&quot;)</span><br><span class="line">            f:=err.(func()string)</span><br><span class="line">            fmt.Println(err,f(),reflect.TypeOf(err).Kind().String())</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            fmt.Println(&quot;fatal&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        // 这里就recover是捕获不到err的，所以这里的err是nil</span><br><span class="line">        if err:=recover();err!=nil&#123;</span><br><span class="line">            fmt.Println(&quot;++++&quot;)</span><br><span class="line">            f:=err.(func()string)</span><br><span class="line">            fmt.Println(err,f(),reflect.TypeOf(err).Kind().String())</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            fmt.Println(&quot;fatal&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        panic(func() string &#123;</span><br><span class="line">            return  &quot;defer panic&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(&quot;panic&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不管运行顺序如何，当参数为函数的时候，要先计算参数的值"><a href="#不管运行顺序如何，当参数为函数的时候，要先计算参数的值" class="headerlink" title="不管运行顺序如何，当参数为函数的时候，要先计算参数的值"></a>不管运行顺序如何，当参数为函数的时候，要先计算参数的值</h3><h3 id="map-引用不存在的-key，不报错"><a href="#map-引用不存在的-key，不报错" class="headerlink" title="map 引用不存在的 key，不报错"></a>map 引用不存在的 key，不报错</h3><h3 id="map-使用-range-遍历顺序问题，并不是录入的顺序，而是随机顺序"><a href="#map-使用-range-遍历顺序问题，并不是录入的顺序，而是随机顺序" class="headerlink" title="map 使用 range 遍历顺序问题，并不是录入的顺序，而是随机顺序"></a>map 使用 range 遍历顺序问题，并不是录入的顺序，而是随机顺序</h3><h3 id="append-函数返回更新后的-slice（长度和容量可能会变），必须重新用-slice-的变量接收，不然无法编译通过"><a href="#append-函数返回更新后的-slice（长度和容量可能会变），必须重新用-slice-的变量接收，不然无法编译通过" class="headerlink" title="append 函数返回更新后的 slice（长度和容量可能会变），必须重新用 slice 的变量接收，不然无法编译通过"></a>append 函数返回更新后的 slice（长度和容量可能会变），必须重新用 slice 的变量接收，不然无法编译通过</h3><h3 id="golang-channel-和一个-goroutine-组合起来就是一个-web-worker-的模式，只是我们在-js-里管理的是-web-worker-的句柄，而在-golang-里面我们要管理的是-channel-这里-golang-的一个优势是我可以把多个-channel-和一个-goroutine-绑定，而-web-worker-一个句柄就对应这个一个-web-worker-是不可能多对一的。"><a href="#golang-channel-和一个-goroutine-组合起来就是一个-web-worker-的模式，只是我们在-js-里管理的是-web-worker-的句柄，而在-golang-里面我们要管理的是-channel-这里-golang-的一个优势是我可以把多个-channel-和一个-goroutine-绑定，而-web-worker-一个句柄就对应这个一个-web-worker-是不可能多对一的。" class="headerlink" title="golang channel 和一个 goroutine 组合起来就是一个 web-worker 的模式，只是我们在 js 里管理的是 web-worker 的句柄，而在 golang 里面我们要管理的是 channel,这里 golang 的一个优势是我可以把多个 channel 和一个 goroutine 绑定，而 web-worker 一个句柄就对应这个一个 web-worker 是不可能多对一的。"></a>golang channel 和一个 goroutine 组合起来就是一个 web-worker 的模式，只是我们在 js 里管理的是 web-worker 的句柄，而在 golang 里面我们要管理的是 channel,这里 golang 的一个优势是我可以把多个 channel 和一个 goroutine 绑定，而 web-worker 一个句柄就对应这个一个 web-worker 是不可能多对一的。</h3><h3 id="golang-channel-的使用方式两种"><a href="#golang-channel-的使用方式两种" class="headerlink" title="golang channel 的使用方式两种"></a>golang channel 的使用方式两种</h3><ol>
<li>调用者生成传递个 goroutine。</li>
<li>被调用者生成返回给调用者。</li>
</ol>
<h3 id="内嵌结构体，当内嵌结构体不是指针时，是会有默认值得，这就符合了-golang-得概念，所有的变量都有默认值，指针的默认值是-nil"><a href="#内嵌结构体，当内嵌结构体不是指针时，是会有默认值得，这就符合了-golang-得概念，所有的变量都有默认值，指针的默认值是-nil" class="headerlink" title="内嵌结构体，当内嵌结构体不是指针时，是会有默认值得，这就符合了 golang 得概念，所有的变量都有默认值，指针的默认值是 nil."></a>内嵌结构体，当内嵌结构体不是指针时，是会有默认值得，这就符合了 golang 得概念，所有的变量都有默认值，指针的默认值是 nil.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;sync&quot;</span><br><span class="line">type A struct &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a := A&#123;&#125;</span><br><span class="line">    a.Lock()</span><br><span class="line">    a.Unlock()</span><br><span class="line">    fmt.Println(&quot;Mutex a &quot;, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码运行是 ok 的。</p>
<h3 id="两个-golang-问题-http-colobu-com-2018-03-08-two-issues-in-go-development"><a href="#两个-golang-问题-http-colobu-com-2018-03-08-two-issues-in-go-development" class="headerlink" title="两个 golang 问题 http://colobu.com/2018/03/08/two-issues-in-go-development/"></a>两个 golang 问题 <a href="http://colobu.com/2018/03/08/two-issues-in-go-development/" target="_blank" rel="noopener">http://colobu.com/2018/03/08/two-issues-in-go-development/</a></h3><h3 id="golang-包的引入路径-GOPATH-src-…一层一层查找"><a href="#golang-包的引入路径-GOPATH-src-…一层一层查找" class="headerlink" title="golang 包的引入路径 GOPATH/src/…一层一层查找"></a>golang 包的引入路径 GOPATH/src/…一层一层查找</h3><h3 id="bin-是可执行的文件，-pkg-是编译生成的-a-文件的存放位置是静态库"><a href="#bin-是可执行的文件，-pkg-是编译生成的-a-文件的存放位置是静态库" class="headerlink" title="bin 是可执行的文件， pkg 是编译生成的.a 文件的存放位置是静态库"></a>bin 是可执行的文件， pkg 是编译生成的.a 文件的存放位置是静态库</h3><h3 id="src-是存放源文件的命令"><a href="#src-是存放源文件的命令" class="headerlink" title="src 是存放源文件的命令"></a>src 是存放源文件的命令</h3><h3 id="安装问题-golang-x-tools-gt-https-github-com-golang-tools"><a href="#安装问题-golang-x-tools-gt-https-github-com-golang-tools" class="headerlink" title="安装问题 golang/x/tools &gt; https://github.com/golang/tools"></a>安装问题 golang/x/tools &gt; <a href="https://github.com/golang/tools" target="_blank" rel="noopener">https://github.com/golang/tools</a></h3><p>下载放到 src 下的 golang/x/下</p>
<h3 id="安装问题-golang-x-net-gt-https-github-com-golang-net"><a href="#安装问题-golang-x-net-gt-https-github-com-golang-net" class="headerlink" title="安装问题 golang/x/net &gt; https://github.com/golang/net"></a>安装问题 golang/x/net &gt; <a href="https://github.com/golang/net" target="_blank" rel="noopener">https://github.com/golang/net</a></h3><p>下载放到 src 下的 golang/x/下</p>
<h3 id="golint-go-get-u-v-github-com-golang-lint-golint"><a href="#golint-go-get-u-v-github-com-golang-lint-golint" class="headerlink" title="golint go get -u -v github.com/golang/lint/golint"></a>golint go get -u -v github.com/golang/lint/golint</h3><h3 id="编译时的使用第三方源码包-编译时的探索"><a href="#编译时的使用第三方源码包-编译时的探索" class="headerlink" title="编译时的使用第三方源码包 编译时的探索"></a>编译时的使用第三方源码包 <a href="https://tonybai.com/2015/03/09/understanding-import-packages/" target="_blank" rel="noopener">编译时的探索</a></h3><ol>
<li>在使用第三方包的时候，当源码和.a 均已安装的情况下，编译器链接的是源码</li>
<li>所谓的使用第三方包源码，实际上是链接了以该最新源码编译的临时目录下的.a 文件而已。</li>
<li>标准库在编译时也是必须要源码的。不过与自定义包不同的是，即便你修改了 fmt 包的源码（未重新编译 GO 安装包），用户源码编译时，也不会尝试重新编译 fmt 包的，依旧只是在链接时链接已经编译好的 fmt.a</li>
<li>Go 语言中 import 后面路径中最后的一个元素到底是包名还是路径名？答案是<strong>目录名</strong>。按照 Golang 语言习惯，一个 go package 的所有源文件放在同一个目录下，且该目录名与该包名相同，比如 libproj1/foo 目录下的 package 为 foo，foo1.go、 foo2.go…共同组成 foo package 的源文件。但目录名与包名也可以不同。</li>
<li>一个路径下<strong>不允许有两个包</strong>。</li>
</ol>
<h3 id="同其他语言-nodejs-一样，一个包被导入一次后就会被缓存，再次被导入会从缓存获取"><a href="#同其他语言-nodejs-一样，一个包被导入一次后就会被缓存，再次被导入会从缓存获取" class="headerlink" title="同其他语言 nodejs 一样，一个包被导入一次后就会被缓存，再次被导入会从缓存获取"></a>同其他语言 nodejs 一样，一个包被导入一次后就会被缓存，再次被导入会从缓存获取</h3><h3 id="init-函数的执行顺序"><a href="#init-函数的执行顺序" class="headerlink" title="init 函数的执行顺序"></a>init 函数的执行顺序</h3><ol>
<li>对同一个 go 文件的 init()调用顺序是从上到下的</li>
<li>对同一个 package 中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的 init()函数,对于</li>
<li>对不同的 package，如果不相互依赖的话，按照 main 包中”先 import 的后调用”的顺序调用其包中的 init()</li>
<li>如果 package 存在依赖，则先调用最早被依赖的 package 中的 init()</li>
<li>最后调用 main 函数</li>
</ol>
<h3 id="关于关闭-channel-有几点需要注意的是："><a href="#关于关闭-channel-有几点需要注意的是：" class="headerlink" title="关于关闭 channel 有几点需要注意的是："></a>关于关闭 channel 有几点需要注意的是：</h3><ol>
<li>重复关闭 channel 会导致 panic。</li>
<li>向关闭的 channel 发送数据会 panic。</li>
<li>从关闭的 channel 读数据不会 panic，读出 channel 中已有的数据之后再读就是 channel 类似的默认值，比如 chan int 类型的 channel 关闭之后读取到的值为 0。</li>
</ol>
<h3 id="make-和-new"><a href="#make-和-new" class="headerlink" title="make 和 new"></a>make 和 new</h3><ol>
<li>new allocate the memory and return the pointer</li>
<li>make allocate the memory and initialize the memory cause slice, map and channel must be initialized before use<br>new 的作用是 初始化 一个指向类型的指针 (<em>T)， make 的作用是为 slice, map 或者 channel 初始化，并且返回引用 T<br>make(T, args)函数的目的与 new(T)不同。它仅仅用于创建 Slice, Map 和 Channel，并且返回类型是 T（不是 T</em>）的一个初始化的（不是零值）的实例。 这中差别的出现是由于这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。 例如, Slice 是一个 具有三项内容的描述符，包括 指向数据（在一个数组内部）的指针，长度以及容量。在这三项内容被初始化之前，Slice 的值为 nil。对于 Slice，Map 和 Channel， make（）函数初始化了其内部的数据结构，并且准备了将要使用的值。</li>
</ol>
<h3 id="产品中一定不要使用默认的-http-Get"><a href="#产品中一定不要使用默认的-http-Get" class="headerlink" title="产品中一定不要使用默认的 http.Get"></a>产品中一定不要使用默认的 http.Get</h3><p>如果你觉得方便，直接使用 http.Get 或者类似的方法发送请求，可能会导致一些问题， 因为这默认是使用 DefaultClient 作为 client:</p>
<ol>
<li>多 goroutine 共享，这意味着在别处对 DefaultClient 的改动会影响你当前的使用</li>
<li>未设置 connection timeout 和 read/write timeout</li>
<li>默认的 idle connection 等设置可能不满足你的需求</li>
</ol>
<h3 id="检查网络错误或者超时-net-Error-和-err-Timeout-可以检查是不是超时错误"><a href="#检查网络错误或者超时-net-Error-和-err-Timeout-可以检查是不是超时错误" class="headerlink" title="检查网络错误或者超时 net.Error 和 err.Timeout() 可以检查是不是超时错误"></a>检查网络错误或者超时 net.Error 和 err.Timeout() 可以检查是不是超时错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err, ok := err.(net.Error); ok &amp;&amp; err.Timeout() &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="golang-命名返回值"><a href="#golang-命名返回值" class="headerlink" title="golang 命名返回值"></a>golang 命名返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func test()(a int) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上 a 相当于已经命名了，相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func test() int &#123;</span><br><span class="line">    var a int</span><br><span class="line">    return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="channel-关闭问题"><a href="#channel-关闭问题" class="headerlink" title="channel 关闭问题"></a>channel 关闭问题</h3><ul>
<li>通过 recover 来恢复来恢复</li>
<li>通过 Mutex 来保证不会向已关闭的 channel 发送消息</li>
<li>通过 sync.Once 来关闭，保证不会重复关闭好的原则是：</li>
</ul>
<ol>
<li>不要在接收端关闭 channel, 避免向关闭的 channel 发送消息</li>
<li>不要关闭有多个并发发送者的 channel</li>
</ol>
<h3 id="golang-里面所有未赋值的变量都会赋值为默认值，就连内嵌-struct-infterface-也一样"><a href="#golang-里面所有未赋值的变量都会赋值为默认值，就连内嵌-struct-infterface-也一样" class="headerlink" title="golang 里面所有未赋值的变量都会赋值为默认值，就连内嵌 struct, infterface 也一样"></a>golang 里面所有未赋值的变量都会赋值为默认值，就连内嵌 struct, infterface 也一样</h3><ul>
<li>内嵌 struct 会变为相应字段的默认值</li>
<li>内嵌 interface 为赋值就是 nil, 因为接口变量的默认值就是 nil(但 nil 和 nil 是不同的， 这里是个坑)</li>
</ul>
<h3 id="若是要-marshal-时，不要输出-null-字段或者是为空的字段（结构体），需要把它赋值为指针才可以然后加上-omitempty"><a href="#若是要-marshal-时，不要输出-null-字段或者是为空的字段（结构体），需要把它赋值为指针才可以然后加上-omitempty" class="headerlink" title="若是要 marshal 时，不要输出 null 字段或者是为空的字段（结构体），需要把它赋值为指针才可以然后加上 omitempty"></a>若是要 marshal 时，不要输出 null 字段或者是为空的字段（结构体），需要把它赋值为指针才可以然后加上 omitempty</h3><p><a href="https://stackoverflow.com/questions/18088294/how-to-not-marshal-an-empty-struct-into-json-with-go?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="noopener">https://stackoverflow.com/questions/18088294/how-to-not-marshal-an-empty-struct-into-json-with-go?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a></p>
<h3 id="http-colobu-com-2017-05-12-call-private-functions-in-other-packages-突破-golang-的访问限制"><a href="#http-colobu-com-2017-05-12-call-private-functions-in-other-packages-突破-golang-的访问限制" class="headerlink" title="http://colobu.com/2017/05/12/call-private-functions-in-other-packages/ 突破 golang 的访问限制"></a><a href="http://colobu.com/2017/05/12/call-private-functions-in-other-packages/" target="_blank" rel="noopener">http://colobu.com/2017/05/12/call-private-functions-in-other-packages/</a> 突破 golang 的访问限制</h3><h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h3><ul>
<li>reflect.TypeOf,是获取类型的元数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.TypeOf(i).Elem().Field(0).Tag //获取定义在struct里面的标签</span><br></pre></td></tr></table></figure>
<ul>
<li>reflect.ValueOf,是获取类型的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.ValueOf(i).Elem().Field(0).String() //获取存储在第一个字段里面的值</span><br></pre></td></tr></table></figure>
<h3 id="http-www-01happy-com-p3206"><a href="#http-www-01happy-com-p3206" class="headerlink" title="http://www.01happy.com/p3206/"></a><a href="http://www.01happy.com/p3206/" target="_blank" rel="noopener">http://www.01happy.com/p3206/</a></h3><p>最后再次重复一遍反射三定律：</p>
<ul>
<li>反射可以将“接口类型变量”转换为“反射类型对象”。</li>
<li>反射可以将“反射类型对象”转换为“接口类型变量”。</li>
<li>如果要修改“反射类型对象”，其值必须是“可写的”（settable）。</li>
</ul>
<p>一旦你理解了这些定律，使用反射将会是一件非常简单的事情。它是一件强大的工具，使用时务必谨慎使用，更不要滥用。</p>
<h3 id="只有可以-addressable-的变量才可以使用-reflect-进行赋值修改即："><a href="#只有可以-addressable-的变量才可以使用-reflect-进行赋值修改即：" class="headerlink" title="只有可以 addressable 的变量才可以使用 reflect 进行赋值修改即："></a>只有可以 addressable 的变量才可以使用 reflect 进行赋值修改即：</h3><p>wrong</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x float64 = 3.4</span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(7.1) // Error: will panic.</span><br></pre></td></tr></table></figure>
<p>yes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x float64 = 3.4</span><br><span class="line">p := reflect.ValueOf(&amp;x) // Note: take the address of x.</span><br><span class="line">fmt.Println(&quot;type of p:&quot;, p.Type())</span><br><span class="line">fmt.Println(&quot;settability of p:&quot;, p.CanSet())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存入 map 的是值是不可以 addressable 的 a = map [string]int; &amp;a[“s”], 这个很好理解因为，map 回去做冲突处理，地址有可能发生变化。</p>
</blockquote>
<h3 id="go-web-的一些建议-https-medium-com-matryer-how-i-write-go-http-services-after-seven-years-37c208122831"><a href="#go-web-的一些建议-https-medium-com-matryer-how-i-write-go-http-services-after-seven-years-37c208122831" class="headerlink" title="[go web 的一些建议](https://medium.com/@matryer/how-i-write-go-http-services-after-seven-years-37c208122831"></a>[go web 的一些建议](<a href="https://medium.com/@matryer/how-i-write-go-http-services-after-seven-years-37c208122831" target="_blank" rel="noopener">https://medium.com/@matryer/how-i-write-go-http-services-after-seven-years-37c208122831</a></h3><ol>
<li><p>Shared dependencies are fields of the structure<br>通过结构体的字段共享依赖，而不是到处引入（适用于所有的）</p>
</li>
<li><p>I have a single file inside every component called routes.go where all the routing can live:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package app</span><br><span class="line">func (s *server) routes() &#123;</span><br><span class="line">    s.router.HandleFunc(&quot;/api/&quot;, s.handleAPI())</span><br><span class="line">    s.router.HandleFunc(&quot;/about&quot;, s.handleAbout())</span><br><span class="line">    s.router.HandleFunc(&quot;/&quot;, s.handleIndex())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is handy because most code maintenance starts with a URL and an error report — so one glance at routes.go will direct us where to look.</p>
<ol start="3">
<li>If a particular handler has a dependency, take it as an argument. 若是有特殊依赖则作为参数传入</li>
</ol>
<p>4.</p>
<h3 id="https-github-com-dgryski-go-perfbook-blob-master-performance-md"><a href="#https-github-com-dgryski-go-perfbook-blob-master-performance-md" class="headerlink" title="https://github.com/dgryski/go-perfbook/blob/master/performance.md"></a><a href="https://github.com/dgryski/go-perfbook/blob/master/performance.md" target="_blank" rel="noopener">https://github.com/dgryski/go-perfbook/blob/master/performance.md</a></h3><h3 id="https-my-oschina-net-xinxingegeya-blog-729673-golang-unsafe-包的-unsafe-特性"><a href="#https-my-oschina-net-xinxingegeya-blog-729673-golang-unsafe-包的-unsafe-特性" class="headerlink" title="https://my.oschina.net/xinxingegeya/blog/729673 golang unsafe 包的 unsafe 特性"></a><a href="https://my.oschina.net/xinxingegeya/blog/729673" target="_blank" rel="noopener">https://my.oschina.net/xinxingegeya/blog/729673</a> golang unsafe 包的 unsafe 特性</h3><h3 id="错误和异常，意料之内的是错误，意料之外的是异常-https-studygolang-com-articles-11753-fr-sidebar"><a href="#错误和异常，意料之内的是错误，意料之外的是异常-https-studygolang-com-articles-11753-fr-sidebar" class="headerlink" title="错误和异常，意料之内的是错误，意料之外的是异常(https://studygolang.com/articles/11753?fr=sidebar)"></a>错误和异常，意料之内的是错误，意料之外的是异常(<a href="https://studygolang.com/articles/11753?fr=sidebar" target="_blank" rel="noopener">https://studygolang.com/articles/11753?fr=sidebar</a>)</h3><h3 id="从标准输入读取"><a href="#从标准输入读取" class="headerlink" title="从标准输入读取"></a>从标准输入读取</h3><ol>
<li>os.Stdin 实现了 Reader 接口可以直接 Read</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := make([]byte, 10)</span><br><span class="line">n, err := os.Stdin.Read(s)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>fmt.Scanf() 可以读取 so.Stdin</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var firstname, secondname string</span><br><span class="line">fmt.Scanln(&amp;FirstName, &amp;SecondNames)    //Scanln 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。</span><br><span class="line">fmt.Scanf(&quot;%s %s&quot;, &amp;firstName, &amp;lastName)    //Scanf与其类似，除了 Scanf 的第一个参数用作格式字符串，用来决定如何读取。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>os.Stdin 是个 Reader 但是没有缓冲， 可以使用 bufio.NewReader()生成一个带缓冲的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">for &#123;</span><br><span class="line">    input, _ := inputReader.ReadString(&apos;\n&apos;)</span><br><span class="line">    fmt.Println(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reader-接口"><a href="#Reader-接口" class="headerlink" title="Reader 接口"></a>Reader 接口</h3><ol>
<li>Read 方法<br>也就是说，当 Read 方法返回错误时，不代表没有读取到任何数据。调用者应该处理返回的任何数据，之后才处理可能的错误。<br>io.EOF 变量的定义：var EOF = errors.New(“EOF”)，是 error 类型。根据 reader 接口的说明，在 n &gt; 0 且数据被读完了的情况下，返回的 error 有可能是 EOF 也有可能是 nil。</li>
</ol>
<h3 id="Writer-接口"><a href="#Writer-接口" class="headerlink" title="Writer 接口"></a>Writer 接口</h3><ol>
<li>Write 方法<br>Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 &lt;= n &lt;= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n &lt; len(p)，它就必须返回一个 非nil 的错误。</li>
</ol>
<h3 id="golang-比较行为"><a href="#golang-比较行为" class="headerlink" title="golang 比较行为"></a>golang <a href="https://golang.org/ref/spec#Comparison_operators" target="_blank" rel="noopener">比较行为</a></h3><ol>
<li>指针只有指针指向的内容是同一个时才相等</li>
<li>接口值可以比较， 但若是接口值得类型相同，但是值却是不可比较的例如slice等，就会报runtime error</li>
</ol>
<p>Slice, map, and function values are not comparable</p>
<h3 id="func的receiver是-值时-无论调用者是指针还是值都可以调用func"><a href="#func的receiver是-值时-无论调用者是指针还是值都可以调用func" class="headerlink" title="func的receiver是 值时 无论调用者是指针还是值都可以调用func"></a>func的receiver是 值时 无论调用者是指针还是值都可以调用func</h3><p>如下若是使用指针作为receiver，则print 值时无法调用到String<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type A struct &#123;</span><br><span class="line">	c int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a A) String() string &#123;</span><br><span class="line">	return &quot;dj&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func format() &#123;</span><br><span class="line"></span><br><span class="line">	a := &amp;A&#123;c: 22&#125;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="bufio的readSlice返回的是bufio-Reader的里的buf（Reader缓存的slice），因此当再此读取以后返回的slice的值是改变的"><a href="#bufio的readSlice返回的是bufio-Reader的里的buf（Reader缓存的slice），因此当再此读取以后返回的slice的值是改变的" class="headerlink" title="bufio的readSlice返回的是bufio.Reader的里的buf（Reader缓存的slice），因此当再此读取以后返回的slice的值是改变的"></a>bufio的readSlice返回的是bufio.Reader的里的buf（Reader缓存的slice），因此当再此读取以后返回的slice的值是改变的</h3><blockquote>
<p>一般的reader都是没有缓冲的，bufio就是给reader加缓冲的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func readSlice() &#123;</span><br><span class="line">	reader := bufio.NewReader(strings.NewReader(&quot;http://studygolang.com.\nIt is the home of gophers&quot;))</span><br><span class="line">	line, _ := reader.ReadSlice(&apos;\n&apos;)</span><br><span class="line">	fmt.Println(&quot;the line is &quot;, string(line))</span><br><span class="line">	n, _ := reader.ReadSlice(&apos;\n&apos;)</span><br><span class="line">	fmt.Println(string(n), string(line))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>最后n和slice的值相同</p>
<p>而ReadBytes和ReadString就不会出现这个问题了，他们都新开辟的空间</p>
<p>如果ReadSlice在找到界定符之前遇到了error，<br>它就会返回缓存中所有的数据和错误本身（经常是 io.EOF）。<br>如果在找到界定符之前缓存已经满了，ReadSlice会返回bufio.ErrBufferFull错误。<br>当且仅当返回的结果（line）没有以界定符结束的时候，ReadSlice返回err != nil，<br>也就是说，如果ReadSlice返回的结果line不是以界定符delim结尾，那么返回的err也一定不等于nil<br>（可能是bufio.ErrBufferFull或io.EOF）。<br>并且当下次在读取时会继续向前<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func ReadSliceSize() &#123;</span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(&quot;http://studygolang.com.\nIt is the home of gophers&quot;), 10)</span><br><span class="line">	line, _ := reader.ReadSlice(&apos;\n&apos;)</span><br><span class="line">	fmt.Println(&quot;the line is &quot;, string(line))</span><br><span class="line">	n, _ := reader.ReadSlice(&apos;\n&apos;)</span><br><span class="line">	fmt.Println(string(n), string(line))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而使用ReadBytes和ReadString就没有这个问题了，bufio.reader会自动为我们处理。</p>
<h3 id="golang排序"><a href="#golang排序" class="headerlink" title="golang排序"></a>golang排序</h3><p>对基本类型排序</p>
<ol>
<li>int, float等<br>sort包有sort.Ints, sort.Float64s等方法排序，会改变原数组</li>
<li>其他类型则需要实现 sort.Interface接口了 ，如less,等</li>
</ol>
<h3 id="程序中使用time-Time"><a href="#程序中使用time-Time" class="headerlink" title="程序中使用time.Time"></a>程序中使用time.Time</h3><p>程序中应使用 Time 类型值来保存和传递时间，而不是指针。就是说，表示时间的变量和字段，应为time.Time类型，而不是*time.Time.类型。一个Time类型值可以被多个go程同时使用</p>
<h3 id="time-格式化"><a href="#time-格式化" class="headerlink" title="time 格式化"></a>time 格式化</h3><p>这是实际开发中常用到的。</p>
<ol>
<li>time.Parse 和 time.ParseInLocation</li>
<li>time.Time.Format<br>解析<br>对于解析，要特别注意时区问题，否则很容易出 bug。比如：</li>
</ol>
<p>t, _ := time.Parse(“2006-01-02 15:04:05”, “2016-06-13 09:14:00”)<br>fmt.Println(time.Now().Sub(t).Hours())<br>2016-06-13 09:14:00 这个时间可能是参数传递过来的。这段代码的结果跟预期的不一样。</p>
<p>原因是 time.Now() 的时区是 time.Local，而 time.Parse 解析出来的时区却是 time.UTC（可以通过 Time.Location() 函数知道是哪个时区）。在中国，它们相差 8 小时。</p>
<p>所以，一般的，我们应该总是使用 time.ParseInLocation 来解析时间，并给第三个参数传递 time.Local。</p>
<h3 id="string和number互转"><a href="#string和number互转" class="headerlink" title="string和number互转"></a>string和number互转</h3><ol>
<li>ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values</li>
<li>FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:</li>
</ol>
<h3 id="number和byte-数字和字节互转"><a href="#number和byte-数字和字节互转" class="headerlink" title="number和byte (数字和字节互转)"></a>number和byte (数字和字节互转)</h3><h3 id="想进行地址的加减操作就得使用uintptr"><a href="#想进行地址的加减操作就得使用uintptr" class="headerlink" title="想进行地址的加减操作就得使用uintptr"></a>想进行地址的加减操作就得使用uintptr</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bts := [5]byte&#123;2, 3, 4, 5, 6&#125;</span><br><span class="line">fmt.Println(bts)</span><br><span class="line">c := (*[4]byte)(unsafe.Pointer((uintptr(unsafe.Pointer(&amp;bts)) + uintptr(1))))[:]</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure>
<p>输出正确，直接使用 slice就错误（bts := []byte{2,3,4,5,6}）<br>原因是：bts为slice的时候 bts的内部结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type SliceHeader struct &#123;</span><br><span class="line">        Data uintptr</span><br><span class="line">        Len  int</span><br><span class="line">        Cap  int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说转化为[]byte以后 只有Data的地址，Len和Cap的值被转化为了字节</p>
<h3 id="string-和-byte-无copy转换"><a href="#string-和-byte-无copy转换" class="headerlink" title="string 和 []byte 无copy转换"></a>string 和 []byte 无copy转换</h3><p>// reflect.SliceHeader and reflect.StringHeader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type SliceHeader struct &#123;</span><br><span class="line">        Data uintptr</span><br><span class="line">        Len  int</span><br><span class="line">        Cap  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StringHeader struct &#123;</span><br><span class="line">        Data uintptr</span><br><span class="line">        Len  int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  struct string&#123;</span><br><span class="line">    uint8 *str;</span><br><span class="line">    int len;</span><br><span class="line">  &#125;</span><br><span class="line">  struct []uint8&#123;</span><br><span class="line">    uint8 *array;</span><br><span class="line">    int len;</span><br><span class="line">    int cap;</span><br><span class="line">  &#125;</span><br><span class="line">  uintptr是golang的内置类型，是能存储指针的整型，uintptr的底层类型是int，它和unsafe.Pointer可相互转换。</span><br><span class="line">  但是转换后的string与[]byte共享底层空间，如果修改了[]byte那么string的值也会改变，就违背了string应该是只读的规范了，可能会造成难以预期的影响。</span><br><span class="line">*/</span><br><span class="line">func str2byte(s string) []byte &#123;</span><br><span class="line">    x := (*[2]uintptr)unsafe.Pointer(&amp;s)</span><br><span class="line">    h := [3]uintptr&#123;x[0],x[1],x[1]&#125;</span><br><span class="line">    return *(*[]byte)(unsafe.Pointer(&amp;h))</span><br><span class="line">&#125;</span><br><span class="line">func byte2str(b []byte) string&#123;</span><br><span class="line">    return *(*string)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="golang-json问题"><a href="#golang-json问题" class="headerlink" title="golang json问题"></a>golang json问题</h3><ol>
<li>json tag <code>json:&quot;name,omitempty,type&quot;</code> json: “name,[option]”</li>
<li><p>int 为0时，若tag 为omitempty, int会不被序列化出来， omitempty，tag里面加上omitempy，可以在序列化的时候忽略0值或者空值<br> 解决办法是使用 指针</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Test struct &#123;</span><br><span class="line">    String  *string `json:&quot;string,omitempty&quot;`</span><br><span class="line">    Integer *int    `json:&quot;integer,omitempty&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>int8 byte uint8 json序列化的时候 会被当做字符串处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type CA struct &#123;  </span><br><span class="line">    List []uint8  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">func main() &#123;  </span><br><span class="line">    ca := CA&#123;[]uint8&#123;1,2,3,4,5,6,7,8,9,0&#125;&#125;  </span><br><span class="line">    r, _ := json.Marshal(ca)  </span><br><span class="line">    fmt.Println(string(r)) //&#123;&quot;List&quot;:&quot;AQIDBAUGBwgJAA==&quot;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="当我们想给某操作加缓冲区时就可以使用bytes-Buffer"><a href="#当我们想给某操作加缓冲区时就可以使用bytes-Buffer" class="headerlink" title="当我们想给某操作加缓冲区时就可以使用bytes.Buffer"></a>当我们想给某操作加缓冲区时就可以使用bytes.Buffer</h3>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 hello2dj (dj_amazing@sina.com)
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>